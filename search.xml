<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>插入排序</title>
    <url>/2019/01/06/insertion-sort/</url>
    <content><![CDATA[<p>插入排序的平均时间复杂度是<span class="math inline">\(O(n^2)\)</span>,对于少量元素的排序，是个有效的算法</p>
<a id="more"></a>
<p>插入排序的工作方式像许多人排序一手扑克牌。开始时，我们的左手为空并且桌面上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。</p>
<p>插入排序所需的时间取决于输入中元素的初始顺序。例如，对一个很大且其中的元素已经有序（或接近有序）的数组进行排序将会比对随机顺序的数组或逆序数组进行排序要快得多。</p>
<h3 id="伪代码">伪代码</h3>
<p>INSERTION-SORT(A) //对于数组A</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for j &#x3D; 2 to A.length</span><br><span class="line">    key&#x3D;A[i]</span><br><span class="line">    &#x2F;&#x2F;Insert A[j] to the sorted sequence A[1..j-1].</span><br><span class="line">    i &#x3D; j - 1</span><br><span class="line">    while i &gt; 0 and A[i] &gt; key</span><br><span class="line">        A[i+1] &#x3D; A[i]</span><br><span class="line">        i &#x3D; i - 1</span><br><span class="line">    A[i+1] &#x3D; key</span><br></pre></td></tr></table></figure>
<h3 id="简单的实现">简单的实现</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *A;</span><br><span class="line">    <span class="keyword">int</span> length, i, j, key;</span><br><span class="line">    <span class="comment">//输入要排序的数字个数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;length);</span><br><span class="line">    A = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>((length+<span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//输入数字</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= length; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt;= length; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        key = A[j];</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; A[i] &gt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            A[i + <span class="number">1</span>] = A[i];</span><br><span class="line">            i = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        A[i + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= length; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    <span class="built_in">free</span>(A);<span class="comment">//别忘了释放malloc来的空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对插入排序做一些改进我们可以得到一种更高效的排序算法--希尔排序</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>判定是否同一棵二叉搜索树</title>
    <url>/2019/03/23/is-multiple-binary-trees-the-same/</url>
    <content><![CDATA[<p>给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列<span class="math inline">\(\lbrace2, 1, 3\rbrace\)</span>和<span class="math inline">\(\lbrace2, 3, 1\rbrace\)</span>插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。 <a id="more"></a></p>
<h4 id="输入格式">输入格式</h4>
<p>输入包含若干组测试数据。每组数据的第1行给出两个正整数N (≤10)和L，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出N个以空格分隔的正整数，作为初始插入序列。最后L行，每行给出N个插入的元素，属于L个需要检查的序列。</p>
<p>简单起见，我们保证每个插入序列都是1到N的一个排列。当读到N为0时，标志输入结束，这组数据不要处理。</p>
<h4 id="输出格式">输出格式</h4>
<p>对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。</p>
<h4 id="输入样例">输入样例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">3 1 4 2</span><br><span class="line">3 4 1 2</span><br><span class="line">3 2 4 1</span><br><span class="line">2 1</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h4 id="输出样例">输出样例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<h4 id="代码">代码</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Tree Left, Right;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Tree <span class="title">MakeTree</span><span class="params">(<span class="keyword">int</span> N)</span></span>;</span><br><span class="line"><span class="function">Tree <span class="title">insert</span><span class="params">(Tree T, <span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function">Tree <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> V)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(Tree T, <span class="keyword">int</span> V)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">(Tree T, <span class="keyword">int</span> N)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ResetT</span><span class="params">(Tree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span><span class="params">(Tree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, L, i;</span><br><span class="line">    Tree T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span> (N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;L);</span><br><span class="line">        T = MakeTree(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Judge(T, N))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">            ResetT(T);</span><br><span class="line">        &#125;</span><br><span class="line">        FreeTree(T);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">MakeTree</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree T;</span><br><span class="line">    <span class="keyword">int</span> i, V;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;V);</span><br><span class="line">    T = NewNode(V);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;V);</span><br><span class="line">        T = insert(T, V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">insert</span><span class="params">(Tree T, <span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">        T = NewNode(V);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (V &gt; T-&gt;v)</span><br><span class="line">            T-&gt;Right = insert(T-&gt;Right, V);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T-&gt;Left = insert(T-&gt;Left, V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree T = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">    T-&gt;v = V;</span><br><span class="line">    T-&gt;Left = T-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    T-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(Tree T, <span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (V &lt; T-&gt;v)</span><br><span class="line">            <span class="keyword">return</span> check(T-&gt;Left, V);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (V &gt; T-&gt;v)</span><br><span class="line">            <span class="keyword">return</span> check(T-&gt;Right, V);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (V == T-&gt;v)</span><br><span class="line">        &#123;</span><br><span class="line">            T-&gt;flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">(Tree T, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, V, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* flag: 0代表目前还一致，1代表已经不一致*/</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;V);</span><br><span class="line">    <span class="keyword">if</span> (V != T-&gt;v)</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        T-&gt;flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;V);</span><br><span class="line">        <span class="keyword">if</span> ((!flag) &amp;&amp; (!check(T, V)))<span class="comment">/*这么做是为了把所有的输入都读取完，以免对下一组数据造成影响*/</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ResetT</span><span class="params">(Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;Left)</span><br><span class="line">        ResetT(T-&gt;Left);</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;Right)</span><br><span class="line">        ResetT(T-&gt;Right);</span><br><span class="line">    T-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span><span class="params">(Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;Left)</span><br><span class="line">        FreeTree(T-&gt;Left);</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;Right)</span><br><span class="line">        FreeTree(T-&gt;Right);</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试点信息">测试点信息</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试点   提示</span><br><span class="line">0        sample 换顺序。有Yes，有No：根不同，子树根不同。树有单边、有双子树</span><br><span class="line">1        最大N，多组合</span><br><span class="line">2        N&#x3D;1，只有1个节点</span><br><span class="line">3        卡只判断数字相对先后位置的错误算法</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/01/03/hello-world/</url>
    <content><![CDATA[<p>大家好，这里是Miroier。 <a id="more"></a> 第一次拥有自己的博客真的很开心。</p>
<p>以后应该会用这个博客来记录我学习中练习的代码和写的习题以及其它有趣的东西(咕咕咕~)。</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>matlab</title>
    <url>/2020/01/09/matlab/</url>
    <content><![CDATA[<p>笔记来自于《MATLAB2018从入门到精通》</p>
<a id="more"></a>
<h2 id="向量与多项式">向量与多项式</h2>
<h3 id="向量">向量</h3>
<h4 id="向量的生成">向量的生成</h4>
<h5 id="直接输入法">直接输入法</h5>
<img src="/2020/01/09/matlab/1_1.png" class="">
<img src="/2020/01/09/matlab/1_2.png" class="">
<h5 id="冒号法">冒号法</h5>
<img src="/2020/01/09/matlab/1_3.png" class="">
<h5 id="利用函数linspace创建向量">利用函数linspace创建向量</h5>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">linspace</span>(first_value, last_value, number)</span><br></pre></td></tr></table></figure>
<img src="/2020/01/09/matlab/1_4.png" class="">
<h5 id="利用函数logspace创建对数分割的向量">利用函数logspace创建对数分割的向量</h5>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">logspace</span>(first_value, last_value, number)</span><br></pre></td></tr></table></figure>
<img src="/2020/01/09/matlab/1_5.png" class="">
<h4 id="向量元素的引用">向量元素的引用</h4>
<table>
<thead>
<tr class="header">
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>x(n)</td>
<td>表示向量中的第n个元素</td>
</tr>
<tr class="even">
<td>x(n1:n2)</td>
<td>表示向量中的第n1至n2个元素</td>
</tr>
</tbody>
</table>
<h4 id="向量运算">向量运算</h4>
<h5 id="四则运算">四则运算</h5>
<img src="/2020/01/09/matlab/1_6.png" class="" title="对向量进行定义、赋值">
<img src="/2020/01/09/matlab/1_7.png" class="" title="加法">
<img src="/2020/01/09/matlab/1_8.png" class="" title="减法">
<img src="/2020/01/09/matlab/1_9.png" class="" title="乘法">
<img src="/2020/01/09/matlab/1_10.png" class="" title="除法">
<h5 id="点积运算">点积运算</h5>
<table>
<thead>
<tr class="header">
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>dot(a,b)</td>
<td>返回向量a与b的点积。a和b必须同维,当a、b都是列向量时，dot(a,b)等同于a.*b</td>
</tr>
<tr class="even">
<td>dot(a,b,dim)</td>
<td>返回向量a和b在dim维的点积</td>
</tr>
</tbody>
</table>
<img src="/2020/01/09/matlab/1_11.png" class="">
<h5 id="叉积运算">叉积运算</h5>
<table>
<thead>
<tr class="header">
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>cross(a,b)</td>
<td>返回向量a与b的叉积。a和b必须是三维的向量</td>
</tr>
<tr class="even">
<td>cross(a,b,dim)</td>
<td>返回向量a和b在dim维的点积。a和b需要有相同的维数，size(a,dim)和size(b,dim)的结果必须为3</td>
</tr>
</tbody>
</table>
<img src="/2020/01/09/matlab/1_12.png" class="">
<h5 id="混合积运算">混合积运算</h5>
<img src="/2020/01/09/matlab/1_13.png" class="">
<h3 id="多项式">多项式</h3>
<h4 id="多项式的创建">多项式的创建</h4>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">poly2sym(p) <span class="comment">%p为多项式的系数</span></span><br></pre></td></tr></table></figure>
<img src="/2020/01/09/matlab/1_14.png" class="">
<h4 id="多项式四则运算">多项式四则运算</h4>
<h5 id="乘法">乘法</h5>
<p><code>conv(p1,p2)</code> <img src="/2020/01/09/matlab/1_15.png" class=""></p>
<h5 id="除法">除法</h5>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[k,r]=deconv(p,q)</span><br></pre></td></tr></table></figure>
<p>k是p除以q的商，r是余式。 上式等价于</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">p=conv[q,k]+r;</span><br></pre></td></tr></table></figure>
<img src="/2020/01/09/matlab/1_16.png" class="">
<h4 id="多项式导数运算">多项式导数运算</h4>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">polyder(p) <span class="comment">%p为多项式的系数</span></span><br></pre></td></tr></table></figure>
<img src="/2020/01/09/matlab/1_17.png" class="">
<h2 id="矩阵运算">矩阵运算</h2>
<h3 id="矩阵创建">矩阵创建</h3>
<h4 id="利用m文件创建">利用M文件创建</h4>
<img src="/2020/01/09/matlab/2_1.png" class="">
<img src="/2020/01/09/matlab/2_2.png" class="">
<h4 id="利用文本创建">利用文本创建</h4>
<img src="/2020/01/09/matlab/2_3.png" class="">
<img src="/2020/01/09/matlab/2_4.png" class="">
<h4 id="创建特殊矩阵">创建特殊矩阵</h4>
<img src="/2020/01/09/matlab/2_5.png" class="">
<h3 id="矩阵元素的运算">矩阵元素的运算</h3>
<h4 id="矩阵元素的修改">矩阵元素的修改</h4>
<table>
<colgroup>
<col style="width: 43%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="header">
<th>命令名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>D=[A;B C]</td>
<td>A为原矩阵，B、C中包含要扩充的元素，D为扩充后的矩阵</td>
</tr>
<tr class="even">
<td>A(m;:)=[]</td>
<td>删除A的第m行</td>
</tr>
<tr class="odd">
<td>A(:,n)</td>
<td>删除A的第n列</td>
</tr>
<tr class="even">
<td>A(m,n)=a; A(m,:)=[a b ...]; A(:,n)=[a b ...]</td>
<td>对A的第m列第n行的元素赋值；对A的第m行赋值；对A的第n列赋值</td>
</tr>
</tbody>
</table>
<img src="/2020/01/09/matlab/2_6.png" class="">
<h4 id="矩阵的变维">矩阵的变维</h4>
<img src="/2020/01/09/matlab/2_7.png" class="">
<img src="/2020/01/09/matlab/2_8.png" class="">
<h4 id="矩阵的变向">矩阵的变向</h4>
<table>
<thead>
<tr class="header">
<th>命令名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Rot(90)</td>
<td>将A逆时针方向旋转90°</td>
</tr>
<tr class="even">
<td>Rot(90,k)</td>
<td>将A逆时针方向旋转90° *k，k可为正整数或负整数</td>
</tr>
<tr class="odd">
<td>Fliplr(X)</td>
<td>将X左右翻转</td>
</tr>
<tr class="even">
<td>flipud(X)</td>
<td>将X上下翻转</td>
</tr>
<tr class="odd">
<td>flipdim(X,dim)</td>
<td>dim=1时对行翻转,dim=2时对列翻转</td>
</tr>
</tbody>
</table>
<img src="/2020/01/09/matlab/2_9.png" class="">
<h4 id="矩阵的抽取">矩阵的抽取</h4>
<p>矩阵的抽取主要是指对角元素和上（下）三角阵的抽取。 <img src="/2020/01/09/matlab/2_10.png" class=""> <img src="/2020/01/09/matlab/2_11.png" class=""></p>
<h3 id="矩阵的数学运算">矩阵的数学运算</h3>
<h4 id="加减">加减</h4>
<p>只有相同维度的矩阵才能进行计算 <img src="/2020/01/09/matlab/2_12.png" class=""> 减法只需将<code>+</code>改成<code>-</code></p>
<h4 id="乘法-1">乘法</h4>
<h5 id="数乘">数乘</h5>
<img src="/2020/01/09/matlab/2_13.png" class="">
<h5 id="矩阵乘法">矩阵乘法</h5>
<img src="/2020/01/09/matlab/2_14.png" class="">
<h5 id="点乘">点乘</h5>
<img src="/2020/01/09/matlab/2_15.png" class="">
<h4 id="除法-1">除法</h4>
<p>计算左除A，A的行数要与B的行数一致，计算右除A/B时，A的列数要与B的列数一致。</p>
<h5 id="左除">左除</h5>
<img src="/2020/01/09/matlab/2_16.png" class="">
<h5 id="右除">右除</h5>
<img src="/2020/01/09/matlab/2_17.png" class="">
<h3 id="矩阵运算-1">矩阵运算</h3>
<img src="/2020/01/09/matlab/2_18.png" class="">
<h4 id="幂函数">幂函数</h4>
<img src="/2020/01/09/matlab/2_19.png" class="">
<p>另外还有指数函数，对数函数，平方根函数等。</p>
<h4 id="矩阵的逆">矩阵的逆</h4>
<img src="/2020/01/09/matlab/2_20.png" class="">
<img src="/2020/01/09/matlab/2_21.png" class="">
<p>操作的对象必须是方阵</p>
<h4 id="矩阵的条件数">矩阵的条件数</h4>
<img src="/2020/01/09/matlab/2_22.png" class="">
<h4 id="矩阵的范数">矩阵的范数</h4>
<img src="/2020/01/09/matlab/2_23.png" class="">
<h2 id="二维绘图">二维绘图</h2>
<h3 id="二维绘图-1">二维绘图</h3>
<h4 id="plot">plot</h4>
<p><code>plot(x)</code> <img src="/2020/01/09/matlab/3_1.png" class=""></p>
<p><code>plot(x,y)</code> <img src="/2020/01/09/matlab/3_2.png" class=""></p>
<p><code>subplot(x,y)</code> <img src="/2020/01/09/matlab/3_3.png" class=""></p>
<p><code>plot(x,y,s)</code> s用来设置所画数据点的类型、大小、颜色以及数据点之间连线的类型、粗细、颜色等。 <img src="/2020/01/09/matlab/3_4.png" class="" title="颜色控制字符表"> <img src="/2020/01/09/matlab/3_5.png" class="" title="线性符号及说明"> <img src="/2020/01/09/matlab/3_6.png" class="" title="hanzibuxing"></p>
<p><code>plot(x1,y1,s1,x2,y2,s2,···)</code> 运行此命令等价于依次执行plot(xi,yi,si),i=1,2,...</p>
<h4 id="fplot">fplot</h4>
<p>  fplot命令也是MATLAB提供的一个画图命令，它是一个专门用于画一元函数图像的命令。<br />
  虽然plot命令也可以画一元函数图像，但plot命令是依据我们给定的数据点来作图的，而在实际情况中，一般并不清楚函数的具体情况，因此依据我们所选取的数据点作的图像可能会忽略真实函数的某些重要特性，给科研工作造成不可估计的损失。MATLAB提供了专门绘制一元函数图像的fplot命令，它用来指导数据点的选取，通过其内部自适应算法，在函数变化比较平稳处，它所取的数据点就会相对稀疏一点，在函数变化明显处所取的数据点就会自动密一些，因此用fplot命令所作出的图像要比用plot命令作出的图像光滑准确。 <img src="/2020/01/09/matlab/3_7.png" class="" title="fplot的调用格式"> <img src="/2020/01/09/matlab/3_8.png" class="" title="对于上面用法的几点说明"></p>
<h4 id="ezplot">ezplot</h4>
<p>ezplot可以很容易地将一个符号函数图形化 <img src="/2020/01/09/matlab/3_9.png" class="" title="ezplot 命令的调用格式"> <img src="/2020/01/09/matlab/3_10.png" class=""> <img src="/2020/01/09/matlab/3_11.png" class=""></p>
<h3 id="不同坐标系下的绘图命令">不同坐标系下的绘图命令</h3>
<h4 id="极坐标系下绘图">极坐标系下绘图</h4>
<img src="/2020/01/09/matlab/3_12.png" class="">
<img src="/2020/01/09/matlab/3_13.png" class="">
<img src="/2020/01/09/matlab/3_14.png" class="">
<h2 id="图形标注">图形标注</h2>
<h3 id="图形属性设置">图形属性设置</h3>
<h4 id="坐标系与坐标轴">坐标系与坐标轴</h4>
<h5 id="坐标系的调整">坐标系的调整</h5>
<p>  MATLAB的绘图函数可根据要绘制的曲线数据的范围自动选择合适的坐标系，使得曲线尽可能清晰的显示出来。所以，一般情况下用户不必自己选择绘图坐标。但是有些图形，如果用户感觉自动选择的坐标不合适，则可以利用函数axis()选择新的坐标系。<br />
  函数axis()的调用格式为：<code>axis(xmin,xmax,ymin,ynax,zmin,zmax}</code>   这个函数格式的功能是设置x, y, z 坐标的最小值和最大值。函数输入参数可以是4个，也可以是6个，分别对应于二维或三维坐标系的最大和最小值。</p>
<h5 id="坐标轴的调整">坐标轴的调整</h5>
<p>axis命令用于控制坐标轴的显示、刻度、长度等特征</p>
<img src="/2020/01/09/matlab/4_1.png" class="" title="axis 命令的调用格式">
<img src="/2020/01/09/matlab/4_2.png" class="">
<img src="/2020/01/09/matlab/4_3.png" class="">
<img src="/2020/01/09/matlab/4_4.png" class="">
<h4 id="图形注释">图形注释</h4>
<h5 id="填充图形">填充图形</h5>
<p>fill 函数用于填充二维封闭多边形，其函数格式如下所示。 <img src="/2020/01/09/matlab/4_5.png" class=""> <img src="/2020/01/09/matlab/4_6.png" class=""> <img src="/2020/01/09/matlab/4_7.png" class=""></p>
<h5 id="注释图形标题及轴名称">注释图形标题及轴名称</h5>
<p>MATLAB中，title命令用于给图形对象加标题。</p>
<img src="/2020/01/09/matlab/4_8.png" class="" title="title 命令的格式调用">
<p><strong>说明：</strong>可以利用gcf 与gca 来获取当前图形窗口与当前坐标轴的旬柄。</p>
<p>  对坐标轴进行标注，相应的命令为xlabel、ylabel、zlabel，作用分别是对x轴、y轴、z轴进行标注，它们的调用格式都是一样的。</p>
<img src="/2020/01/09/matlab/4_9.png" class="" title="xlabel 命令的调用格式">
<h5 id="图形标注-1">图形标注</h5>
<p>  在给所绘得的图形进行详细的标注时，最常用的两个命令是text与gtext，它们均可以在图形的具体部位进行标注。</p>
<h5 id="text命令">text命令</h5>
<img src="/2020/01/09/matlab/4_10.png" class="" title="text 命令的调用格式">
<img src="/2020/01/09/matlab/4_11.png" class="" title="text 命令属性列表">
<img src="/2020/01/09/matlab/4_12.png" class="" title="续表">
<p>上表中的这些属性及相应的值都可以通过get 命令来查看，以及用set 命令来修改。</p>
<h5 id="gtext命令">gtext命令</h5>
<p>  gtext命令可以让鼠标在图形的任意位置进行标注。当光标进入图形窗口时，会变成一个大十字架形，等待用户的操作。调用格式如下：</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">gtext (<span class="string">'string'</span>,<span class="string">'property'</span>, propertyvalue,···)</span><br></pre></td></tr></table></figure>
<p>  调用这个函数后，图形窗口中的鼠标指针会成为十字光标，通过移动鼠标来进行定位，即光标移到预定位置后按下鼠标左键或键盘上的任意键都会在光标位置显示指定文本“string”。由于要用鼠标操作，该函数只能在MATLAB命令行窗口中进行。</p>
<h5 id="图例标注">图例标注</h5>
<p>  当在一幅图中出现多种曲线时，用户可以根据自己的需要，利用legend 命令对不同的图例进行说明。</p>
<img src="/2020/01/09/matlab/4_13.png" class="" title="legend 命令的调用格式">
<img src="/2020/01/09/matlab/4_14.png" class="" title="pos取值">
<h5 id="分隔线控制">分隔线控制</h5>
<img src="/2020/01/09/matlab/4_15.png" class="" title="grid 命令的调用格式">
<h3 id="特殊图形">特殊图形</h3>
<h4 id="统计图形">统计图形</h4>
<h5 id="条形图">条形图</h5>
<p>  绘制条形图时可分为二维情况和三维情况，其中绘制二维条形图的命令为bar（竖直条形图）与barh（水平条形图）；绘制三维条形图的命令为bar3（竖直条形图）与bar3h（水平条形图）。它们的调用格式都是一样的，因此我们只介绍bar的调用格式</p>
<img src="/2020/01/09/matlab/4_16.png" class="" title="bar 命令的调用格式">
<h5 id="面积图">面积图</h5>
<p>  面积图在实际中可以表现不同部分对整体的影响。在MATLAB中，绘制面积图的命令是area，它的调用格式见表</p>
<img src="/2020/01/09/matlab/4_17.png" class="" title="area 命令的调用格式">
<h5 id="饼图">饼图</h5>
<p>  饼图用来显示向量或矩阵中各元素所占的比例，它可以用在一些统计数据可视化中。在二维情况下，创建饼图的命令是pie，三维情况下创建饼图的命令是pie3，二者的调用格式也非常相似，因此我们只介绍pie的调用格式。</p>
<img src="/2020/01/09/matlab/4_18.png" class="" title="pie 命令的调用格式">
<h5 id="柱状图">柱状图</h5>
<p>MATLAB中，绘制柱状图的命令有两个：<br />
hist命令：它用来绘制直角坐标系下的柱状图。<br />
rose命令：它用来绘制极坐标系下的柱状图。</p>
<img src="/2020/01/09/matlab/4_19.png" class="" title="hist 命令的调用格式">
<img src="/2020/01/09/matlab/4_20.png" class="" title="rose 命令的调用格式">
<blockquote>
<p>实例一一各个季度所占营利总额的比例统计图 <img src="/2020/01/09/matlab/4_21.png" class=""> <img src="/2020/01/09/matlab/4_22.png" class=""></p>
</blockquote>
<p><strong>注意：</strong>饼图的标注比较特别，其标签是作为文本图形对象来处理的，如果要修改标注文本字符串或位置，则首先要获取相应对象的字符串及其范围，然后再加以修改。</p>
<blockquote>
<p>实例一一绘制柱状图 <img src="/2020/01/09/matlab/4_23.png" class=""> <img src="/2020/01/09/matlab/4_24.png" class=""> <img src="/2020/01/09/matlab/4_25.png" class="" title="直角坐标系和极坐标系下的柱状图"></p>
</blockquote>
<h4 id="离散数据图形">离散数据图形</h4>
<p>  除了上面提到的统计图形外，MATLAB还提供了一些在工程计算中常用的离散数据图形，例如误差棒图、火柴杆图与阶梯图等。</p>
<h5 id="误差棒图">误差棒图</h5>
<p>MATLAB 中绘制误差棒图的命令为errorbar</p>
<img src="/2020/01/09/matlab/4_26.png" class="" title="errorbar 命令的调用格式">
<blockquote>
<p>实例一一绘制铸件尺寸误差棒图 <img src="/2020/01/09/matlab/4_27.png" class=""></p>
</blockquote>
<h5 id="火柴杆图">火柴杆图</h5>
<p>  用线条显示数据点与x轴的距离，用一小圆圈（默认标记〉或用指定的其他标记符号与线条相连，并在y轴上标记数据点的值，这样的图形称为火柴杆图。在二维情况下，实现这种操作的命令是stem。</p>
<img src="/2020/01/09/matlab/4_28.png" class="" title="stem命令的调用格式">
<p>在三维情况下，也有相应的画火柴杆图的命令stem3。</p>
<img src="/2020/01/09/matlab/4_29.png" class="" title="stem3命令的调用格式">
<blockquote>
<p>实例一一绘制火柴杆图 <img src="/2020/01/09/matlab/4_30.png" class=""> <img src="/2020/01/09/matlab/4_31.png" class=""></p>
</blockquote>
<h5 id="阶梯图">阶梯图</h5>
<p>  阶梯图在电子信息工程以及控制理论中用得非常多，在MATLAB 中，实现这种作图的命令是stairs。</p>
<img src="/2020/01/09/matlab/4_32.png" class="" title="stairs 命令的调用格式">
<blockquote>
<p>实例一一给制阶梯图 <img src="/2020/01/09/matlab/4_33.png" class=""> <img src="/2020/01/09/matlab/4_34.png" class=""></p>
</blockquote>
<h4 id="向量图形">向量图形</h4>
<p>  由于物理等学科的需要，在实际中有时需要绘制一些带方向的图形，即向量图。对于这种图形的绘制， MATLAB 中也有相关的命令，本小节就来学一下几个常用的命令。</p>
<h5 id="罗盘图">罗盘图</h5>
<p>  罗盘图即起点为坐标原点的二维或三维向量，同时还在坐标系中显示圆形的分隔线。实现这种作图的命令是compass。</p>
<img src="/2020/01/09/matlab/4_35.png" class="" title="compass 命令的调用格式">
<h5 id="羽毛图">羽毛图</h5>
<p>  羽毛图是在横坐标上等距地显示向量的图形，看起来就像鸟的羽毛一样。它的绘制命令是feather。</p>
<img src="/2020/01/09/matlab/4_36.png" class="" title="feather 命令的调用格式">
<blockquote>
<p>实例一一罗盘图与羽毛图 <img src="/2020/01/09/matlab/4_37.png" class=""> <img src="/2020/01/09/matlab/4_38.png" class=""></p>
</blockquote>
<h5 id="箭头图">箭头图</h5>
<p>  上面两个命令绘制的图也可以叫做箭头图，但即将要讲的箭头图比上面两个箭头图更像数学中的向量，即它的箭头方向为向量方向，箭头的长短表示向量的大小。这种图的绘制命令是quiver与quiver3 ，前者绘制的是二维图形，后者绘制是三维图形。它们的调用格式也十分相似，只是后者比前者多一个坐标参数，因此我们只介绍一下quiver的调用格式。</p>
<img src="/2020/01/09/matlab/4_39.png" class="" title="quiver 命令的调用格式">
<p>quiver与quiver3这两个命令经常与其他的绘图命令配合使用，见下例。</p>
<blockquote>
<p>实例一一绘制箭头图形 <img src="/2020/01/09/matlab/4_40.png" class=""> <img src="/2020/01/09/matlab/4_41.png" class=""></p>
</blockquote>
<h2 id="三维绘图">三维绘图</h2>
<h3 id="三维绘图-1">三维绘图</h3>
<p>  在实际的工程设计中， 二维绘图功能在某些场合往往无法更直观地表达数据的分析结果，常常需要将结果表示成三维图形。MATLAB 为此提供了相应的三维绘图功能，三维绘图与二维绘图功能有异曲同工之效。用于三维绘图的MATLAB 高级绘图函数中，对于上述许多问题都设置了默认值，应尽量使用默认值。<br />
  为了显示三维图形， MATLAB 提供了各种各样的函数。有一些函数可在三维空间中画线，而另一些可以画曲面与线格框架。另外，颜色可以用来代表第四维。当颜色以这种方式使用时，不但它不再具有像照片中那样显示色彩的自然属性，而且也不具有基本数据的内在属性，所以把它称作为彩色。本章主要介绍三维图形的作图方法和效果。</p>
<h4 id="三维曲线绘图命令">三维曲线绘图命令</h4>
<h5 id="plot3">plot3</h5>
<p>  plot3命令是二维绘图plot命令的扩展，因此它们的使用格式也基本相同，只是在参数中多加了一个第三维的信息。例如plot(x,y,z)与plot3(x,y,z,s)的意义是一样的，前者绘的是二维图，后者绘的是三维图，后面的参数s也是用来控制曲线的类型、粗细、颜色等。</p>
<blockquote>
<p>实例一一绘制空间直线 <img src="/2020/01/09/matlab/5_1.png" class=""> <img src="/2020/01/09/matlab/5_2.png" class=""> 实例一一绘制三维曲线 <img src="/2020/01/09/matlab/5_3.png" class=""> <img src="/2020/01/09/matlab/5_4.png" class=""></p>
</blockquote>
<h5 id="ezplot3">ezplot3</h5>
<p>  同二维情况一样， 三维绘图里也有一个专门绘制符号函数的命令ezplot3。 <img src="/2020/01/09/matlab/5_5.png" class=""></p>
<h4 id="三维网格命令">三维网格命令</h4>
<h5 id="mesh">mesh</h5>
<p>  该命令生成的是由X、Y和Z指定的网线面，而不是单根曲线。</p>
<img src="/2020/01/09/matlab/5_6.png" class="">
<p>  在演示之前，我们先来学一个常用的命令meshgrid，它用来生成二元函数z=f(x,y)中xy平面上的矩形定义域中数据点矩阵X和Y，或者是三元函数u=f(x,y,z)中立方体定义域中的数据点矩阵X、Y和Z。</p>
<img src="/2020/01/09/matlab/5_7.png" class="">
<blockquote>
<p>实例一一绘制网格面 <img src="/2020/01/09/matlab/5_8.png" class=""> <img src="/2020/01/09/matlab/5_9.png" class=""></p>
</blockquote>
<p>  对于一个三维网格图，有时用户不想显示背后的网格，这时可以利用hidden 命令来实现这种要求。它的使用格式也非常简单。</p>
<img src="/2020/01/09/matlab/5_10.png" class="" title="hidden 命令的调用格式">
<blockquote>
<p>实例一一绘制山峰曲面 <img src="/2020/01/09/matlab/5_11.png" class=""> <img src="/2020/01/09/matlab/5_12.png" class=""></p>
</blockquote>
<p>  MATLAB还有两个同类的函数：meshc与meshz。meshc用来画图形的网格图加基本的等高线图，meshz用来画图形的网格图与零平面的网格图。</p>
<blockquote>
<p>实例一一绘制函数曲面 <img src="/2020/01/09/matlab/5_13.png" class=""> <img src="/2020/01/09/matlab/5_14.png" class=""></p>
</blockquote>
<h5 id="ezmesh">ezmesh</h5>
<p>  该命令专门用来绘制符号函数f(x, y) （即f是关于x 、y 的数学函数的字符串表示）的网格图形。</p>
<img src="/2020/01/09/matlab/5_15.png" class="" title="ezmesh 命令的调用格式">
<blockquote>
<p>实例一一绘制符号函数曲面 <img src="/2020/01/09/matlab/5_16.png" class=""> <img src="/2020/01/09/matlab/5_17.png" class=""></p>
</blockquote>
<h4 id="三维曲面命令">三维曲面命令</h4>
<h5 id="surf">surf</h5>
<p>  surf命令的调用格式与mesh命令完全一样，这里就不再详细说明了。下面给出几个例子。</p>
<blockquote>
<p>实例一一绘制山峰表面 <img src="/2020/01/09/matlab/5_18.png" class=""> <img src="/2020/01/09/matlab/5_19.png" class=""></p>
</blockquote>
<p>  如果想查看曲面背后图形的情况，可以在曲面的相应位置打个洞孔，即将数据设置为NaN,所有的MATLAB作图函数都忽略NaN的数据点，在该点出现的地方留下一个洞孔。</p>
<blockquote>
<p>实例一一绘制带洞孔的山峰表面 <img src="/2020/01/09/matlab/5_20.png" class=""> <img src="/2020/01/09/matlab/5_21.png" class=""></p>
</blockquote>
<h5 id="ezsurf">ezsurf</h5>
<p>  该命令专门用来绘制符号函数f(x,y)（即f是关于x、y的数学函数的字符串表示）的表面图形。</p>
<img src="/2020/01/09/matlab/5_22.png" class="" title="ezsurf 命令的调用格式">
<blockquote>
<p>绘制参数曲面 <img src="/2020/01/09/matlab/5_23.png" class=""> <img src="/2020/01/09/matlab/5_24.png" class=""></p>
</blockquote>
<h4 id="柱面与球面">柱面与球面</h4>
<p>  在MATLAB中，有专门绘制柱面与球面的命令cylinder与sphere，它们的使用格式也非常简单。首先来看cylinder命令。</p>
<img src="/2020/01/09/matlab/5_25.png" class="">
<blockquote>
<p>实例一一绘制柱面 <img src="/2020/01/09/matlab/5_26.png" class=""> <img src="/2020/01/09/matlab/5_27.png" class=""></p>
</blockquote>
<p><strong>小技巧：</strong>用cylinder可以作棱柱的图像，例如运行cylinder(2,6)将绘出底面为正六边形、半径为2的棱柱。</p>
<p>  sphere命令用来生成三维直角坐标系中的球面。</p>
<img src="/2020/01/09/matlab/5_28.png" class="" title="sphere 命令的调用格式">
<blockquote>
<p>实例一一绘制球面 <img src="/2020/01/09/matlab/5_29.png" class=""> <img src="/2020/01/09/matlab/5_30.png" class=""></p>
</blockquote>
<h4 id="三维图形等值线">三维图形等值线</h4>
<p>  在军事、地理等学科中经常会用到等值线。在MATLAB中有许多绘制等值线的命令，我们主要介绍以下几个。</p>
<h5 id="contour3">contour3</h5>
<p>  contour3是三维绘图中最常用的绘制等值线的命令，该命令生成一个定义在矩形格栅上曲面的三维等值线图。</p>
<img src="/2020/01/09/matlab/5_31.png" class="" title="contour 命令的调用格式">
<blockquote>
<p>实例一一三维等值线图 <img src="/2020/01/09/matlab/5_32.png" class=""> <img src="/2020/01/09/matlab/5_33.png" class=""></p>
</blockquote>
<h5 id="contour">contour</h5>
<p>  contour3用于绘制二维图时就等价于contour，后者用来绘制二维等值线，可以看作是一个三维曲面向xy平面上的投影。</p>
<img src="/2020/01/09/matlab/5_34.png" class="" title="contour">
<blockquote>
<p>实例一一绘制二维等值线图 <img src="/2020/01/09/matlab/5_35.png" class=""> <img src="/2020/01/09/matlab/5_36.png" class=""></p>
</blockquote>
<h5 id="contourf">contourf</h5>
<p>  此命令用来填充二维等值线图，即先画出不同等值线，然后将相邻的等值线之间用同一颜色进行填充，填充用的颜色决定于当前的色图颜色。</p>
<img src="/2020/01/09/matlab/5_37.png" class="" title="contourf 命令的调用格式">
<blockquote>
<p>实例一一绘制二维等值线图及颜色填充 <img src="/2020/01/09/matlab/5_38.png" class=""> <img src="/2020/01/09/matlab/5_39.png" class=""></p>
</blockquote>
<h5 id="contourc">contourc</h5>
<p>  该命令计算等值线矩阵C，该矩阵可用于命令contour、contour3 和contourf等。矩阵Z中的数值确定平面上的等值线高度值，等值线的计算结果用由矩阵Z维数决定的间隔的宽度。</p>
<img src="/2020/01/09/matlab/5_40.png" class="" title="contourc 命令的调用格式">
<h5 id="clabel">clabel</h5>
<p>  clabel命令用来在二维等值线图中添加高度标签。</p>
<img src="/2020/01/09/matlab/5_41.png" class="">
<p>对上面的使用格式，需要说明的一点是，若命令中有h，则会对标签进行恰当的旋转，否则标签会竖直放置，且在恰当的位置显示一个“＋” 号。</p>
<blockquote>
<p>实例一一绘制等值线 <img src="/2020/01/09/matlab/5_42.png" class=""> <img src="/2020/01/09/matlab/5_43.png" class=""></p>
</blockquote>
<h5 id="ezcontour">ezcontour</h5>
<p>  该命令专门用来绘制符号函数f(x,y)（即f是关于x、y的数学函数的字符串表示）的等值线图。</p>
<img src="/2020/01/09/matlab/5_44.png" class="" title="ezcontour 命令的调用格式">
<blockquote>
<p>实例一一绘制符号函数等值线图 <img src="/2020/01/09/matlab/5_45.png" class=""> <img src="/2020/01/09/matlab/5_46.png" class=""></p>
</blockquote>
<h5 id="ezsurfc">ezsurfc</h5>
<p>  该命令用来绘制函数f(x,y)的带等值线的三维表面图，其中函数f是一个以字符串形式给出的二元函数。</p>
<img src="/2020/01/09/matlab/5_47.png" class="" title="ezsurfc 命令的调用格式">
<blockquote>
<p>实例一一绘制带等值线的三维表面图 <img src="/2020/01/09/matlab/5_48.png" class=""> <img src="/2020/01/09/matlab/5_49.png" class=""></p>
</blockquote>
<h3 id="三维图像修饰处理">三维图像修饰处理</h3>
<h4 id="视角处理">视角处理</h4>
<p>  在现实空间中，从不同角度或位置观察某一事物就会有不同的效果，即会有“横看成岭侧成峰”的感觉。三维图形表现的正是一个空间内的图形，因此在不同视角及位置都会有不同的效果，这在工程实际中也是经常遇到的。MATLAB 提供的view 命令能够很好地满足这种需要。   view 命令用来控制三维图形的观察点和视角。</p>
<img src="/2020/01/09/matlab/5_50.png" class="" title="view 命令的调用格式">
<p>  对于这个命令需要说明的是，方位角az与仰角el为两个旋转角度。做一通过视点和z轴平行的平面，与xy平面有一交线，该交线与y轴的反方向的、按逆时针方向（从z轴的方向观察）计算的夹角，就是观察点的方位角az；若角度为负值，则按顺时针方向计算。在通过视点与z轴的平面上，用一直线连接视点与坐标原点，该直线与xy平面的夹角就是观察点的仰角el；若仰角为负值，则观察点转移到曲面下面。</p>
<blockquote>
<p>实例一一绘制网格面视图 <img src="/2020/01/09/matlab/5_51.png" class=""> <img src="/2020/01/09/matlab/5_52.png" class=""></p>
</blockquote>
<h4 id="颜色处理">颜色处理</h4>
<h5 id="色图明暗控制命令">色图明暗控制命令</h5>
<p>MATLAB中，控制色图明暗的命令是brighten命令。</p>
<img src="/2020/01/09/matlab/5_53.png" class="" title="brighten 命令的调用格式">
<h5 id="色轴刻度">色轴刻度</h5>
<p>  caxis命令控制着对应色图的数据值的映射图。它通过将被变址的颜色数据（CData）与颜色数据映射（CDataMapping）设置为scaled，影响着任何的表面、块、图像：该命令还改变坐标轴图形对象的属性Clim与ClimMode。</p>
<img src="/2020/01/09/matlab/5_54.png" class="" title="caxis 命令的调用格式">
<blockquote>
<p>实例一一映射球面表里颜色 <img src="/2020/01/09/matlab/5_55.png" class=""> <img src="/2020/01/09/matlab/5_56.png" class=""></p>
</blockquote>
<p>  在MATLAB中，还有一个画色轴的命令colorbar，这个命令在图形窗口的工具条中有相应的图标。</p>
<img src="/2020/01/09/matlab/5_57.png" class="" title="colorbar 命令的调用格式} ##### 颜色渲染设置 &amp;emsp;&amp;emsp;shading命令用来控制曲面与补片等的图形对象的颜色渲染，同时设置当前坐标轴中的所有曲面与补片图形对象的属性EdgeColor与FaceColor。 {% asset_img 5_58.png shading 命令的调用格式">
<blockquote>
<p>实例一一渲染图形 <img src="/2020/01/09/matlab/5_59.png" class=""> <img src="/2020/01/09/matlab/5_60.png" class=""></p>
</blockquote>
<h5 id="颜色映像使用">颜色映像使用</h5>
<p>  语句colormap(M)将矩阵M作为当前图形窗口所用的颜色映像。例如，colormap(cool)装入了一个有64个输入项的cool颜色映像。colormap default装入了默认的颜色映像（hsv）。<br />
  函数plot、plot3、contour和contour3不使用颜色映像，它们使用列在plot颜色和线形表中的颜色。而大多数其他绘图函数，比如mesh、surf、fill、pcolor和它们的各种变形函数，使用当前的颜色映像。<br />
  接受颜色参量的绘图函数中的颜色参量通常采用以下3 种形式之一:</p>
<ol type="1">
<li>字符串，代表plot颜色或线型表中的一种颜色，比如'r'代表红色。</li>
<li>3个输入的行向量，它代表一个单独的RGB值，比如[.25 .50 .75]。</li>
<li>矩阵，如果颜色参量是一个矩阵，其元素做了调整，并把它们用作当前颜色映射的下标。</li>
</ol>
<blockquote>
<p>实例一一颜色映像 <img src="/2020/01/09/matlab/5_61.png" class=""> <img src="/2020/01/09/matlab/5_62.png" class=""></p>
</blockquote>
<h4 id="光照处理">光照处理</h4>
<p>  在MATLAB中绘制三维图形时，我们不仅可以画出带光照模式的曲面，还能在绘图时指定光线的来源。</p>
<h5 id="带光照模式的三维曲面">带光照模式的三维曲面</h5>
<p>  surfl命令用来画一个带光照模式的三维曲面图，该命令显示一个带阴影的曲面，结合了周围的、散射的和镜面反射的光照模式。想获得较平滑的颜色过渡，则需要使用有线性强度变化的色图（如gray、copper、bone、pink等）。</p>
<img src="/2020/01/09/matlab/5_63.png" class="" title="surlf 命令的调用格式">
<p>  对于这个命令的调用格式需要说明的一点是，参数X, Y, Z确定的点定义了参数曲面的“里面”和“外面”，若用户想曲面的“里面”有光照模式，只要使用surfl(X',Y',Z')即可。</p>
<blockquote>
<p>实例一一三维图形添加光照 <img src="/2020/01/09/matlab/5_64.png" class=""> <img src="/2020/01/09/matlab/5_65.png" class=""></p>
</blockquote>
<h5 id="光源位置及照明模式">光源位置及照明模式</h5>
<p>  在绘制带光照的三维图像时，可以利用light命令与lightangle命令来确定光源位置，其中light命令使用格式非常简单，即为：<br />
  light('color',s1,'style',s2,'position',s3)，其中color、style与position的位置可以互换，s1、s2、s3为相应的可选值。例如，light(’position’,[1 0 0])表示光源从无穷远处沿x轴向原点照射过来。</p>
<img src="/2020/01/09/matlab/5_66.png" class="" title="lightangle 命令的调用格式">
<p>  在确定了光源位置后，用户可能还会用到一些照明模式，这一点可以利用lighting命令来实现，它主要用四种使用格式，即有四种照明模式。</p>
<img src="/2020/01/09/matlab/5_67.png" class="" title="lighting 命令的调用格式">
<blockquote>
<p>实例一一色彩变幻 <img src="/2020/01/09/matlab/5_68.png" class=""> <img src="/2020/01/09/matlab/5_69.png" class=""></p>
</blockquote>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2019/01/13/selection-sort/</url>
    <content><![CDATA[<p>选择排序是一种很容易理解和实现的简单排序算法。<br />
<a id="more"></a><br />
首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。因为它在不断地选择剩余元素之中的最小者，所以这种方法叫选择排序。</p>
<p>它有两个很鲜明的特点：<br />
　　运行时间与输入无关。为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息。这种性质在某些情况下是缺点，因为使用选择排序的人可能会惊讶的发现，一个已经有序的数组或是主键全部相等的数组和一个元素随机排列的数组所用的排序时间竟然一样长！我们将会看到，其它算法会更善于利用输入的初始状态。<br />
　　数据移动是最少的。每次交换都会改变两个数组元素的值，因此选择排序用了Ｎ次交换——交换次数和数组大小是线性关系。其它的任何算法都不具备这个特征（大部分的增长数量级都是线性对数或平方级别）</p>
<p>简单的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *A;</span><br><span class="line">    <span class="keyword">int</span> length, i, j, t, <span class="built_in">min</span>, key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入要排序的数字个数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;length);</span><br><span class="line">    A = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(length * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//输入数字</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">min</span> = A[i];</span><br><span class="line">        key = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; <span class="built_in">min</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">min</span> = A[j];</span><br><span class="line">                key = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t = A[i];</span><br><span class="line">        A[i] = <span class="built_in">min</span>;</span><br><span class="line">        A[key] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    <span class="built_in">free</span>(A);<span class="comment">//别忘了释放malloc来的空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>一元多项式的乘法与加法运算</title>
    <url>/2019/03/10/polynomial/</url>
    <content><![CDATA[<p>设计函数分别求两个一元多项式的乘积与和。 <a id="more"></a></p>
<h4 id="输入格式">输入格式</h4>
<p>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p>
<h4 id="输出格式">输出格式</h4>
<p>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出“0 0”。</p>
<h4 id="输入样例">输入样例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3 4 -5 2  6 1  -2 0</span><br><span class="line">3 5 20  -7 4  3 1</span><br></pre></td></tr></table></figure>
<h4 id="输出样例">输出样例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1</span><br><span class="line">5 20 -4 4 -5 2 9 1 -2 0</span><br></pre></td></tr></table></figure>
<h4 id="代码">代码</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NUM</span> * <span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NUM</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> coef;<span class="comment">//系数</span></span><br><span class="line">    <span class="keyword">int</span> expo;<span class="comment">//指数</span></span><br><span class="line">    List next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> coef, <span class="keyword">int</span> expo, List *rear)</span></span>;</span><br><span class="line"><span class="function">List <span class="title">add</span><span class="params">(List quem, List quen)</span></span>;</span><br><span class="line"><span class="function">List <span class="title">mul</span><span class="params">(List quem, List quen)</span></span>;</span><br><span class="line"><span class="function">List <span class="title">insertSortandMerge</span><span class="params">(List front)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(List res)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n,coef,expo;</span><br><span class="line">    List quem, quen, resadd, resmul;</span><br><span class="line">    List rearm = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM)), rearn = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM));</span><br><span class="line">    rearm-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    rearn-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    quem = rearm;</span><br><span class="line">    quen = rearn;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;coef, &amp;expo);</span><br><span class="line">        addNode(coef, expo, &amp;rearm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;coef, &amp;expo);</span><br><span class="line">        addNode(coef, expo, &amp;rearn);</span><br><span class="line">    &#125;</span><br><span class="line">    resadd = add(quem-&gt;next, quen-&gt;next);</span><br><span class="line">    resmul = mul(quem-&gt;next, quen-&gt;next);</span><br><span class="line">    Print(resmul);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    Print(resadd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> coef, <span class="keyword">int</span> expo, List *rear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//由于在本函数中需要改变当前结果表达式尾项指针的值</span></span><br><span class="line">    <span class="comment">//所以函数传递进来的是尾项结点指针的地址，*rear指向尾项</span></span><br><span class="line">    List P = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM));<span class="comment">//申请新节点并赋值</span></span><br><span class="line">    P-&gt;coef = coef;</span><br><span class="line">    P-&gt;expo = expo;</span><br><span class="line">    P-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将P指向的新节点插入到当前结果表达式尾项的后面</span></span><br><span class="line">    (*rear)-&gt;next = P;</span><br><span class="line">    *rear = (*rear)-&gt;next;<span class="comment">//修改rear值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">List <span class="title">add</span><span class="params">(List quem, List quen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List front, rear, temp;<span class="comment">//为方便表头插入，先产生一个临时空结点作为结果多项式链表头</span></span><br><span class="line">    rear = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM));</span><br><span class="line">    front = rear;<span class="comment">//由front记录结果多项式链表头结点</span></span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">while</span> (quem&amp;&amp;quen)<span class="comment">//当两个多项式都有非零项待处理时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (quem-&gt;expo == quen-&gt;expo)<span class="comment">//两数据项指数相等</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum = quem-&gt;coef + quen-&gt;coef;</span><br><span class="line">            <span class="keyword">if</span> (sum)</span><br><span class="line">                addNode(sum, quem-&gt;expo, &amp;rear);</span><br><span class="line">            quem = quem-&gt;next;</span><br><span class="line">            quen = quen-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (quem-&gt;expo &lt; quen-&gt;expo)<span class="comment">//quen中的数据项指数较大</span></span><br><span class="line">        &#123;</span><br><span class="line">            addNode(quen-&gt;coef, quen-&gt;expo, &amp;rear);</span><br><span class="line">            quen = quen-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (quem-&gt;expo &gt; quen-&gt;expo)<span class="comment">//quem中的数据项指数较大</span></span><br><span class="line">        &#123;</span><br><span class="line">            addNode(quem-&gt;coef, quem-&gt;expo, &amp;rear);</span><br><span class="line">            quem = quem-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将未处理完的另一个多项式的所有结点依次复制到结果多项式中去</span></span><br><span class="line">    <span class="keyword">while</span> (quem)</span><br><span class="line">    &#123;</span><br><span class="line">        addNode(quem-&gt;coef, quem-&gt;expo, &amp;rear);</span><br><span class="line">        quem = quem-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (quen)</span><br><span class="line">    &#123;</span><br><span class="line">        addNode(quen-&gt;coef, quen-&gt;expo, &amp;rear);</span><br><span class="line">        quen = quen-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    rear-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    temp = front;</span><br><span class="line">    front = front-&gt;next;<span class="comment">//令front指向结果多项式第一个非零项</span></span><br><span class="line">    <span class="built_in">free</span>(temp);<span class="comment">//释放临时空表头结点</span></span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">List <span class="title">mul</span><span class="params">(List quem, List quen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List front, rear, temp, Fquem;<span class="comment">//Fquem保存quem的位置</span></span><br><span class="line">    <span class="keyword">int</span> sum, mul;</span><br><span class="line">    rear = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM));</span><br><span class="line">    front = rear;</span><br><span class="line">    Fquem = quem;</span><br><span class="line">    <span class="keyword">while</span> (quen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (quem)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = (quem-&gt;coef) * (quen-&gt;coef);</span><br><span class="line">            mul = (quem-&gt;expo) + (quen-&gt;expo);</span><br><span class="line">            addNode(sum, mul, &amp;rear);</span><br><span class="line">            quem = quem-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        quem = Fquem;<span class="comment">//重置quem</span></span><br><span class="line">        quen = quen-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    rear-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    temp = front;</span><br><span class="line">    front = front-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    front = insertSortandMerge(front);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">List <span class="title">insertSortandMerge</span><span class="params">(List front)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//处理多项式乘法的结果</span></span><br><span class="line">    <span class="comment">/*按指数从大到小进行插入排序，第二个循环中顺便将要插入的项与之前排好序的“队列”中指数相同的项进行合并*/</span></span><br><span class="line">    List head, temp, front_to_free = front;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    head = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (front == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;coef = front-&gt;coef;</span><br><span class="line">        head-&gt;expo = front-&gt;expo;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (front)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (front-&gt;expo == temp-&gt;next-&gt;expo)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = temp-&gt;next-&gt;coef + front-&gt;coef;</span><br><span class="line">                <span class="keyword">if</span> (sum)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp-&gt;next-&gt;coef = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                front = front-&gt;next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (front-&gt;expo &gt; head-&gt;expo)</span><br><span class="line">            &#123;</span><br><span class="line">                List t = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM));</span><br><span class="line">                t-&gt;coef = front-&gt;coef;</span><br><span class="line">                t-&gt;expo = front-&gt;expo;</span><br><span class="line">                t-&gt;next = head;</span><br><span class="line">                head = t;</span><br><span class="line">                front = front-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(t);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (front-&gt;expo &lt; temp-&gt;expo &amp;&amp; front-&gt;expo&gt;temp-&gt;next-&gt;expo)</span><br><span class="line">            &#123;</span><br><span class="line">                List t = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM));</span><br><span class="line">                t-&gt;coef = front-&gt;coef;</span><br><span class="line">                t-&gt;expo = front-&gt;expo;</span><br><span class="line">                t-&gt;next = temp-&gt;next;</span><br><span class="line">                temp-&gt;next = t;</span><br><span class="line">                front = front-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(t);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            addNode(front-&gt;coef, front-&gt;expo, &amp;temp);</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(front_to_free);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(List res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输出操作，首先特判一下</span></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0 0"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">while</span> (res)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, res-&gt;coef, res-&gt;expo);</span><br><span class="line">        <span class="keyword">if</span> (res-&gt;next)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试点信息">测试点信息</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试点    提示</span><br><span class="line">0        sample换个数字</span><br><span class="line">1        同类项合并时有抵消</span><br><span class="line">2        系数和指数取上限，结果有零多项式</span><br><span class="line">3        输入有零多项式和常数多项式</span><br></pre></td></tr></table></figure>
<p><del>什么都不想说，因为写了六个小时，太累了。</del></p>
<p>好吧，时隔一个星期，我又回来补上了一部分注释。</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>Root Of AVL Tree</title>
    <url>/2019/03/23/root-of-AVL-tree/</url>
    <content><![CDATA[<p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. <a id="more"></a> Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.</p>
<h4 id="input-specification">Input Specification</h4>
<p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤20) which is the total number of keys to be inserted. Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p>
<h4 id="output-specification">Output Specification</h4>
<p>For each test case, print the root of the resulting AVL tree in one line.</p>
<h4 id="sample-input-1">Sample Input 1</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">88 70 61 96 120</span><br></pre></td></tr></table></figure>
<h4 id="sample-output-1">Sample Output 1</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">70</span><br></pre></td></tr></table></figure>
<h4 id="sample-input-2">Sample Input 2</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">88 70 61 96 120 90 65</span><br></pre></td></tr></table></figure>
<h4 id="sample-output-2">Sample Output 2</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">88</span><br></pre></td></tr></table></figure>
<h4 id="代码">代码</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> * <span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position AVLTree;   <span class="comment">//AVL树类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> &#123;</span></span><br><span class="line">    ElementType Data;   <span class="comment">//结点数据</span></span><br><span class="line">    AVLTree Left;   <span class="comment">//指向左子树</span></span><br><span class="line">    AVLTree Right;  <span class="comment">//指向右子树</span></span><br><span class="line">    <span class="keyword">int</span> Height; <span class="comment">//树高</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function">AVLTree <span class="title">Insert</span><span class="params">(AVLTree T, ElementType X)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHeight</span><span class="params">(AVLTree T)</span></span>;</span><br><span class="line"><span class="function">AVLTree <span class="title">SingleLeftRotation</span><span class="params">(AVLTree A)</span></span>;</span><br><span class="line"><span class="function">AVLTree <span class="title">SingleRightRotation</span><span class="params">(AVLTree A)</span></span>;</span><br><span class="line"><span class="function">AVLTree <span class="title">DoubleLeftRightRotation</span><span class="params">(AVLTree A)</span></span>;</span><br><span class="line"><span class="function">AVLTree <span class="title">DoubleRightLeftRotation</span><span class="params">(AVLTree A)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, num;</span><br><span class="line">    AVLTree T = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line">        T = Insert(T, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, T-&gt;Data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AVLTree <span class="title">Insert</span><span class="params">(AVLTree T, ElementType X)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//将X插入AVL树中，并且返回调整后的AVL树</span></span><br><span class="line">    <span class="keyword">if</span> (!T)<span class="comment">//若插入空树，则新建包含一个结点的树</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = (AVLTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct AVLNode));</span><br><span class="line">        T-&gt;Data = X;</span><br><span class="line">        T-&gt;Height = <span class="number">1</span>;</span><br><span class="line">        T-&gt;Left = T-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; T-&gt;Data)</span><br><span class="line">    &#123;<span class="comment">//插入左子树</span></span><br><span class="line">        T-&gt;Left = Insert(T-&gt;Left, X);</span><br><span class="line">        <span class="comment">//如果需要左旋</span></span><br><span class="line">        <span class="keyword">if</span> (GetHeight(T-&gt;Left) - GetHeight(T-&gt;Right) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (X &lt; T-&gt;Left-&gt;Data)</span><br><span class="line">                T = SingleLeftRotation(T);  <span class="comment">//左单旋</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T = DoubleLeftRightRotation(T); <span class="comment">//左-右双旋</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; T-&gt;Data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//插入右子树</span></span><br><span class="line">        T-&gt;Right = Insert(T-&gt;Right, X);</span><br><span class="line">        <span class="comment">//如果需要右旋</span></span><br><span class="line">        <span class="keyword">if</span> (GetHeight(T-&gt;Right) - GetHeight(T-&gt;Left) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (X &gt; T-&gt;Right-&gt;Data)</span><br><span class="line">                T = SingleRightRotation(T); <span class="comment">//右单旋</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T = DoubleRightLeftRotation(T); <span class="comment">//右-左双旋</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//else X==T-&gt;Data,无需插入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//别忘了更新树高</span></span><br><span class="line">    T-&gt;Height = Max(GetHeight(T-&gt;Left), GetHeight(T-&gt;Right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHeight</span><span class="params">(AVLTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T)</span><br><span class="line">        <span class="keyword">return</span> T-&gt;Height;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AVLTree <span class="title">SingleLeftRotation</span><span class="params">(AVLTree A)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//注意：A必须有一个左子结点B</span></span><br><span class="line">    <span class="comment">//将A与B做左单旋，更新A与B的高度，返回新的根节点B</span></span><br><span class="line">    AVLTree B = A-&gt;Left;</span><br><span class="line">    A-&gt;Left = B-&gt;Right;</span><br><span class="line">    B-&gt;Right = A;</span><br><span class="line">    A-&gt;Height = Max(GetHeight(A-&gt;Left), GetHeight(A-&gt;Right)) + <span class="number">1</span>;</span><br><span class="line">    B-&gt;Height = Max(GetHeight(B-&gt;Left), A-&gt;Height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AVLTree <span class="title">SingleRightRotation</span><span class="params">(AVLTree A)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//注意：A必须有一个右子结点B</span></span><br><span class="line">    <span class="comment">//将A与B做右单旋，更新A与B的高度，返回新的根节点B</span></span><br><span class="line">    AVLTree B = A-&gt;Right;</span><br><span class="line">    A-&gt;Right = B-&gt;Left;</span><br><span class="line">    B-&gt;Left = A;</span><br><span class="line">    A-&gt;Height = Max(GetHeight(A-&gt;Left), GetHeight(A-&gt;Right)) + <span class="number">1</span>;</span><br><span class="line">    B-&gt;Height = Max(GetHeight(B-&gt;Right), A-&gt;Height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AVLTree <span class="title">DoubleLeftRightRotation</span><span class="params">(AVLTree A)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//注意：A必须有一个左子结点B，且B必须有一个右子节点C</span></span><br><span class="line">    <span class="comment">//将A、B与C做两次单旋，返回新的根节点C</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//B与C做右单旋，返回C</span></span><br><span class="line">    A-&gt;Left = SingleRightRotation(A-&gt;Left);</span><br><span class="line">    <span class="comment">//A与C做左单旋，返回C</span></span><br><span class="line">    <span class="keyword">return</span> SingleLeftRotation(A);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AVLTree <span class="title">DoubleRightLeftRotation</span><span class="params">(AVLTree A)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//注意：A必须有一个右子结点B，且B必须有一个左子节点C</span></span><br><span class="line">    <span class="comment">//将A、B与C做两次单旋，返回新的根节点C</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//B与C做左单旋，返回C</span></span><br><span class="line">    A-&gt;Right = SingleLeftRotation(A-&gt;Right);</span><br><span class="line">    <span class="comment">//A与C做右单旋，返回C</span></span><br><span class="line">    <span class="keyword">return</span> SingleRightRotation(A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试点">测试点</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试点      提示</span><br><span class="line">0           fig 1 - LL</span><br><span class="line">1           fig 2 - RR</span><br><span class="line">2           fig 3 - RL</span><br><span class="line">3           fig 4 - LR</span><br><span class="line">4           深度LL旋转</span><br><span class="line">5           最大N，深度RL旋转</span><br><span class="line">6           最小N</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>矩阵乘法的Strassen算法</title>
    <url>/2019/02/02/strassen/</url>
    <content><![CDATA[<p>  最简单的矩阵乘法可以通过三重循环来实现，其时间复杂度为<span class="math inline">\(\Theta(n^{3})\)</span>，Strassen算法通过巧妙的增加加法来减少乘法实现了<span class="math inline">\(O(n^{2.81})\)</span>的时间复杂度</p>
<a id="more"></a>
<p>Strassen算法的四个步骤：</p>
<ol type="1">
<li>将输入矩阵A、B与输出矩阵C分解为<span class="math inline">\(n/2\times n/2\)</span>的子矩阵，采用下标计算方法，此步骤花费<span class="math inline">\(\Theta\)</span>(1)时间。<br />
</li>
<li>创建10个<span class="math inline">\(n/2\times n/2\)</span>的矩阵，每个矩阵保存步骤1中创建的两个子矩阵的和或差，花费<span class="math inline">\(\Theta(n^2)\)</span>。<br />
</li>
<li>用步骤1中创建的子矩阵和步骤2中创建的10个矩阵，递归的计算7个<span class="math inline">\(P_i\)</span>矩阵积。<br />
</li>
<li>通过<span class="math inline">\(P_i\)</span>矩阵的不同组合进行加减运算，计算出C的子矩阵，花费时间<span class="math inline">\(\Theta(n^2)\)</span>。</li>
</ol>
<p>  为了方便计算矩阵积C=A<span class="math inline">\(\cdot\)</span>B，假定三个矩阵均为<span class="math inline">\(n\times n\)</span>矩阵，其中n为2的幂。做出这个假设是因为在每个分解步骤中，<span class="math inline">\(n\times n\)</span>矩阵都被划分为4个<span class="math inline">\(n/2\times n/2\)</span>的子矩阵，如果假定<span class="math inline">\(n\)</span>是2的幂，则只要<span class="math inline">\(n\geq 2\)</span>即可保证子矩阵规模<span class="math inline">\(n/2\)</span>为整数。</p>
<p>假定将A、B和C均分解为4个<span class="math inline">\(n/2\times n/2\)</span>的子矩阵：</p>
<p><span class="math display">\[A=
 \left[
 \begin{matrix}
   A_{11} &amp; A_{12} \\
   A_{21} &amp; A_{22} \\
  \end{matrix}
  \right]
，B=
 \left[
 \begin{matrix}
   B_{11} &amp; B_{12} \\
   B_{21} &amp; B_{22} \\
  \end{matrix}
  \right]
，C=
 \left[
 \begin{matrix}
   C_{11} &amp; C_{12} \\
   C_{21} &amp; C_{22} \\
  \end{matrix}
  \right]
\]</span> 根据矩阵乘法的定义，可以得到如下4个公式： <span class="math display">\[
\begin{equation}\label{1}
\begin{aligned}
C_{11}&amp;=A_{11}\cdot B_{11}+A_{12}\cdot B_{21} \\
C_{12}&amp;=A_{11}\cdot B_{12}+A_{12}\cdot B_{22} \\
C_{21}&amp;=A_{21}\cdot B_{11}+A_{22}\cdot B_{21} \\
C_{22}&amp;=A_{21}\cdot B_{12}+A_{22}\cdot B_{22} \\
\end{aligned}
\end{equation}
\]</span></p>
<p>步骤2中，创建如下10个矩阵： <span class="math display">\[
\begin{equation}\label{2}
\begin{aligned}
S_1&amp;=B_{12}-B_{22}\\
S_2&amp;=A_{11}-A_{12}\\
S_3&amp;=A_{21}+A_{22}\\
S_4&amp;=B_{21}-B_{21}\\
S_5&amp;=A_{11}+A_{22}\\
S_6&amp;=B_{11}+B_{22}\\
S_7&amp;=A_{12}-A_{22}\\
S_8&amp;=B_{21}+B_{22}\\
S_9&amp;=A_{11}-A_{21}\\
S_{10}&amp;=B_{11}+B_{12}\\
\end{aligned}
\end{equation}
\]</span> 由于必须进行10次<span class="math inline">\(n/2\times n/2\)</span>矩阵的加减法，因此，该步骤花费<span class="math inline">\(\Theta(n^2)\)</span>时间。 步骤3中，递归的计算7次<span class="math inline">\(n/2\times n/2\)</span>矩阵的乘法，如下所示： <span class="math display">\[
\begin{align*}
P_1&amp;=A_{11}\cdot S_1\\
P_2&amp;=S_2\cdot B_{22}\\
P_3&amp;=S_3\cdot B_{11}\\
P_4&amp;=A_{22}\cdot S_4\\
P_5&amp;=S_5\cdot S_6\\
P_6&amp;=S_7\cdot S_8\\
P_7&amp;=S_9\cdot S_{10}\\
\end{align*}
\]</span> 步骤4中， <span class="math display">\[
\begin{align*}
C_{11}&amp;=P_5+P_4-P_2+P_6\\
C_{12}&amp;=P_1+P_2\\
C_{21}&amp;=P_3+P_4\\
C_{22}&amp;=P_5+P_1-P_3-P_7\\
\end{align*}
\]</span> 共进行了8次<span class="math inline">\(n/2\times n/2\)</span>矩阵的加减法，因此花费<span class="math inline">\(\Theta(n^2)\)</span>时间。 代值计算后可以发现(2)式结果与(1)式是相同的。</p>
<p>描述Strassen算法运行时间T(n)的递归式： <span class="math display">\[T(n)=\begin{cases}
\Theta(1)&amp;n=1\\
7T(n/2)+\Theta(n^2)&amp;n&gt;1\\
\end{cases}\]</span></p>
<p>  用主方法来求解这个递归式，可知解为<span class="math inline">\(T\left(n\right)=\Theta(n^{lg7})\)</span>，由于<span class="math inline">\(lg7\)</span>介于2.80和2.81之间，所以时间复杂度为<span class="math inline">\(O(n^{2.81})\)</span>。</p>
<p>天知道Strassen是怎么想到这个方法的QAQ</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>修改文章底部标签图形</title>
    <url>/2019/09/27/%E4%BF%AE%E6%94%B9%E6%96%87%E7%AB%A0%E5%BA%95%E9%83%A8%E6%A0%87%E7%AD%BE%E5%9B%BE%E5%BD%A2/</url>
    <content><![CDATA[<p>可能有人会觉得自带的<code>#</code>标签比较丑，那么可以考虑更改<code>themes\next\layout\_macro\post.swig</code>来更换一个图标</p>
<a id="more"></a>
<img src="/2019/09/27/%E4%BF%AE%E6%94%B9%E6%96%87%E7%AB%A0%E5%BA%95%E9%83%A8%E6%A0%87%E7%AD%BE%E5%9B%BE%E5%BD%A2/tags_before.png" class="" title="更改前">
<img src="/2019/09/27/%E4%BF%AE%E6%94%B9%E6%96%87%E7%AB%A0%E5%BA%95%E9%83%A8%E6%A0%87%E7%AD%BE%E5%9B%BE%E5%BD%A2/tags_after.png" class="" title="更改后">
<p>在<code>post.swig</code>文件中搜索<code>tag_indicate</code>找到<code>set tag_indicate = '#'</code>,将其改成<code>set tag_indicate = '&lt;i class="fa fa-tag"&gt;&lt;/i&gt;'</code>。</p>
<p>更好的方法：可以直接在主题目录下的<code>_config.yml</code>中搜索<code>tag_icon</code>将其值改为true</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>随机选择算法</title>
    <url>/2019/08/25/randSelect/</url>
    <content><![CDATA[<p>  有这样一个问题：如何从一个无序的数组里求出第<span class="math inline">\(K\)</span>大的数（为了简化讨论，假设数组中的数各不相同），例如，对数组<span class="math inline">\(\{ 5, 12, 7, 2, 9, 3\}\)</span>来说，第三大的数是5，第五大的数是9。</p>
<a id="more"></a>
<p>  最直接的想法就是对数组排一下序，然后直接取出第<span class="math inline">\(K\)</span>大元素即可。但是这样做法需要<span class="math inline">\(O(nlogn)\)</span>的时间复杂度，虽然看起来很好，但还有更优化的算法。下面介绍随机选择算法，它对任何输入都可以达到<span class="math inline">\(O(n)\)</span>的期望时间复杂度。</p>
<p>  随机选择算法的原理类似于随机快速排序算法。可以证明虽然随机选择算法的最坏时间复杂度是<span class="math inline">\(O(n^2)\)</span>，但是其对任意输入的期望时间复杂度却是<span class="math inline">\(O(n)\)</span>，这意味着不存在一组特定的数据能使这个算法出现最坏情况，是个相当实用和出色的算法。</p>
<p>下面以一道OJ题展示一下该算法的核心代码</p>
<p><strong>题目</strong><br />
  给定一个长度为<span class="math inline">\(n(1\leq n\leq 1,000,000)\)</span>的无序正整数序列，以及另一个数<span class="math inline">\(k(1\leq k\leq 1,000,000)\)</span>（关于第<span class="math inline">\(k\)</span>大的数：例如序列<span class="math inline">\(\{ 1, 2, 3, 4, 5, 6\}\)</span>）中第三大的数是4。）</p>
<p><strong>输入</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行两个正整数n, m。</span><br><span class="line">第二行为n个正整数。</span><br></pre></td></tr></table></figure></p>
<p><strong>输出</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第m大的数。</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输入</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输出</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p>
<p><strong>代码</strong> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"algorithm"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cmath"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cstdio"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cstdlib"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ctime"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> A[maxn], n;</span><br><span class="line"><span class="comment">//随机选取主元，对区间[left, right]进行划分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randPartition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//生成[left, right]内的随机数p</span></span><br><span class="line">    <span class="keyword">int</span> p = round(<span class="number">1.0</span> * rand() / RAND_MAX * (right - left) + left);</span><br><span class="line">    <span class="comment">//交换A[p]与A[left]</span></span><br><span class="line">    swap(A[p], A[left]);</span><br><span class="line">    <span class="comment">//以下为不随机选择基准时的划分过程，不需要改变</span></span><br><span class="line">    <span class="comment">//将A[left]存放至临时变量temp</span></span><br><span class="line">    <span class="keyword">int</span> temp = A[left];</span><br><span class="line">    <span class="comment">//只要left与right不相遇</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; A[right] &gt; temp)</span><br><span class="line">            right--;        <span class="comment">//反复左移right</span></span><br><span class="line">        A[left] = A[right]; <span class="comment">//将A[right]挪到A[left]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; A[left] &lt;= temp)</span><br><span class="line">            left++;         <span class="comment">//反复右移left</span></span><br><span class="line">        A[right] = A[left]; <span class="comment">//将A[left]挪到A[right]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把temp放到left和right相遇的地方</span></span><br><span class="line">    A[left] = temp;</span><br><span class="line">    <span class="comment">//返回相遇的下标</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随机选择算法，从A[left, right]中找到第K大的数，进行划分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randSelect</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">return</span> A[left];</span><br><span class="line">    <span class="comment">//划分后主元的位置为p</span></span><br><span class="line">    <span class="keyword">int</span> p = randPartition(A, left, right);</span><br><span class="line">    <span class="comment">//A[p]是A[left, right]中的第M大</span></span><br><span class="line">    <span class="keyword">int</span> M = p - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//找到第K大的数</span></span><br><span class="line">    <span class="keyword">if</span> (K == M) <span class="comment">//找到第K大的数</span></span><br><span class="line">        <span class="keyword">return</span> A[p];</span><br><span class="line">    <span class="keyword">if</span> (K &lt; M) <span class="comment">//第K大数在主元左侧</span></span><br><span class="line">        <span class="keyword">return</span> randSelect(A, left, p - <span class="number">1</span>, K);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//第K大数在主元右侧</span></span><br><span class="line">        <span class="keyword">return</span> randSelect(A, p + <span class="number">1</span>, right, K - M);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果直接填m-1的话找的是第K小的数字</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, randSelect(A, <span class="number">0</span>, n - <span class="number">1</span>, n - m + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>最大子列和</title>
    <url>/2019/03/07/maxsubseqsum/</url>
    <content><![CDATA[<p>最大子列和问题，即给定N个整数的序列<span class="math inline">\(\{A_1,A_2,\ldots,A_N \}\)</span>，求函数<span class="math inline">\(f(i,j)=max\lbrace 0,\sum\limits_{i=0}^n{A_k}\rbrace\)</span>的最大值。 例如<span class="math inline">\(\lbrace-2,11,-4,13,-5,-2\rbrace\)</span>的最大子列和为20，子列为<span class="math inline">\(\lbrace11,-4,13\rbrace\)</span>. <span class="math inline">\(\lbrace-10, 1, 2, 3, 4, -5, -23, 3, 7, -21\rbrace\)</span>的最大子列和为10，子列为<span class="math inline">\(\lbrace1，2，3，4\rbrace\)</span>。 <a id="more"></a> 本文将给出实现这种算法的<span class="math inline">\(\Theta(N^2)\)</span>和<span class="math inline">\(\Theta(N)\)</span>算法</p>
<h2 id="thetan2"><span class="math inline">\(\Theta(N^2)\)</span></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubseqSum</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ThisSum,MaxSum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)    <span class="comment">//i是子列左端位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        ThisSum=<span class="number">0</span>;      <span class="comment">//ThisSum是从A[i]到A[j]的子列和</span></span><br><span class="line">        <span class="keyword">for</span>(j = i; j &lt; N; j++)<span class="comment">//j是子列右端位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            ThisSum += A[j];  <span class="comment">//对于相同的i，不同的j，只要在j-1次循环的基础上累加1项即可</span></span><br><span class="line">            <span class="keyword">if</span>(ThisSum &gt; MaxSum) <span class="comment">//如果刚得到的这个子列和更大</span></span><br><span class="line">                MaxSum = ThisSum; <span class="comment">//则更新结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="thetan"><span class="math inline">\(\Theta(N)\)</span></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubseqSum</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ThisSum, MaxSum;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    ThisSum = MaxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ThisSum += A[i];        <span class="comment">//向右累加</span></span><br><span class="line">        <span class="keyword">if</span>(ThisSum &gt; MaxSum)</span><br><span class="line">            MaxSum = ThisSum;   <span class="comment">//发现更大和则更新当前结果</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ThisSum &lt; <span class="number">0</span>)    <span class="comment">//如果当前子列和为负</span></span><br><span class="line">            ThisSum = <span class="number">0</span>;        <span class="comment">//则不可能使后面的部分和增大，抛弃之</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方法可能不是很好理解，有必要的话可以根据上面的例子手动推演一下。</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>堆中的路径</title>
    <url>/2019/03/30/%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>将一系列给定数字插入一个初始为空的小顶堆<code>H[]</code>。随后对任意给定的下标<code>i</code>，打印从<code>H[i]</code>到根结点的路径。 <a id="more"></a></p>
<h4 id="输入格式">输入格式</h4>
<p>每组测试第1行包含2个正整数N和M(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的N个要被插入一个初始为空的小顶堆的整数。最后一行给出M个下标。</p>
<h4 id="输出格式">输出格式</h4>
<p>对输入中给出的每个下标<code>i</code>，在一行中输出从<code>H[i]</code>到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。</p>
<h4 id="输入样例">输入样例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">46 23 26 24 10</span><br><span class="line">5 4 3</span><br></pre></td></tr></table></figure>
<h4 id="输出样例">输出样例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">24 23 10</span><br><span class="line">46 23 10</span><br><span class="line">26 10</span><br></pre></td></tr></table></figure>
<h4 id="代码">代码</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINH -10001</span></span><br><span class="line"><span class="keyword">int</span> H[MAXN], <span class="built_in">size</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> X)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, x, i, j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    Create();<span class="comment">//堆初始化</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;<span class="comment">//以逐个插入方式建堆</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        Insert(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;j);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, H[j]);</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;<span class="comment">//沿根方向输出各节点</span></span><br><span class="line">            j /= <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>, H[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    H[<span class="number">0</span>] = MINH;</span><br><span class="line">    <span class="comment">//设置岗哨</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将X插入H，这里省略检查堆是否已满的代码</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = ++<span class="built_in">size</span>; H[i / <span class="number">2</span>] &gt; X; i /= <span class="number">2</span>)</span><br><span class="line">        H[i] = H[i / <span class="number">2</span>];</span><br><span class="line">    H[i] = X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试点">测试点</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试点      提示</span><br><span class="line">0           sample 调整到根、到中间位置，有不需要调整的元素</span><br><span class="line">1           路径更长，交错，index从中间开始，有负数</span><br><span class="line">2           最小N和M</span><br><span class="line">3           最大N和M随机，元素取到正负10000</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>快速幂取模</title>
    <url>/2020/07/07/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%8F%96%E6%A8%A1/</url>
    <content><![CDATA[<p>现在让我们来计算<span class="math inline">\(a^b\%c\)</span> <a id="more"></a></p>
<h2 id="最简单的想法">最简单的想法</h2>
<p>将<span class="math inline">\(a\)</span>累计乘上<span class="math inline">\(b\)</span>次再对<span class="math inline">\(c\)</span>取模即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b--)</span><br><span class="line">        ans = ans * a;</span><br><span class="line">    ans = ans % c;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上去没有问题，但是当<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>的值很大时，就算是long long类型也有可能让累乘的结果溢出，而且在做乘法时一共要进行<span class="math inline">\(b\)</span>次运算，时间上的代价也很大，那么是否能从这两方面进行优化呢？</p>
<h2 id="快速幂">快速幂</h2>
<p>快速幂是一个计算<span class="math inline">\(a^b\)</span>的小技巧，它的时间复杂度为<span class="math inline">\(\Theta \left( \log n \right)\)</span>，从一个简单的例子开始：</p>
<p>现在你要计算<span class="math inline">\(62^9\)</span>这个数，假设你手上有个只能加减乘除的计算器，想必你肯定不会真的把<span class="math inline">\(62\)</span>这个数乘上<span class="math inline">\(9\)</span>次，因为这实在太慢了，我们会先计算<span class="math inline">\(62^4\)</span>的值，将其与自身相乘后再乘上一个<span class="math inline">\(62\)</span>就得到了结果，将这个规则递归下去，可以得到下面这样的流程</p>
<p><span class="math display">\[
62^9=\left( 62^4 \right) ^2*62=\left( \left( 62^2 \right) ^2 \right) ^2*62
\]</span></p>
<p>原本要进行9次乘法，现在只需要进行4次，幂越大时，效果越明显。</p>
<h3 id="递归实现">递归实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="built_in">pow</span>(a, b / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans * ans * a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ans * ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归实现">非递归实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取模">取模</h2>
<p>首先引入几个数学公式 <span class="math display">\[
\begin{align}
\left( a+b \right) \%c=\left[ \left( a\%c \right) +\left( b\%c \right) \right] \%c
\\
\left( a-b \right) \%c=\left[ \left( a\%c \right) -\left( b\%c \right) \right] \%c
\\
\left( a*b \right) \%c=\left[ \left( a\%c \right) *\left( b\%c \right) \right] \%c
\end{align}
\]</span></p>
<p>我们需要用到上面的第$( 3 ) $式，下面给出证明：</p>
<p><span class="math display">\[
\begin{align*}
a\%c &amp; =d\Rightarrow a=tc+d\\
b\%c &amp; =e\Rightarrow b=kc+e\\
ab\%c &amp; =\left( tc+d \right) \left( kc+e \right) \%c\\
&amp; =\left( tkc^2+\left( te+dk \right) c+de \right) \%c\\
&amp; =de\%c=\left[ \left( a\%c \right) *\left( b\%c \right) \right] \%c
\end{align*}
\]</span></p>
<p>根据这个公式，可以知道</p>
<p><span class="math display">\[
a^b\%c=\left( a\%c \right) ^b\%c
\]</span></p>
<h2 id="最终结果">最终结果</h2>
<p>根据以上结论，我们可以在循环乘积的过程中加入取模运算，这样就可以避免最终结果过大的情况，再结合之前的快速幂技巧，就可以得到最终的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a %= c;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = (ans * a) % c;</span><br><span class="line">        a = (a * a) % c;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>数模</title>
    <url>/2020/07/06/%E6%95%B0%E6%A8%A1/</url>
    <content><![CDATA[<p>主要是学习清风数模时的笔记 <a id="more"></a></p>
<h2 id="思维导图">思维导图</h2>
<img src="/2020/07/06/%E6%95%B0%E6%A8%A1/%E6%B8%85%E9%A3%8E%E6%95%B0%E6%A8%A1.png" class="">
<h2 id="层次分析法">层次分析法</h2>
<h3 id="关键词">关键词</h3>
<ul>
<li>判断矩阵</li>
<li>一致性检验</li>
<li>三种方法求权重（算术平均法、几何平均法、特征值法）</li>
</ul>
<h3 id="作用">作用</h3>
<ul>
<li>解决评价类问题</li>
</ul>
<h3 id="matlab">matlab</h3>
<ul>
<li>input 输入函数</li>
<li>disp 输出函数</li>
<li>eig 求特征值和特征矩阵</li>
</ul>
<h2 id="topsis法">TOPSIS法</h2>
<h3 id="关键词-1">关键词</h3>
<ul>
<li>指标正向化</li>
<li>标准化（消除量纲的影响）</li>
<li>归一化</li>
</ul>
<h3 id="作用-1">作用</h3>
<ul>
<li>评价方法</li>
</ul>
<h3 id="matlab-1">matlab</h3>
<ul>
<li>sort排序函数</li>
</ul>
<h2 id="插值">插值</h2>
<h3 id="关键词-2">关键词</h3>
<ul>
<li>拉格朗日插值</li>
<li>龙格现象</li>
<li>分段二次插值</li>
<li>牛顿插值</li>
<li>分段三次埃尔米特插值</li>
<li>三次样条插值</li>
</ul>
<h3 id="作用-2">作用</h3>
<ul>
<li>一般我们很少使用插值算法来预测数据</li>
</ul>
<h3 id="matlab-2">matlab</h3>
<ul>
<li>pchip 分段三次埃尔米特插值</li>
<li>spline 三次样条插值</li>
<li>interpn n维数据插值</li>
</ul>
<h2 id="拟合">拟合</h2>
<h3 id="关键词-3">关键词</h3>
<ul>
<li>插值与拟合的区别</li>
<li>最小二乘法</li>
<li>拟合好坏的评价（拟合优度R方，误差平方和SSE）</li>
<li>拟合工具箱</li>
<li>代码生成</li>
</ul>
<h3 id="作用-3">作用</h3>
<ul>
<li>预测</li>
</ul>
<h3 id="注意事项">注意事项</h3>
<ul>
<li>R方只能用于拟合函数为对参数为线性的函数，否则只看SSE</li>
<li>拟合工具箱方法为Custom时，若不收敛，可以在Fit Options更改StartPoint</li>
</ul>
<h3 id="matlab-3">matlab</h3>
<ul>
<li>匿名函数z=@(x,y) x<sup>2+y</sup>2</li>
<li>匿名函数画图fplot</li>
<li>randi 产生均匀分布的随机整数</li>
<li>rand 产生0至1之间均匀分布的随机数</li>
<li>normrnd 产生正态分布的随机数</li>
<li>roundn 任意位置四舍五入</li>
</ul>
<h2 id="相关系数">相关系数</h2>
<h3 id="皮尔逊相关系数">皮尔逊相关系数</h3>
<ul>
<li><p>关键词</p>
<ul>
<li>总体（皮尔逊Person）相关系数</li>
<li>样本皮尔逊Person相关系数</li>
</ul></li>
<li><p>注意事项</p>
<ul>
<li>必须先知道两个变量是线性相关的，才能用Person相关系数计算相关程度</li>
<li>异常值对Person相关系数的影响很大</li>
<li>给出数据的描述性统计</li>
</ul></li>
<li><p>MATALB</p>
<ul>
<li>[R, P]=corrcoef(Test)</li>
<li>R返回的是相关系数表，P返回的是对应于每个相关系数的p值</li>
</ul></li>
<li><p>EXCEL</p>
<ul>
<li>数据-数据分析-描述统计</li>
<li>开始-条件格式-色阶 数据美化</li>
</ul></li>
<li><p>SPSS</p>
<ul>
<li>分析-描述统计-描述</li>
<li>图形-旧对话框-散点图/点图-矩阵散点图</li>
</ul></li>
</ul>
<h3 id="假设检验">假设检验</h3>
<ul>
<li><p>步骤</p>
<ul>
<li>写出原假设H0和备择假设H1</li>
<li>在H0成立条件下，构造符合某一分布的统计量</li>
<li>在给定置信水平下，求出接受域</li>
<li>用已知的样本数据代入计算统计量，得到检验值，根据检验值和接受域关系得到结论</li>
</ul></li>
</ul>
<h3 id="相关系数假设检验">相关系数假设检验</h3>
<ul>
<li><p>假设检验的条件</p>
<ul>
<li>实验数据通常假设是成对的来自于正态分布的总体</li>
<li>实验数据之间的差距不能太大</li>
<li>每组样本之间是独立抽样的</li>
</ul></li>
<li><p>作用</p>
<ul>
<li>两个变量之间可能没有线性关系，只是在样本中计算得到线性关系的表达式，假设检验是为了确认两变量之间关系的真实性</li>
</ul></li>
<li><p>MATLAB</p>
<ul>
<li>tpdf t分布概率密度</li>
<li>tcdf t分布累积密度函数</li>
<li>tinv tcdf反函数</li>
</ul></li>
<li><p>SPSS</p>
<ul>
<li>分析-相关-双变量</li>
</ul></li>
</ul>
<h3 id="对数据正态分布检验">对数据正态分布检验</h3>
<ul>
<li><p>大样本检验(n&gt;30)</p>
<ul>
<li>雅克-贝拉检验</li>
<li>[h, p]=jbtest(x, alpha)</li>
</ul></li>
<li><p>小样本检验(3-50)</p>
<ul>
<li>夏皮洛-威尔克检验</li>
<li>分析-描述统计-探索-图 勾选含检验的正态图</li>
</ul></li>
<li><p>QQ图</p>
<ul>
<li>qqplot</li>
<li>观察是否在一条直线上</li>
<li>要求数据量非常大</li>
</ul></li>
</ul>
<h3 id="斯皮尔曼相关系数">斯皮尔曼相关系数</h3>
<ul>
<li><p>一个数的等级，就是将它所在的一列数按照从小到大排序后，这个数所在的位置</p></li>
<li><p>有两种计算方法</p>
<ul>
<li><p>第一种</p>
<ul>
<li>Subtopic</li>
</ul></li>
<li><p>第二种</p>
<ul>
<li>斯皮尔曼相关系数被定义成等级之间的皮尔逊相关系数</li>
</ul></li>
</ul></li>
<li><p>分小样本大样本情况</p></li>
<li><p>MATLAB</p>
<ul>
<li>corr(X, Y, 'type', 'Spearman')</li>
<li>corr(X, 'type', 'Spearman')</li>
</ul></li>
<li><p>和皮尔逊相关系数的区别</p>
<ul>
<li>连续数据、正态分布、线性关系用皮尔逊，否则斯皮尔曼</li>
<li>定序数据用斯皮尔曼</li>
</ul></li>
</ul>
<h2 id="典型相关分析">典型相关分析</h2>
<h3 id="关键词-4">关键词</h3>
<ul>
<li>典型变量</li>
<li>典型相关系数（典型变量的相关系数）</li>
</ul>
<h3 id="作用-4">作用</h3>
<ul>
<li>研究两组变量之间的关系（相关系数是两个变量之间的关系）</li>
</ul>
<h3 id="spss">SPSS</h3>
<ul>
<li>分析-相关-典型分析性</li>
</ul>
<h2 id="多元回归分析">多元回归分析</h2>
<h3 id="分类">分类</h3>
<ul>
<li>线性回归、01回归、定序回归、计数回归和生存回归</li>
</ul>
<h3 id="作用-5">作用</h3>
<ul>
<li>过研究X和Y的相关关系，尝试去解释Y的形成机制，进而达到通过去预测Y的目的。</li>
</ul>
<h3 id="步骤">步骤</h3>
<ul>
<li>第一、识别重要变量（逐步回归法）</li>
<li>第二、判断相关性的方向（正相关或负相关）</li>
<li>第三、要估计权重（回归系数）</li>
</ul>
<h3 id="数据类型及处理方法">数据类型及处理方法</h3>
<ul>
<li>Subtopic</li>
</ul>
<h3 id="数据的收集">数据的收集</h3>
<ul>
<li>【简道云汇总】110+数据网 https://link.jiandaoyun.com/f/5cc652cc2cf3b22fb7819189</li>
<li>虫部落数据搜索 http://data.chongbuluo.com/</li>
<li>【汇总】数据来源/大数据平台 https://link.jiandaoyun.com/f/5b35d05ff7f6ef2604d39a93</li>
<li>大数据工具导航工具 http://hao.199it.com/</li>
</ul>
<h3 id="线性回归">线性回归</h3>
<ul>
<li>线性的理解</li>
<li>误差项和自变量有相关性会导致内生性，造成回归变量的不准确估计</li>
<li>实际应用中，只需保证核心解释变量与扰动项不相关</li>
<li>取对数的经验以及好处</li>
<li>虚拟变量</li>
<li>含有交互项的自变量</li>
</ul>
<h3 id="回归的应用">回归的应用</h3>
<ul>
<li>Stata</li>
<li>定量数据 summarize 简写sum</li>
<li>定性数据 tabulate 简写tab</li>
<li>tabulate 变量名, gen(A) 返回对应的这个变量的频率分布表，并生成对应的虚拟变量（以A开头）</li>
<li>regress y, x1, x2, …, xk</li>
<li>更多细节详见代码</li>
</ul>
<h2 id="图论最短路径问题">图论最短路径问题</h2>
<h3 id="两种作图方法">两种作图方法</h3>
<ul>
<li>在线作图CS Academy</li>
<li>MATLAB</li>
</ul>
<h3 id="迪杰斯特拉算法">迪杰斯特拉算法</h3>
<ul>
<li>缺点：不能处理负权重的图</li>
</ul>
<h3 id="贝尔曼-福特算法">贝尔曼-福特算法</h3>
<ul>
<li>可以处理负权重的有向图，但不能处理负权回路（无向图一个负权边就相当于负权回路）</li>
</ul>
<h3 id="matlab-4">MATLAB</h3>
<ul>
<li>graph无向图</li>
<li>digraph有向图</li>
<li>shortestpath求解指定两点最短路径</li>
<li>highlight高亮最短路径</li>
<li>distances返回任意两点最短的距离矩阵</li>
<li>nearest找给点范围内所有的点</li>
</ul>
<h2 id="分类-1">分类</h2>
<h3 id="逻辑回归">逻辑回归</h3>
<h3 id="fisher线性判别分析">Fisher线性判别分析</h3>
<ul>
<li><p>思想</p>
<ul>
<li>将所有点分割在超平面两侧，每个点投影到法向量上，使得类间距离大、类内距离小</li>
</ul></li>
</ul>
<h2 id="聚类">聚类</h2>
<h3 id="k-means算法">K-means算法</h3>
<ul>
<li><p>步骤</p>
<ul>
<li>一 指定需要划分的簇的数量K</li>
<li>二 随机地选择K个点作为初始聚类中心</li>
<li>三 计算每个数据点，将数据点划归为离该店最近的聚类中心所属的簇</li>
<li>四 每个簇计算中心点</li>
<li>五 循环三四步，直到收敛或达到最大迭代次数</li>
</ul></li>
<li><p>优点</p>
<ul>
<li>算法简单、快速</li>
<li>对处理大数据集，该算法是相对高效率的</li>
</ul></li>
<li><p>缺点</p>
<ul>
<li>要求用户必须事先给出要生成的簇的数目K</li>
<li>对初值敏感</li>
<li>对于孤立点数据敏感</li>
</ul></li>
</ul>
<h3 id="k-means算法-1">K-means++算法</h3>
<ul>
<li><p>提出</p>
<ul>
<li>为了解决K-means的第二、三个缺点</li>
</ul></li>
<li><p>改进后步骤</p>
<ul>
<li>一 随机选取一个样本点作为初始聚类中心</li>
<li>二 计算每个样本点与当前已有聚类中心的最短距离，每个点的概率和最短距离成正比，依据概率选出下一个聚类中心</li>
<li>三 重复二，直到选出K个聚类中心，之后使用标准K-means算法</li>
</ul></li>
<li><p>SPSS</p>
<ul>
<li>分析-分类-K均值分类</li>
</ul></li>
<li><p>注意事项</p>
<ul>
<li>如果单位不一样，可以先标准化再进行聚类</li>
</ul></li>
</ul>
<h3 id="系统层次聚类">系统（层次）聚类</h3>
<ul>
<li><p>提出</p>
<ul>
<li>为了解决K-means算法需要指定K的缺点</li>
</ul></li>
<li><p>样本间距离</p>
<ul>
<li>绝对值距离</li>
<li>欧式距离</li>
<li>明可夫斯基距离</li>
<li>切比雪夫距离</li>
<li>马氏距离</li>
</ul></li>
<li><p>类间距离</p>
<ul>
<li>最短距离法</li>
<li>最长距离法</li>
<li>组间平均连接法</li>
<li>组内平均连接法</li>
<li>重心法</li>
</ul></li>
<li><p>步骤</p>
<ul>
<li>一 计算n个样本间两两距离</li>
<li>二 构造n个类，每个类一个样本</li>
<li>三 合并距离最近的两个类为一新类</li>
<li>四 计算新类与当前各类的距离</li>
<li>五 重复三、四步，直到只剩一个类</li>
<li>六 画聚类图</li>
<li>七 决定分类个数</li>
</ul></li>
<li><p>确定K的方法</p>
<ul>
<li>肘部法则：通过图形估计最优的聚类数量</li>
<li>将聚类系数从大到小作散点图，在图上找折线由陡到缓的转折点就是K</li>
</ul></li>
</ul>
<h3 id="dbscan算法">DBSCAN算法</h3>
<ul>
<li><p>区别</p>
<ul>
<li>前几种算法基于距离定义，DBSCAN算法基于密度定义</li>
</ul></li>
<li><p>点的类别</p>
<ul>
<li>核心点：半径Eps内含有不少于MinPts数目的点</li>
<li>边界点：半径Eps内含有少于MinPts数目的点，但在核心点的领域内</li>
<li>噪音点：既不是核心点也不是边界点的点</li>
</ul></li>
<li><p>优点</p>
<ul>
<li>不需要预先指定聚类的数量</li>
<li>能够处理异常数据</li>
</ul></li>
</ul>
<h2 id="时间序列分析">时间序列分析</h2>
<h3 id="季节分解">季节分解</h3>
<ul>
<li><p>时间序列分类</p>
<ul>
<li>时期序列：时期序列中的观测值反映现象在一段时期内发展过程的总量，不同时期的观测值可以相加，相加结果表明现象在更长一段时间内的活动总量</li>
<li>时点序列：时点序列中的观测值反映现象在某一瞬间上所达到的水平，不同时期的观测值不能相加，相加结果没有实际意义。</li>
</ul></li>
<li><p>数值变化规律</p>
<ul>
<li>长期趋势T：例如新生儿死亡率随医学水平提高而下降</li>
<li>季节趋势S：例如百度指数</li>
<li>循环变动C：例如经济周期</li>
<li>不规则变动I：偶然因素</li>
</ul></li>
<li><p>适用情况</p>
<ul>
<li>数据具有周期性才能使用时间序列分解，月份数据或者季度数据，不能是年份数据</li>
<li>随时间推移序列季节波动变得越来越大则使用乘积模型（T<em>S</em>C*I），保持恒定则使用加法模型（T+S+C+I）</li>
</ul></li>
<li><p>对缺失值的处理</p>
<ul>
<li>缺失值在开头或尾部，直接删除，否则替换缺失值</li>
<li>替换缺失值方法：SPSS-转换-替换缺失值</li>
</ul></li>
<li><p>步骤</p>
<ul>
<li>一：定义时间变量（数据-定义日期和时间）</li>
<li>二：作时间序列图（分析-时间序列预测-序列图）</li>
<li>三：季节性分解（分析-时间序列预测-季节性分解）</li>
<li>四：对结果进行说明</li>
<li>五：画出分解后的时间序列图</li>
</ul></li>
<li><p>SPSS</p>
<ul>
<li>分析-时间序列预测-序列图</li>
<li>分析-时间序列预测-季节分解</li>
</ul></li>
</ul>
<h3 id="指数平滑">指数平滑</h3>
<ul>
<li><p>Subtopic</p></li>
<li><p>SPSS</p>
<ul>
<li>分析-时间序列预测-创建传统模型</li>
</ul></li>
</ul>
<h3 id="arima">ARIMA</h3>
<h2 id="预测模型">预测模型</h2>
<h3 id="灰色预测">灰色预测</h3>
<ul>
<li><p>概念</p>
<ul>
<li>灰色预测是对既含有已知信息又含有不确定信息的系统进行预则，就是对在一定范围内变化的、与时间有关的灰色过程进行预测。</li>
</ul></li>
<li><p>GM(1, 1)</p>
<ul>
<li>代表微分方程一阶、变量一个，本质是有条件的指数拟合</li>
<li>数据具有准指数规律是适用灰色系统建模的理论基础，所以需要判断累加一次后的序列是否具有准指数规律</li>
<li>发展系数越小预测的越精确</li>
</ul></li>
<li><p>GM(1, 1)模型的评价</p>
<ul>
<li>残差检验</li>
<li>级比偏差检验</li>
</ul></li>
<li><p>适用场景</p>
<ul>
<li>(1)数据是以年份度量的非负数据（如果是月份或者季度数据一定要用我们上一讲学过的时间序列模型）；</li>
<li>(2)数据能经过准指数规律的检验（除了前两期外,后面至少90%的期数的光滑比要低于0.5）</li>
<li>(3)数据的期数较短且和其他数据之间的关联性不强（小于等于10,也不能太短了，比如只有3期数据），要是数据期数较长，一般用传统的时间序列模型比较合适。</li>
</ul></li>
<li><p>步骤</p>
<ul>
<li>一：首先判断原始数据是否含负数或者低于4期，如果无下一步</li>
<li>二：对一次累加的数据进行准指数规律检验，如果符合下一步</li>
<li>三：输入需要预测的后续期数，分三种情况</li>
<li>四：绘制图形，并进行残差检验和级比偏差检验</li>
</ul></li>
</ul>
<h3 id="神经网络">神经网络</h3>
<ul>
<li><p>主要是MATLAB神经网络工具箱的使用</p></li>
<li><p>最好能够更改训练算法、神经元个数来让结果更有说服力</p></li>
<li><p>使用时在论文中要解释原理</p></li>
<li><p>训练算法</p>
<ul>
<li>莱文贝格-马夸特方法</li>
<li>贝叶斯正则化方法</li>
<li>量化共轭梯度法</li>
</ul></li>
</ul>
<h2 id="奇异值分解svd">奇异值分解SVD</h2>
<h3 id="用于图片和视频的压缩">用于图片和视频的压缩</h3>
<h2 id="主成分分析">主成分分析</h2>
<h3 id="作用-6">作用</h3>
<ul>
<li>降维，将多个变量转换成少数几个互不相关的主成分</li>
</ul>
<h3 id="步骤-1">步骤</h3>
<ul>
<li>标准化处理</li>
<li>计算标准化样本的协方差矩阵R（前两步可以合并用corrcoef）</li>
<li>计算R的特征值和特征向量</li>
<li>计算主成分的贡献率以及累计贡献率（一般达到80%即可）</li>
<li>写出主成分（根据累计贡献率）</li>
<li>分析主成分的含义（有模糊性，比较困难）</li>
<li>后续分析（聚类、回归）</li>
</ul>
<h3 id="注意事项-1">注意事项</h3>
<ul>
<li>不要在综合评价函数中使用主成分进行加权求得分</li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>八种常用排序算法总结</title>
    <url>/2019/07/06/%E5%85%AB%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>交换排序（冒泡排序，快速排序），插入排序（直接插入排序，希尔排序），选择排序（简单选择排序，堆排序），归并排序，基数排序</p>
<a id="more"></a>
<h2 id="冒泡排序bubble-sort">冒泡排序(Bubble Sort)</h2>
<p>冒泡排序步骤：</p>
<ol type="1">
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 冒泡排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 控制共比较多少轮</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 控制比较的次数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序quick-sort">快速排序(Quick Sort)</h2>
<p>  快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。</p>
<p>快速排序步骤</p>
<ol type="1">
<li>挑选基准值：从数列中挑出一个元素，称为“基准”（pivot）</li>
<li>分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成，</li>
<li>递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序</li>
</ol>
<p>  递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//快速排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="comment">// 把第0个数作为基准值</span></span><br><span class="line">            <span class="keyword">int</span> pivot = arr[start];</span><br><span class="line">            <span class="comment">// 记录需要排序的下标</span></span><br><span class="line">            <span class="keyword">int</span> low = start;</span><br><span class="line">            <span class="keyword">int</span> high = end;</span><br><span class="line">            <span class="comment">// 循环找比基准值大的数和比基准值小的数</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">                <span class="comment">// 右边的数字比基准值大</span></span><br><span class="line">                <span class="keyword">while</span> (low &lt; high &amp;&amp; pivot &lt;= arr[high]) &#123;</span><br><span class="line">                    high--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 使用右边的数字替换左边的数</span></span><br><span class="line">                arr[low] = arr[high];</span><br><span class="line">                <span class="comment">// 如果左边的数字比基准值小</span></span><br><span class="line">                <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;</span><br><span class="line">                    low++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 使用左边的数字替换右边的数</span></span><br><span class="line">                arr[high] = arr[low];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把基准值赋给低（或高）的那一边（这里low==high，所以都一样）</span></span><br><span class="line">            arr[low] = pivot;</span><br><span class="line">            <span class="comment">// 处理所有小的数字</span></span><br><span class="line">            quickSort(arr, start, low);</span><br><span class="line">            <span class="comment">// 处理所有大的数字</span></span><br><span class="line">            quickSort(arr, low + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序insert-sort">插入排序(Insert Sort)</h2>
<p>  插入排序原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。举个例子来说：插入排序的工作方式像许多人排序一手扑克牌。开始时，我们的左手为空并且桌面上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。</p>
<p>  插入排序所需的时间取决于输入中元素的初始顺序。例如，对一个很大且其中的元素已经有序（或接近有序）的数组进行排序将会比对随机顺序的数组或逆序数组进行排序要快得多。</p>
<p>插入排序步骤：</p>
<ol type="1">
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历所有数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 把当前遍历数字存起来</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果当前数字比temp大，就一直往前直到找到合适位置</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">                <span class="comment">// 把前一个数字赋给后一个数字</span></span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把临时变量赋给不满足条件的后一个值</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序shell-sort">希尔排序(Shell Sort)</h2>
<p>  希尔排序是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p>
<p>  希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ul>
<p>  希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//希尔排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历所有的步长</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = arr.length / <span class="number">2</span>; d &gt; <span class="number">0</span>; d /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历所有的元素</span></span><br><span class="line">            <span class="comment">//下面这个for循环取d=1和插入排序一样</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = d; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                <span class="keyword">int</span> j = i - d;</span><br><span class="line">                <span class="comment">// 遍历本组中所有的元素</span></span><br><span class="line">                <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前元素大于加上步长后的那个元素</span></span><br><span class="line">                    arr[j + d] = arr[j];</span><br><span class="line">                    j -= d;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j + d] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序selection-sort">选择排序(Selection Sort)</h2>
<p>  选择排序是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p>它有两个很鲜明的特点：<br />
　　运行时间与输入无关。为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息。这种性质在某些情况下是缺点，因为使用选择排序的人可能会惊讶的发现，一个已经有序的数组或是主键全部相等的数组和一个元素随机排列的数组所用的排序时间竟然一样长！相比之下，其它算法会更善于利用输入的初始状态。<br />
　　数据移动是最少的。每次交换都会改变两个数组元素的值，因此选择排序用了<span class="math inline">\(N\)</span>次交换——交换次数和数组大小是线性关系。其它的任何算法都不具备这个特征（大部分的增长数量级都是线性对数或平方级别）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 选择排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历所有的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 这里是记录最小数下标，也可以记录最小的数</span></span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="comment">// 把当前遍历的数和后面所有的数依次进行比较，并记录下最小的数的下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果后面比较的数比记录最小的数小</span></span><br><span class="line">                <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                    <span class="comment">// 记录下最小的那个数的下标</span></span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果最小的数和当前遍历的数的下标不一致,说明下标为minIndex的数比当前遍历的数更小</span></span><br><span class="line">            <span class="keyword">if</span> (i != minIndex) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[minIndex];</span><br><span class="line">                arr[minIndex] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序heap-sort">堆排序(Heap Sort)</h2>
<p>  堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p>
<p>通常堆是通过一维数组来实现的。在数组起始位置为0的情形中：</p>
<ul>
<li>父节点i的左子节点在位置<span class="math inline">\((2i+1)\)</span></li>
<li>父节点i的右子节点在位置<span class="math inline">\((2i+2)\)</span></li>
<li>子节点i的父节点在位置<span class="math inline">\(((i-1)/2)\)</span></li>
</ul>
<p>  堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余<span class="math inline">\(n-1\)</span>个元素重新构造成一个堆，这样会得到<span class="math inline">\(n\)</span>个元素的次小值。如此反复执行，便能得到一个有序序列了</p>
<p>堆排序的步骤</p>
<ol type="1">
<li>构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</li>
<li>将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//堆排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 开始位置是最后一个非叶子节点，即最后一个节点的父节点</span></span><br><span class="line">        <span class="keyword">int</span> start = (arr.length - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 调整大顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxHeap(arr, arr.length, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先把数组中第0个和堆中最后一个数交换位置，在把前面的处理为大顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            maxHeap(arr, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调整为大顶堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> size, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左子节点</span></span><br><span class="line">        <span class="keyword">int</span> leftNode = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 右子节点</span></span><br><span class="line">        <span class="keyword">int</span> rightNode = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> max = index;</span><br><span class="line">        <span class="comment">// 和两个子节点分别对比，找出最大的节点</span></span><br><span class="line">        <span class="keyword">if</span> (leftNode &lt; size &amp;&amp; arr[leftNode] &gt; arr[max]) &#123;</span><br><span class="line">            max = leftNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightNode &lt; size &amp;&amp; arr[rightNode] &gt; arr[max]) &#123;</span><br><span class="line">            max = rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换位置</span></span><br><span class="line">        <span class="keyword">if</span> (max != index) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[index];</span><br><span class="line">            arr[index] = arr[max];</span><br><span class="line">            arr[max] = temp;</span><br><span class="line">            <span class="comment">// 交换位置后可能破坏之前排好的堆，需要重新调整</span></span><br><span class="line">            maxHeap(arr, size, max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序merge-sort">归并排序(Merge Sort)</h2>
<p>  归并排序是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p>
<p>  归并排序的基本思路是将数组分成二组<span class="math inline">\(A，B\)</span>，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。要让<span class="math inline">\(A，B\)</span>两组内部数据有序，可以再将<span class="math inline">\(A，B\)</span>组各自分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数组，再合并数组就完成了归并排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//归并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="comment">// 处理左边</span></span><br><span class="line">            mergesort(arr, low, mid);</span><br><span class="line">            <span class="comment">// 处理右边</span></span><br><span class="line">            mergesort(arr, mid + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于存储归并后的临时数组</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 记录第一个数组中需要遍历的下标</span></span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="comment">// 记录第二个数组中需要遍历的下标</span></span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 用于记录在临时数组中存放的下标</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历两个数组，取出小的数字，放入临时数组中</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">            <span class="comment">// 如果第一个数组的数据更小</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 把小的数据放入临时数组中</span></span><br><span class="line">                temp[index] = arr[i];</span><br><span class="line">                <span class="comment">// 让下标向后移一位</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[index] = arr[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理多余的数据</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">            temp[index] = arr[j];</span><br><span class="line">            j++;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[index] = arr[i];</span><br><span class="line">            i++;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把临时数组中数据重新存入原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; temp.length; k++) &#123;</span><br><span class="line">            arr[k + low] = temp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基数排序radix-sort">基数排序(Radix Sort)</h2>
<p>  基数排序是一种非比较型整数排序算法，其原理是将所有待比较数值（正整数）统一为同样的数字长度，数字较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//基数排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixsort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存数组中最大的数字</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求最大数字的位数</span></span><br><span class="line">        <span class="keyword">int</span> maxlength = (max + <span class="string">""</span>).length();</span><br><span class="line">        <span class="comment">// 用于临时存储数据的数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">        <span class="comment">// 用于记录在temp中相应数组存放的数字数量；</span></span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">// 根据最大长度的数决定比较的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = <span class="number">1</span>; i &lt; maxlength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 把每一个数字分别计算余数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 计算余数</span></span><br><span class="line">                <span class="keyword">int</span> ys = arr[j] / n % <span class="number">10</span>;</span><br><span class="line">                <span class="comment">// 把当前遍历的数据放入指定的数组中</span></span><br><span class="line">                temp[ys][counts[ys]] = arr[j];</span><br><span class="line">                <span class="comment">// 记录数量</span></span><br><span class="line">                counts[ys]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录取的元素需要放的位置</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 把数字取出来</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; counts.length; k++) &#123;</span><br><span class="line">                <span class="comment">// 记录数量数组中当前余数记录的数量不为0</span></span><br><span class="line">                <span class="keyword">if</span> (counts[k] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 循环取出元素</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; counts[k]; l++) &#123;</span><br><span class="line">                        <span class="comment">// 取出元素</span></span><br><span class="line">                        arr[index] = temp[k][l];</span><br><span class="line">                        <span class="comment">// 记录下一个位置</span></span><br><span class="line">                        index++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 把数量置为0</span></span><br><span class="line">                    counts[k] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
</search>
