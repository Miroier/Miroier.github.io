<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2019/01/03/hello-world/</url>
    <content><![CDATA[<p>大家好，这里是Miroier。 <a id="more"></a> 第一次拥有自己的博客真的很开心。</p>
<p>以后应该会用这个博客来记录我学习中练习的代码和写的习题以及其它有趣的东西(咕咕咕~)。</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>判定是否同一棵二叉搜索树</title>
    <url>/2019/03/23/is-multiple-binary-trees-the-same/</url>
    <content><![CDATA[<p>给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列<span class="math inline">\(\lbrace2, 1, 3\rbrace\)</span>和<span class="math inline">\(\lbrace2, 3, 1\rbrace\)</span>插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。 <a id="more"></a></p>
<h4 id="输入格式">输入格式</h4>
<p>输入包含若干组测试数据。每组数据的第1行给出两个正整数N (≤10)和L，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出N个以空格分隔的正整数，作为初始插入序列。最后L行，每行给出N个插入的元素，属于L个需要检查的序列。</p>
<p>简单起见，我们保证每个插入序列都是1到N的一个排列。当读到N为0时，标志输入结束，这组数据不要处理。</p>
<h4 id="输出格式">输出格式</h4>
<p>对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。</p>
<h4 id="输入样例">输入样例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">3 1 4 2</span><br><span class="line">3 4 1 2</span><br><span class="line">3 2 4 1</span><br><span class="line">2 1</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h4 id="输出样例">输出样例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<h4 id="代码">代码</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Tree Left, Right;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Tree <span class="title">MakeTree</span><span class="params">(<span class="keyword">int</span> N)</span></span>;</span><br><span class="line"><span class="function">Tree <span class="title">insert</span><span class="params">(Tree T, <span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function">Tree <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> V)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(Tree T, <span class="keyword">int</span> V)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">(Tree T, <span class="keyword">int</span> N)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ResetT</span><span class="params">(Tree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span><span class="params">(Tree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, L, i;</span><br><span class="line">    Tree T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span> (N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;L);</span><br><span class="line">        T = MakeTree(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Judge(T, N))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">            ResetT(T);</span><br><span class="line">        &#125;</span><br><span class="line">        FreeTree(T);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">MakeTree</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree T;</span><br><span class="line">    <span class="keyword">int</span> i, V;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;V);</span><br><span class="line">    T = NewNode(V);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;V);</span><br><span class="line">        T = insert(T, V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">insert</span><span class="params">(Tree T, <span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">        T = NewNode(V);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (V &gt; T-&gt;v)</span><br><span class="line">            T-&gt;Right = insert(T-&gt;Right, V);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T-&gt;Left = insert(T-&gt;Left, V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree T = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">    T-&gt;v = V;</span><br><span class="line">    T-&gt;Left = T-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    T-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(Tree T, <span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (V &lt; T-&gt;v)</span><br><span class="line">            <span class="keyword">return</span> check(T-&gt;Left, V);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (V &gt; T-&gt;v)</span><br><span class="line">            <span class="keyword">return</span> check(T-&gt;Right, V);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (V == T-&gt;v)</span><br><span class="line">        &#123;</span><br><span class="line">            T-&gt;flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">(Tree T, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, V, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* flag: 0代表目前还一致，1代表已经不一致*/</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;V);</span><br><span class="line">    <span class="keyword">if</span> (V != T-&gt;v)</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        T-&gt;flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;V);</span><br><span class="line">        <span class="keyword">if</span> ((!flag) &amp;&amp; (!check(T, V)))<span class="comment">/*这么做是为了把所有的输入都读取完，以免对下一组数据造成影响*/</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ResetT</span><span class="params">(Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;Left)</span><br><span class="line">        ResetT(T-&gt;Left);</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;Right)</span><br><span class="line">        ResetT(T-&gt;Right);</span><br><span class="line">    T-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span><span class="params">(Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;Left)</span><br><span class="line">        FreeTree(T-&gt;Left);</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;Right)</span><br><span class="line">        FreeTree(T-&gt;Right);</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试点信息">测试点信息</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试点   提示</span><br><span class="line">0        sample 换顺序。有Yes，有No：根不同，子树根不同。树有单边、有双子树</span><br><span class="line">1        最大N，多组合</span><br><span class="line">2        N&#x3D;1，只有1个节点</span><br><span class="line">3        卡只判断数字相对先后位置的错误算法</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>matlab</title>
    <url>/2020/01/09/matlab/</url>
    <content><![CDATA[<p>笔记来自于《MATLAB2018从入门到精通》</p>
<a id="more"></a>
<h2 id="向量与多项式">向量与多项式</h2>
<h3 id="向量">向量</h3>
<h4 id="向量的生成">向量的生成</h4>
<h5 id="直接输入法">直接输入法</h5>
<img src="/2020/01/09/matlab/1_1.png" class="">
<img src="/2020/01/09/matlab/1_2.png" class="">
<h5 id="冒号法">冒号法</h5>
<img src="/2020/01/09/matlab/1_3.png" class="">
<h5 id="利用函数linspace创建向量">利用函数linspace创建向量</h5>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">linspace</span>(first_value, last_value, number)</span><br></pre></td></tr></table></figure>
<img src="/2020/01/09/matlab/1_4.png" class="">
<h5 id="利用函数logspace创建对数分割的向量">利用函数logspace创建对数分割的向量</h5>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">logspace</span>(first_value, last_value, number)</span><br></pre></td></tr></table></figure>
<img src="/2020/01/09/matlab/1_5.png" class="">
<h4 id="向量元素的引用">向量元素的引用</h4>
<table>
<thead>
<tr class="header">
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>x(n)</td>
<td>表示向量中的第n个元素</td>
</tr>
<tr class="even">
<td>x(n1:n2)</td>
<td>表示向量中的第n1至n2个元素</td>
</tr>
</tbody>
</table>
<h4 id="向量运算">向量运算</h4>
<h5 id="四则运算">四则运算</h5>
<img src="/2020/01/09/matlab/1_6.png" class="" title="对向量进行定义、赋值">
<img src="/2020/01/09/matlab/1_7.png" class="" title="加法">
<img src="/2020/01/09/matlab/1_8.png" class="" title="减法">
<img src="/2020/01/09/matlab/1_9.png" class="" title="乘法">
<img src="/2020/01/09/matlab/1_10.png" class="" title="除法">
<h5 id="点积运算">点积运算</h5>
<table>
<thead>
<tr class="header">
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>dot(a,b)</td>
<td>返回向量a与b的点积。a和b必须同维,当a、b都是列向量时，dot(a,b)等同于a.*b</td>
</tr>
<tr class="even">
<td>dot(a,b,dim)</td>
<td>返回向量a和b在dim维的点积</td>
</tr>
</tbody>
</table>
<img src="/2020/01/09/matlab/1_11.png" class="">
<h5 id="叉积运算">叉积运算</h5>
<table>
<thead>
<tr class="header">
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>cross(a,b)</td>
<td>返回向量a与b的叉积。a和b必须是三维的向量</td>
</tr>
<tr class="even">
<td>cross(a,b,dim)</td>
<td>返回向量a和b在dim维的点积。a和b需要有相同的维数，size(a,dim)和size(b,dim)的结果必须为3</td>
</tr>
</tbody>
</table>
<img src="/2020/01/09/matlab/1_12.png" class="">
<h5 id="混合积运算">混合积运算</h5>
<img src="/2020/01/09/matlab/1_13.png" class="">
<h3 id="多项式">多项式</h3>
<h4 id="多项式的创建">多项式的创建</h4>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">poly2sym(p) <span class="comment">%p为多项式的系数</span></span><br></pre></td></tr></table></figure>
<img src="/2020/01/09/matlab/1_14.png" class="">
<h4 id="多项式四则运算">多项式四则运算</h4>
<h5 id="乘法">乘法</h5>
<p><code>conv(p1,p2)</code> <img src="/2020/01/09/matlab/1_15.png" class=""></p>
<h5 id="除法">除法</h5>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[k,r]=deconv(p,q)</span><br></pre></td></tr></table></figure>
<p>k是p除以q的商，r是余式。 上式等价于</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">p=conv[q,k]+r;</span><br></pre></td></tr></table></figure>
<img src="/2020/01/09/matlab/1_16.png" class="">
<h4 id="多项式导数运算">多项式导数运算</h4>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">polyder(p) <span class="comment">%p为多项式的系数</span></span><br></pre></td></tr></table></figure>
<img src="/2020/01/09/matlab/1_17.png" class="">
<h2 id="矩阵运算">矩阵运算</h2>
<h3 id="矩阵创建">矩阵创建</h3>
<h4 id="利用m文件创建">利用M文件创建</h4>
<img src="/2020/01/09/matlab/2_1.png" class="">
<img src="/2020/01/09/matlab/2_2.png" class="">
<h4 id="利用文本创建">利用文本创建</h4>
<img src="/2020/01/09/matlab/2_3.png" class="">
<img src="/2020/01/09/matlab/2_4.png" class="">
<h4 id="创建特殊矩阵">创建特殊矩阵</h4>
<img src="/2020/01/09/matlab/2_5.png" class="">
<h3 id="矩阵元素的运算">矩阵元素的运算</h3>
<h4 id="矩阵元素的修改">矩阵元素的修改</h4>
<table>
<colgroup>
<col style="width: 43%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="header">
<th>命令名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>D=[A;B C]</td>
<td>A为原矩阵，B、C中包含要扩充的元素，D为扩充后的矩阵</td>
</tr>
<tr class="even">
<td>A(m;:)=[]</td>
<td>删除A的第m行</td>
</tr>
<tr class="odd">
<td>A(:,n)</td>
<td>删除A的第n列</td>
</tr>
<tr class="even">
<td>A(m,n)=a; A(m,:)=[a b ...]; A(:,n)=[a b ...]</td>
<td>对A的第m列第n行的元素赋值；对A的第m行赋值；对A的第n列赋值</td>
</tr>
</tbody>
</table>
<img src="/2020/01/09/matlab/2_6.png" class="">
<h4 id="矩阵的变维">矩阵的变维</h4>
<img src="/2020/01/09/matlab/2_7.png" class="">
<img src="/2020/01/09/matlab/2_8.png" class="">
<h4 id="矩阵的变向">矩阵的变向</h4>
<table>
<thead>
<tr class="header">
<th>命令名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Rot(90)</td>
<td>将A逆时针方向旋转90°</td>
</tr>
<tr class="even">
<td>Rot(90,k)</td>
<td>将A逆时针方向旋转90° *k，k可为正整数或负整数</td>
</tr>
<tr class="odd">
<td>Fliplr(X)</td>
<td>将X左右翻转</td>
</tr>
<tr class="even">
<td>flipud(X)</td>
<td>将X上下翻转</td>
</tr>
<tr class="odd">
<td>flipdim(X,dim)</td>
<td>dim=1时对行翻转,dim=2时对列翻转</td>
</tr>
</tbody>
</table>
<img src="/2020/01/09/matlab/2_9.png" class="">
<h4 id="矩阵的抽取">矩阵的抽取</h4>
<p>矩阵的抽取主要是指对角元素和上（下）三角阵的抽取。 <img src="/2020/01/09/matlab/2_10.png" class=""> <img src="/2020/01/09/matlab/2_11.png" class=""></p>
<h3 id="矩阵的数学运算">矩阵的数学运算</h3>
<h4 id="加减">加减</h4>
<p>只有相同维度的矩阵才能进行计算 <img src="/2020/01/09/matlab/2_12.png" class=""> 减法只需将<code>+</code>改成<code>-</code></p>
<h4 id="乘法-1">乘法</h4>
<h5 id="数乘">数乘</h5>
<img src="/2020/01/09/matlab/2_13.png" class="">
<h5 id="矩阵乘法">矩阵乘法</h5>
<img src="/2020/01/09/matlab/2_14.png" class="">
<h5 id="点乘">点乘</h5>
<img src="/2020/01/09/matlab/2_15.png" class="">
<h4 id="除法-1">除法</h4>
<p>计算左除A，A的行数要与B的行数一致，计算右除A/B时，A的列数要与B的列数一致。</p>
<h5 id="左除">左除</h5>
<img src="/2020/01/09/matlab/2_16.png" class="">
<h5 id="右除">右除</h5>
<img src="/2020/01/09/matlab/2_17.png" class="">
<h3 id="矩阵运算-1">矩阵运算</h3>
<img src="/2020/01/09/matlab/2_18.png" class="">
<h4 id="幂函数">幂函数</h4>
<img src="/2020/01/09/matlab/2_19.png" class="">
<p>另外还有指数函数，对数函数，平方根函数等。</p>
<h4 id="矩阵的逆">矩阵的逆</h4>
<img src="/2020/01/09/matlab/2_20.png" class="">
<img src="/2020/01/09/matlab/2_21.png" class="">
<p>操作的对象必须是方阵</p>
<h4 id="矩阵的条件数">矩阵的条件数</h4>
<img src="/2020/01/09/matlab/2_22.png" class="">
<h4 id="矩阵的范数">矩阵的范数</h4>
<img src="/2020/01/09/matlab/2_23.png" class="">
<h2 id="二维绘图">二维绘图</h2>
<h3 id="二维绘图-1">二维绘图</h3>
<h4 id="plot">plot</h4>
<p><code>plot(x)</code> <img src="/2020/01/09/matlab/3_1.png" class=""></p>
<p><code>plot(x,y)</code> <img src="/2020/01/09/matlab/3_2.png" class=""></p>
<p><code>subplot(x,y)</code> <img src="/2020/01/09/matlab/3_3.png" class=""></p>
<p><code>plot(x,y,s)</code> s用来设置所画数据点的类型、大小、颜色以及数据点之间连线的类型、粗细、颜色等。 <img src="/2020/01/09/matlab/3_4.png" class="" title="颜色控制字符表"> <img src="/2020/01/09/matlab/3_5.png" class="" title="线性符号及说明"> <img src="/2020/01/09/matlab/3_6.png" class="" title="hanzibuxing"></p>
<p><code>plot(x1,y1,s1,x2,y2,s2,···)</code> 运行此命令等价于依次执行plot(xi,yi,si),i=1,2,...</p>
<h4 id="fplot">fplot</h4>
<p>  fplot命令也是MATLAB提供的一个画图命令，它是一个专门用于画一元函数图像的命令。<br />
  虽然plot命令也可以画一元函数图像，但plot命令是依据我们给定的数据点来作图的，而在实际情况中，一般并不清楚函数的具体情况，因此依据我们所选取的数据点作的图像可能会忽略真实函数的某些重要特性，给科研工作造成不可估计的损失。MATLAB提供了专门绘制一元函数图像的fplot命令，它用来指导数据点的选取，通过其内部自适应算法，在函数变化比较平稳处，它所取的数据点就会相对稀疏一点，在函数变化明显处所取的数据点就会自动密一些，因此用fplot命令所作出的图像要比用plot命令作出的图像光滑准确。 <img src="/2020/01/09/matlab/3_7.png" class="" title="fplot的调用格式"> <img src="/2020/01/09/matlab/3_8.png" class="" title="对于上面用法的几点说明"></p>
<h4 id="ezplot">ezplot</h4>
<p>ezplot可以很容易地将一个符号函数图形化 <img src="/2020/01/09/matlab/3_9.png" class="" title="ezplot 命令的调用格式"> <img src="/2020/01/09/matlab/3_10.png" class=""> <img src="/2020/01/09/matlab/3_11.png" class=""></p>
<h3 id="不同坐标系下的绘图命令">不同坐标系下的绘图命令</h3>
<h4 id="极坐标系下绘图">极坐标系下绘图</h4>
<img src="/2020/01/09/matlab/3_12.png" class="">
<img src="/2020/01/09/matlab/3_13.png" class="">
<img src="/2020/01/09/matlab/3_14.png" class="">
<h2 id="图形标注">图形标注</h2>
<h3 id="图形属性设置">图形属性设置</h3>
<h4 id="坐标系与坐标轴">坐标系与坐标轴</h4>
<h5 id="坐标系的调整">坐标系的调整</h5>
<p>  MATLAB的绘图函数可根据要绘制的曲线数据的范围自动选择合适的坐标系，使得曲线尽可能清晰的显示出来。所以，一般情况下用户不必自己选择绘图坐标。但是有些图形，如果用户感觉自动选择的坐标不合适，则可以利用函数axis()选择新的坐标系。<br />
  函数axis()的调用格式为：<code>axis(xmin,xmax,ymin,ynax,zmin,zmax}</code>   这个函数格式的功能是设置x, y, z 坐标的最小值和最大值。函数输入参数可以是4个，也可以是6个，分别对应于二维或三维坐标系的最大和最小值。</p>
<h5 id="坐标轴的调整">坐标轴的调整</h5>
<p>axis命令用于控制坐标轴的显示、刻度、长度等特征</p>
<img src="/2020/01/09/matlab/4_1.png" class="" title="axis 命令的调用格式">
<img src="/2020/01/09/matlab/4_2.png" class="">
<img src="/2020/01/09/matlab/4_3.png" class="">
<img src="/2020/01/09/matlab/4_4.png" class="">
<h4 id="图形注释">图形注释</h4>
<h5 id="填充图形">填充图形</h5>
<p>fill 函数用于填充二维封闭多边形，其函数格式如下所示。 <img src="/2020/01/09/matlab/4_5.png" class=""> <img src="/2020/01/09/matlab/4_6.png" class=""> <img src="/2020/01/09/matlab/4_7.png" class=""></p>
<h5 id="注释图形标题及轴名称">注释图形标题及轴名称</h5>
<p>MATLAB中，title命令用于给图形对象加标题。</p>
<img src="/2020/01/09/matlab/4_8.png" class="" title="title 命令的格式调用">
<p><strong>说明：</strong>可以利用gcf 与gca 来获取当前图形窗口与当前坐标轴的旬柄。</p>
<p>  对坐标轴进行标注，相应的命令为xlabel、ylabel、zlabel，作用分别是对x轴、y轴、z轴进行标注，它们的调用格式都是一样的。</p>
<img src="/2020/01/09/matlab/4_9.png" class="" title="xlabel 命令的调用格式">
<h5 id="图形标注-1">图形标注</h5>
<p>  在给所绘得的图形进行详细的标注时，最常用的两个命令是text与gtext，它们均可以在图形的具体部位进行标注。</p>
<h5 id="text命令">text命令</h5>
<img src="/2020/01/09/matlab/4_10.png" class="" title="text 命令的调用格式">
<img src="/2020/01/09/matlab/4_11.png" class="" title="text 命令属性列表">
<img src="/2020/01/09/matlab/4_12.png" class="" title="续表">
<p>上表中的这些属性及相应的值都可以通过get 命令来查看，以及用set 命令来修改。</p>
<h5 id="gtext命令">gtext命令</h5>
<p>  gtext命令可以让鼠标在图形的任意位置进行标注。当光标进入图形窗口时，会变成一个大十字架形，等待用户的操作。调用格式如下：</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">gtext (<span class="string">'string'</span>,<span class="string">'property'</span>, propertyvalue,···)</span><br></pre></td></tr></table></figure>
<p>  调用这个函数后，图形窗口中的鼠标指针会成为十字光标，通过移动鼠标来进行定位，即光标移到预定位置后按下鼠标左键或键盘上的任意键都会在光标位置显示指定文本“string”。由于要用鼠标操作，该函数只能在MATLAB命令行窗口中进行。</p>
<h5 id="图例标注">图例标注</h5>
<p>  当在一幅图中出现多种曲线时，用户可以根据自己的需要，利用legend 命令对不同的图例进行说明。</p>
<img src="/2020/01/09/matlab/4_13.png" class="" title="legend 命令的调用格式">
<img src="/2020/01/09/matlab/4_14.png" class="" title="pos取值">
<h5 id="分隔线控制">分隔线控制</h5>
<img src="/2020/01/09/matlab/4_15.png" class="" title="grid 命令的调用格式">
<h3 id="特殊图形">特殊图形</h3>
<h4 id="统计图形">统计图形</h4>
<h5 id="条形图">条形图</h5>
<p>  绘制条形图时可分为二维情况和三维情况，其中绘制二维条形图的命令为bar（竖直条形图）与barh（水平条形图）；绘制三维条形图的命令为bar3（竖直条形图）与bar3h（水平条形图）。它们的调用格式都是一样的，因此我们只介绍bar的调用格式</p>
<img src="/2020/01/09/matlab/4_16.png" class="" title="bar 命令的调用格式">
<h5 id="面积图">面积图</h5>
<p>  面积图在实际中可以表现不同部分对整体的影响。在MATLAB中，绘制面积图的命令是area，它的调用格式见表</p>
<img src="/2020/01/09/matlab/4_17.png" class="" title="area 命令的调用格式">
<h5 id="饼图">饼图</h5>
<p>  饼图用来显示向量或矩阵中各元素所占的比例，它可以用在一些统计数据可视化中。在二维情况下，创建饼图的命令是pie，三维情况下创建饼图的命令是pie3，二者的调用格式也非常相似，因此我们只介绍pie的调用格式。</p>
<img src="/2020/01/09/matlab/4_18.png" class="" title="pie 命令的调用格式">
<h5 id="柱状图">柱状图</h5>
<p>MATLAB中，绘制柱状图的命令有两个：<br />
hist命令：它用来绘制直角坐标系下的柱状图。<br />
rose命令：它用来绘制极坐标系下的柱状图。</p>
<img src="/2020/01/09/matlab/4_19.png" class="" title="hist 命令的调用格式">
<img src="/2020/01/09/matlab/4_20.png" class="" title="rose 命令的调用格式">
<blockquote>
<p>实例一一各个季度所占营利总额的比例统计图 <img src="/2020/01/09/matlab/4_21.png" class=""> <img src="/2020/01/09/matlab/4_22.png" class=""></p>
</blockquote>
<p><strong>注意：</strong>饼图的标注比较特别，其标签是作为文本图形对象来处理的，如果要修改标注文本字符串或位置，则首先要获取相应对象的字符串及其范围，然后再加以修改。</p>
<blockquote>
<p>实例一一绘制柱状图 <img src="/2020/01/09/matlab/4_23.png" class=""> <img src="/2020/01/09/matlab/4_24.png" class=""> <img src="/2020/01/09/matlab/4_25.png" class="" title="直角坐标系和极坐标系下的柱状图"></p>
</blockquote>
<h4 id="离散数据图形">离散数据图形</h4>
<p>  除了上面提到的统计图形外，MATLAB还提供了一些在工程计算中常用的离散数据图形，例如误差棒图、火柴杆图与阶梯图等。</p>
<h5 id="误差棒图">误差棒图</h5>
<p>MATLAB 中绘制误差棒图的命令为errorbar</p>
<img src="/2020/01/09/matlab/4_26.png" class="" title="errorbar 命令的调用格式">
<blockquote>
<p>实例一一绘制铸件尺寸误差棒图 <img src="/2020/01/09/matlab/4_27.png" class=""></p>
</blockquote>
<h5 id="火柴杆图">火柴杆图</h5>
<p>  用线条显示数据点与x轴的距离，用一小圆圈（默认标记〉或用指定的其他标记符号与线条相连，并在y轴上标记数据点的值，这样的图形称为火柴杆图。在二维情况下，实现这种操作的命令是stem。</p>
<img src="/2020/01/09/matlab/4_28.png" class="" title="stem命令的调用格式">
<p>在三维情况下，也有相应的画火柴杆图的命令stem3。</p>
<img src="/2020/01/09/matlab/4_29.png" class="" title="stem3命令的调用格式">
<blockquote>
<p>实例一一绘制火柴杆图 <img src="/2020/01/09/matlab/4_30.png" class=""> <img src="/2020/01/09/matlab/4_31.png" class=""></p>
</blockquote>
<h5 id="阶梯图">阶梯图</h5>
<p>  阶梯图在电子信息工程以及控制理论中用得非常多，在MATLAB 中，实现这种作图的命令是stairs。</p>
<img src="/2020/01/09/matlab/4_32.png" class="" title="stairs 命令的调用格式">
<blockquote>
<p>实例一一给制阶梯图 <img src="/2020/01/09/matlab/4_33.png" class=""> <img src="/2020/01/09/matlab/4_34.png" class=""></p>
</blockquote>
<h4 id="向量图形">向量图形</h4>
<p>  由于物理等学科的需要，在实际中有时需要绘制一些带方向的图形，即向量图。对于这种图形的绘制， MATLAB 中也有相关的命令，本小节就来学一下几个常用的命令。</p>
<h5 id="罗盘图">罗盘图</h5>
<p>  罗盘图即起点为坐标原点的二维或三维向量，同时还在坐标系中显示圆形的分隔线。实现这种作图的命令是compass。</p>
<img src="/2020/01/09/matlab/4_35.png" class="" title="compass 命令的调用格式">
<h5 id="羽毛图">羽毛图</h5>
<p>  羽毛图是在横坐标上等距地显示向量的图形，看起来就像鸟的羽毛一样。它的绘制命令是feather。</p>
<img src="/2020/01/09/matlab/4_36.png" class="" title="feather 命令的调用格式">
<blockquote>
<p>实例一一罗盘图与羽毛图 <img src="/2020/01/09/matlab/4_37.png" class=""> <img src="/2020/01/09/matlab/4_38.png" class=""></p>
</blockquote>
<h5 id="箭头图">箭头图</h5>
<p>  上面两个命令绘制的图也可以叫做箭头图，但即将要讲的箭头图比上面两个箭头图更像数学中的向量，即它的箭头方向为向量方向，箭头的长短表示向量的大小。这种图的绘制命令是quiver与quiver3 ，前者绘制的是二维图形，后者绘制是三维图形。它们的调用格式也十分相似，只是后者比前者多一个坐标参数，因此我们只介绍一下quiver的调用格式。</p>
<img src="/2020/01/09/matlab/4_39.png" class="" title="quiver 命令的调用格式">
<p>quiver与quiver3这两个命令经常与其他的绘图命令配合使用，见下例。</p>
<blockquote>
<p>实例一一绘制箭头图形 <img src="/2020/01/09/matlab/4_40.png" class=""> <img src="/2020/01/09/matlab/4_41.png" class=""></p>
</blockquote>
<h2 id="三维绘图">三维绘图</h2>
<h3 id="三维绘图-1">三维绘图</h3>
<p>  在实际的工程设计中， 二维绘图功能在某些场合往往无法更直观地表达数据的分析结果，常常需要将结果表示成三维图形。MATLAB 为此提供了相应的三维绘图功能，三维绘图与二维绘图功能有异曲同工之效。用于三维绘图的MATLAB 高级绘图函数中，对于上述许多问题都设置了默认值，应尽量使用默认值。<br />
  为了显示三维图形， MATLAB 提供了各种各样的函数。有一些函数可在三维空间中画线，而另一些可以画曲面与线格框架。另外，颜色可以用来代表第四维。当颜色以这种方式使用时，不但它不再具有像照片中那样显示色彩的自然属性，而且也不具有基本数据的内在属性，所以把它称作为彩色。本章主要介绍三维图形的作图方法和效果。</p>
<h4 id="三维曲线绘图命令">三维曲线绘图命令</h4>
<h5 id="plot3">plot3</h5>
<p>  plot3命令是二维绘图plot命令的扩展，因此它们的使用格式也基本相同，只是在参数中多加了一个第三维的信息。例如plot(x,y,z)与plot3(x,y,z,s)的意义是一样的，前者绘的是二维图，后者绘的是三维图，后面的参数s也是用来控制曲线的类型、粗细、颜色等。</p>
<blockquote>
<p>实例一一绘制空间直线 <img src="/2020/01/09/matlab/5_1.png" class=""> <img src="/2020/01/09/matlab/5_2.png" class=""> 实例一一绘制三维曲线 <img src="/2020/01/09/matlab/5_3.png" class=""> <img src="/2020/01/09/matlab/5_4.png" class=""></p>
</blockquote>
<h5 id="ezplot3">ezplot3</h5>
<p>  同二维情况一样， 三维绘图里也有一个专门绘制符号函数的命令ezplot3。 <img src="/2020/01/09/matlab/5_5.png" class=""></p>
<h4 id="三维网格命令">三维网格命令</h4>
<h5 id="mesh">mesh</h5>
<p>  该命令生成的是由X、Y和Z指定的网线面，而不是单根曲线。</p>
<img src="/2020/01/09/matlab/5_6.png" class="">
<p>  在演示之前，我们先来学一个常用的命令meshgrid，它用来生成二元函数z=f(x,y)中xy平面上的矩形定义域中数据点矩阵X和Y，或者是三元函数u=f(x,y,z)中立方体定义域中的数据点矩阵X、Y和Z。</p>
<img src="/2020/01/09/matlab/5_7.png" class="">
<blockquote>
<p>实例一一绘制网格面 <img src="/2020/01/09/matlab/5_8.png" class=""> <img src="/2020/01/09/matlab/5_9.png" class=""></p>
</blockquote>
<p>  对于一个三维网格图，有时用户不想显示背后的网格，这时可以利用hidden 命令来实现这种要求。它的使用格式也非常简单。</p>
<img src="/2020/01/09/matlab/5_10.png" class="" title="hidden 命令的调用格式">
<blockquote>
<p>实例一一绘制山峰曲面 <img src="/2020/01/09/matlab/5_11.png" class=""> <img src="/2020/01/09/matlab/5_12.png" class=""></p>
</blockquote>
<p>  MATLAB还有两个同类的函数：meshc与meshz。meshc用来画图形的网格图加基本的等高线图，meshz用来画图形的网格图与零平面的网格图。</p>
<blockquote>
<p>实例一一绘制函数曲面 <img src="/2020/01/09/matlab/5_13.png" class=""> <img src="/2020/01/09/matlab/5_14.png" class=""></p>
</blockquote>
<h5 id="ezmesh">ezmesh</h5>
<p>  该命令专门用来绘制符号函数f(x, y) （即f是关于x 、y 的数学函数的字符串表示）的网格图形。</p>
<img src="/2020/01/09/matlab/5_15.png" class="" title="ezmesh 命令的调用格式">
<blockquote>
<p>实例一一绘制符号函数曲面 <img src="/2020/01/09/matlab/5_16.png" class=""> <img src="/2020/01/09/matlab/5_17.png" class=""></p>
</blockquote>
<h4 id="三维曲面命令">三维曲面命令</h4>
<h5 id="surf">surf</h5>
<p>  surf命令的调用格式与mesh命令完全一样，这里就不再详细说明了。下面给出几个例子。</p>
<blockquote>
<p>实例一一绘制山峰表面 <img src="/2020/01/09/matlab/5_18.png" class=""> <img src="/2020/01/09/matlab/5_19.png" class=""></p>
</blockquote>
<p>  如果想查看曲面背后图形的情况，可以在曲面的相应位置打个洞孔，即将数据设置为NaN,所有的MATLAB作图函数都忽略NaN的数据点，在该点出现的地方留下一个洞孔。</p>
<blockquote>
<p>实例一一绘制带洞孔的山峰表面 <img src="/2020/01/09/matlab/5_20.png" class=""> <img src="/2020/01/09/matlab/5_21.png" class=""></p>
</blockquote>
<h5 id="ezsurf">ezsurf</h5>
<p>  该命令专门用来绘制符号函数f(x,y)（即f是关于x、y的数学函数的字符串表示）的表面图形。</p>
<img src="/2020/01/09/matlab/5_22.png" class="" title="ezsurf 命令的调用格式">
<blockquote>
<p>绘制参数曲面 <img src="/2020/01/09/matlab/5_23.png" class=""> <img src="/2020/01/09/matlab/5_24.png" class=""></p>
</blockquote>
<h4 id="柱面与球面">柱面与球面</h4>
<p>  在MATLAB中，有专门绘制柱面与球面的命令cylinder与sphere，它们的使用格式也非常简单。首先来看cylinder命令。</p>
<img src="/2020/01/09/matlab/5_25.png" class="">
<blockquote>
<p>实例一一绘制柱面 <img src="/2020/01/09/matlab/5_26.png" class=""> <img src="/2020/01/09/matlab/5_27.png" class=""></p>
</blockquote>
<p><strong>小技巧：</strong>用cylinder可以作棱柱的图像，例如运行cylinder(2,6)将绘出底面为正六边形、半径为2的棱柱。</p>
<p>  sphere命令用来生成三维直角坐标系中的球面。</p>
<img src="/2020/01/09/matlab/5_28.png" class="" title="sphere 命令的调用格式">
<blockquote>
<p>实例一一绘制球面 <img src="/2020/01/09/matlab/5_29.png" class=""> <img src="/2020/01/09/matlab/5_30.png" class=""></p>
</blockquote>
<h4 id="三维图形等值线">三维图形等值线</h4>
<p>  在军事、地理等学科中经常会用到等值线。在MATLAB中有许多绘制等值线的命令，我们主要介绍以下几个。</p>
<h5 id="contour3">contour3</h5>
<p>  contour3是三维绘图中最常用的绘制等值线的命令，该命令生成一个定义在矩形格栅上曲面的三维等值线图。</p>
<img src="/2020/01/09/matlab/5_31.png" class="" title="contour 命令的调用格式">
<blockquote>
<p>实例一一三维等值线图 <img src="/2020/01/09/matlab/5_32.png" class=""> <img src="/2020/01/09/matlab/5_33.png" class=""></p>
</blockquote>
<h5 id="contour">contour</h5>
<p>  contour3用于绘制二维图时就等价于contour，后者用来绘制二维等值线，可以看作是一个三维曲面向xy平面上的投影。</p>
<img src="/2020/01/09/matlab/5_34.png" class="" title="contour">
<blockquote>
<p>实例一一绘制二维等值线图 <img src="/2020/01/09/matlab/5_35.png" class=""> <img src="/2020/01/09/matlab/5_36.png" class=""></p>
</blockquote>
<h5 id="contourf">contourf</h5>
<p>  此命令用来填充二维等值线图，即先画出不同等值线，然后将相邻的等值线之间用同一颜色进行填充，填充用的颜色决定于当前的色图颜色。</p>
<img src="/2020/01/09/matlab/5_37.png" class="" title="contourf 命令的调用格式">
<blockquote>
<p>实例一一绘制二维等值线图及颜色填充 <img src="/2020/01/09/matlab/5_38.png" class=""> <img src="/2020/01/09/matlab/5_39.png" class=""></p>
</blockquote>
<h5 id="contourc">contourc</h5>
<p>  该命令计算等值线矩阵C，该矩阵可用于命令contour、contour3 和contourf等。矩阵Z中的数值确定平面上的等值线高度值，等值线的计算结果用由矩阵Z维数决定的间隔的宽度。</p>
<img src="/2020/01/09/matlab/5_40.png" class="" title="contourc 命令的调用格式">
<h5 id="clabel">clabel</h5>
<p>  clabel命令用来在二维等值线图中添加高度标签。</p>
<img src="/2020/01/09/matlab/5_41.png" class="">
<p>对上面的使用格式，需要说明的一点是，若命令中有h，则会对标签进行恰当的旋转，否则标签会竖直放置，且在恰当的位置显示一个“＋” 号。</p>
<blockquote>
<p>实例一一绘制等值线 <img src="/2020/01/09/matlab/5_42.png" class=""> <img src="/2020/01/09/matlab/5_43.png" class=""></p>
</blockquote>
<h5 id="ezcontour">ezcontour</h5>
<p>  该命令专门用来绘制符号函数f(x,y)（即f是关于x、y的数学函数的字符串表示）的等值线图。</p>
<img src="/2020/01/09/matlab/5_44.png" class="" title="ezcontour 命令的调用格式">
<blockquote>
<p>实例一一绘制符号函数等值线图 <img src="/2020/01/09/matlab/5_45.png" class=""> <img src="/2020/01/09/matlab/5_46.png" class=""></p>
</blockquote>
<h5 id="ezsurfc">ezsurfc</h5>
<p>  该命令用来绘制函数f(x,y)的带等值线的三维表面图，其中函数f是一个以字符串形式给出的二元函数。</p>
<img src="/2020/01/09/matlab/5_47.png" class="" title="ezsurfc 命令的调用格式">
<blockquote>
<p>实例一一绘制带等值线的三维表面图 <img src="/2020/01/09/matlab/5_48.png" class=""> <img src="/2020/01/09/matlab/5_49.png" class=""></p>
</blockquote>
<h3 id="三维图像修饰处理">三维图像修饰处理</h3>
<h4 id="视角处理">视角处理</h4>
<p>  在现实空间中，从不同角度或位置观察某一事物就会有不同的效果，即会有“横看成岭侧成峰”的感觉。三维图形表现的正是一个空间内的图形，因此在不同视角及位置都会有不同的效果，这在工程实际中也是经常遇到的。MATLAB 提供的view 命令能够很好地满足这种需要。   view 命令用来控制三维图形的观察点和视角。</p>
<img src="/2020/01/09/matlab/5_50.png" class="" title="view 命令的调用格式">
<p>  对于这个命令需要说明的是，方位角az与仰角el为两个旋转角度。做一通过视点和z轴平行的平面，与xy平面有一交线，该交线与y轴的反方向的、按逆时针方向（从z轴的方向观察）计算的夹角，就是观察点的方位角az；若角度为负值，则按顺时针方向计算。在通过视点与z轴的平面上，用一直线连接视点与坐标原点，该直线与xy平面的夹角就是观察点的仰角el；若仰角为负值，则观察点转移到曲面下面。</p>
<blockquote>
<p>实例一一绘制网格面视图 <img src="/2020/01/09/matlab/5_51.png" class=""> <img src="/2020/01/09/matlab/5_52.png" class=""></p>
</blockquote>
<h4 id="颜色处理">颜色处理</h4>
<h5 id="色图明暗控制命令">色图明暗控制命令</h5>
<p>MATLAB中，控制色图明暗的命令是brighten命令。</p>
<img src="/2020/01/09/matlab/5_53.png" class="" title="brighten 命令的调用格式">
<h5 id="色轴刻度">色轴刻度</h5>
<p>  caxis命令控制着对应色图的数据值的映射图。它通过将被变址的颜色数据（CData）与颜色数据映射（CDataMapping）设置为scaled，影响着任何的表面、块、图像：该命令还改变坐标轴图形对象的属性Clim与ClimMode。</p>
<img src="/2020/01/09/matlab/5_54.png" class="" title="caxis 命令的调用格式">
<blockquote>
<p>实例一一映射球面表里颜色 <img src="/2020/01/09/matlab/5_55.png" class=""> <img src="/2020/01/09/matlab/5_56.png" class=""></p>
</blockquote>
<p>  在MATLAB中，还有一个画色轴的命令colorbar，这个命令在图形窗口的工具条中有相应的图标。</p>
<img src="/2020/01/09/matlab/5_57.png" class="" title="colorbar 命令的调用格式} ##### 颜色渲染设置 &amp;emsp;&amp;emsp;shading命令用来控制曲面与补片等的图形对象的颜色渲染，同时设置当前坐标轴中的所有曲面与补片图形对象的属性EdgeColor与FaceColor。 {% asset_img 5_58.png shading 命令的调用格式">
<blockquote>
<p>实例一一渲染图形 <img src="/2020/01/09/matlab/5_59.png" class=""> <img src="/2020/01/09/matlab/5_60.png" class=""></p>
</blockquote>
<h5 id="颜色映像使用">颜色映像使用</h5>
<p>  语句colormap(M)将矩阵M作为当前图形窗口所用的颜色映像。例如，colormap(cool)装入了一个有64个输入项的cool颜色映像。colormap default装入了默认的颜色映像（hsv）。<br />
  函数plot、plot3、contour和contour3不使用颜色映像，它们使用列在plot颜色和线形表中的颜色。而大多数其他绘图函数，比如mesh、surf、fill、pcolor和它们的各种变形函数，使用当前的颜色映像。<br />
  接受颜色参量的绘图函数中的颜色参量通常采用以下3 种形式之一:</p>
<ol type="1">
<li>字符串，代表plot颜色或线型表中的一种颜色，比如'r'代表红色。</li>
<li>3个输入的行向量，它代表一个单独的RGB值，比如[.25 .50 .75]。</li>
<li>矩阵，如果颜色参量是一个矩阵，其元素做了调整，并把它们用作当前颜色映射的下标。</li>
</ol>
<blockquote>
<p>实例一一颜色映像 <img src="/2020/01/09/matlab/5_61.png" class=""> <img src="/2020/01/09/matlab/5_62.png" class=""></p>
</blockquote>
<h4 id="光照处理">光照处理</h4>
<p>  在MATLAB中绘制三维图形时，我们不仅可以画出带光照模式的曲面，还能在绘图时指定光线的来源。</p>
<h5 id="带光照模式的三维曲面">带光照模式的三维曲面</h5>
<p>  surfl命令用来画一个带光照模式的三维曲面图，该命令显示一个带阴影的曲面，结合了周围的、散射的和镜面反射的光照模式。想获得较平滑的颜色过渡，则需要使用有线性强度变化的色图（如gray、copper、bone、pink等）。</p>
<img src="/2020/01/09/matlab/5_63.png" class="" title="surlf 命令的调用格式">
<p>  对于这个命令的调用格式需要说明的一点是，参数X, Y, Z确定的点定义了参数曲面的“里面”和“外面”，若用户想曲面的“里面”有光照模式，只要使用surfl(X',Y',Z')即可。</p>
<blockquote>
<p>实例一一三维图形添加光照 <img src="/2020/01/09/matlab/5_64.png" class=""> <img src="/2020/01/09/matlab/5_65.png" class=""></p>
</blockquote>
<h5 id="光源位置及照明模式">光源位置及照明模式</h5>
<p>  在绘制带光照的三维图像时，可以利用light命令与lightangle命令来确定光源位置，其中light命令使用格式非常简单，即为：<br />
  light('color',s1,'style',s2,'position',s3)，其中color、style与position的位置可以互换，s1、s2、s3为相应的可选值。例如，light(’position’,[1 0 0])表示光源从无穷远处沿x轴向原点照射过来。</p>
<img src="/2020/01/09/matlab/5_66.png" class="" title="lightangle 命令的调用格式">
<p>  在确定了光源位置后，用户可能还会用到一些照明模式，这一点可以利用lighting命令来实现，它主要用四种使用格式，即有四种照明模式。</p>
<img src="/2020/01/09/matlab/5_67.png" class="" title="lighting 命令的调用格式">
<blockquote>
<p>实例一一色彩变幻 <img src="/2020/01/09/matlab/5_68.png" class=""> <img src="/2020/01/09/matlab/5_69.png" class=""></p>
</blockquote>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>随机选择算法</title>
    <url>/2019/08/25/randSelect/</url>
    <content><![CDATA[<p>  有这样一个问题：如何从一个无序的数组里求出第<span class="math inline">\(K\)</span>大的数（为了简化讨论，假设数组中的数各不相同），例如，对数组<span class="math inline">\(\{ 5, 12, 7, 2, 9, 3\}\)</span>来说，第三大的数是5，第五大的数是9。</p>
<a id="more"></a>
<p>  最直接的想法就是对数组排一下序，然后直接取出第<span class="math inline">\(K\)</span>大元素即可。但是这样做法需要<span class="math inline">\(O(nlogn)\)</span>的时间复杂度，虽然看起来很好，但还有更优化的算法。下面介绍随机选择算法，它对任何输入都可以达到<span class="math inline">\(O(n)\)</span>的期望时间复杂度。</p>
<p>  随机选择算法的原理类似于随机快速排序算法。可以证明虽然随机选择算法的最坏时间复杂度是<span class="math inline">\(O(n^2)\)</span>，但是其对任意输入的期望时间复杂度却是<span class="math inline">\(O(n)\)</span>，这意味着不存在一组特定的数据能使这个算法出现最坏情况，是个相当实用和出色的算法。</p>
<p>下面以一道OJ题展示一下该算法的核心代码</p>
<p><strong>题目</strong><br />
  给定一个长度为<span class="math inline">\(n(1\leq n\leq 1,000,000)\)</span>的无序正整数序列，以及另一个数<span class="math inline">\(k(1\leq k\leq 1,000,000)\)</span>（关于第<span class="math inline">\(k\)</span>大的数：例如序列<span class="math inline">\(\{ 1, 2, 3, 4, 5, 6\}\)</span>）中第三大的数是4。）</p>
<p><strong>输入</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行两个正整数n, m。</span><br><span class="line">第二行为n个正整数。</span><br></pre></td></tr></table></figure></p>
<p><strong>输出</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第m大的数。</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输入</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输出</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p>
<p><strong>代码</strong> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"algorithm"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cmath"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cstdio"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cstdlib"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ctime"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> A[maxn], n;</span><br><span class="line"><span class="comment">//随机选取主元，对区间[left, right]进行划分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randPartition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//生成[left, right]内的随机数p</span></span><br><span class="line">    <span class="keyword">int</span> p = round(<span class="number">1.0</span> * rand() / RAND_MAX * (right - left) + left);</span><br><span class="line">    <span class="comment">//交换A[p]与A[left]</span></span><br><span class="line">    swap(A[p], A[left]);</span><br><span class="line">    <span class="comment">//以下为不随机选择基准时的划分过程，不需要改变</span></span><br><span class="line">    <span class="comment">//将A[left]存放至临时变量temp</span></span><br><span class="line">    <span class="keyword">int</span> temp = A[left];</span><br><span class="line">    <span class="comment">//只要left与right不相遇</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; A[right] &gt; temp)</span><br><span class="line">            right--;        <span class="comment">//反复左移right</span></span><br><span class="line">        A[left] = A[right]; <span class="comment">//将A[right]挪到A[left]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; A[left] &lt;= temp)</span><br><span class="line">            left++;         <span class="comment">//反复右移left</span></span><br><span class="line">        A[right] = A[left]; <span class="comment">//将A[left]挪到A[right]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把temp放到left和right相遇的地方</span></span><br><span class="line">    A[left] = temp;</span><br><span class="line">    <span class="comment">//返回相遇的下标</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随机选择算法，从A[left, right]中找到第K大的数，进行划分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randSelect</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">return</span> A[left];</span><br><span class="line">    <span class="comment">//划分后主元的位置为p</span></span><br><span class="line">    <span class="keyword">int</span> p = randPartition(A, left, right);</span><br><span class="line">    <span class="comment">//A[p]是A[left, right]中的第M大</span></span><br><span class="line">    <span class="keyword">int</span> M = p - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//找到第K大的数</span></span><br><span class="line">    <span class="keyword">if</span> (K == M) <span class="comment">//找到第K大的数</span></span><br><span class="line">        <span class="keyword">return</span> A[p];</span><br><span class="line">    <span class="keyword">if</span> (K &lt; M) <span class="comment">//第K大数在主元左侧</span></span><br><span class="line">        <span class="keyword">return</span> randSelect(A, left, p - <span class="number">1</span>, K);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//第K大数在主元右侧</span></span><br><span class="line">        <span class="keyword">return</span> randSelect(A, p + <span class="number">1</span>, right, K - M);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果直接填m-1的话找的是第K小的数字</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, randSelect(A, <span class="number">0</span>, n - <span class="number">1</span>, n - m + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2019/01/06/insertion-sort/</url>
    <content><![CDATA[<p>插入排序的平均时间复杂度是<span class="math inline">\(O(n^2)\)</span>,对于少量元素的排序，是个有效的算法</p>
<a id="more"></a>
<p>插入排序的工作方式像许多人排序一手扑克牌。开始时，我们的左手为空并且桌面上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。</p>
<p>插入排序所需的时间取决于输入中元素的初始顺序。例如，对一个很大且其中的元素已经有序（或接近有序）的数组进行排序将会比对随机顺序的数组或逆序数组进行排序要快得多。</p>
<h3 id="伪代码">伪代码</h3>
<p>INSERTION-SORT(A) //对于数组A</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for j &#x3D; 2 to A.length</span><br><span class="line">    key&#x3D;A[i]</span><br><span class="line">    &#x2F;&#x2F;Insert A[j] to the sorted sequence A[1..j-1].</span><br><span class="line">    i &#x3D; j - 1</span><br><span class="line">    while i &gt; 0 and A[i] &gt; key</span><br><span class="line">        A[i+1] &#x3D; A[i]</span><br><span class="line">        i &#x3D; i - 1</span><br><span class="line">    A[i+1] &#x3D; key</span><br></pre></td></tr></table></figure>
<h3 id="简单的实现">简单的实现</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *A;</span><br><span class="line">    <span class="keyword">int</span> length, i, j, key;</span><br><span class="line">    <span class="comment">//输入要排序的数字个数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;length);</span><br><span class="line">    A = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>((length+<span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//输入数字</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= length; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt;= length; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        key = A[j];</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; A[i] &gt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            A[i + <span class="number">1</span>] = A[i];</span><br><span class="line">            i = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        A[i + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= length; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    <span class="built_in">free</span>(A);<span class="comment">//别忘了释放malloc来的空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对插入排序做一些改进我们可以得到一种更高效的排序算法--希尔排序</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>最大子列和</title>
    <url>/2019/03/07/maxsubseqsum/</url>
    <content><![CDATA[<p>最大子列和问题，即给定N个整数的序列<span class="math inline">\(\{A_1,A_2,\ldots,A_N \}\)</span>，求函数<span class="math inline">\(f(i,j)=max\lbrace 0,\sum\limits_{i=0}^n{A_k}\rbrace\)</span>的最大值。 例如<span class="math inline">\(\lbrace-2,11,-4,13,-5,-2\rbrace\)</span>的最大子列和为20，子列为<span class="math inline">\(\lbrace11,-4,13\rbrace\)</span>. <span class="math inline">\(\lbrace-10, 1, 2, 3, 4, -5, -23, 3, 7, -21\rbrace\)</span>的最大子列和为10，子列为<span class="math inline">\(\lbrace1，2，3，4\rbrace\)</span>。 <a id="more"></a> 本文将给出实现这种算法的<span class="math inline">\(\Theta(N^2)\)</span>和<span class="math inline">\(\Theta(N)\)</span>算法</p>
<h2 id="thetan2"><span class="math inline">\(\Theta(N^2)\)</span></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubseqSum</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ThisSum,MaxSum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)    <span class="comment">//i是子列左端位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        ThisSum=<span class="number">0</span>;      <span class="comment">//ThisSum是从A[i]到A[j]的子列和</span></span><br><span class="line">        <span class="keyword">for</span>(j = i; j &lt; N; j++)<span class="comment">//j是子列右端位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            ThisSum += A[j];  <span class="comment">//对于相同的i，不同的j，只要在j-1次循环的基础上累加1项即可</span></span><br><span class="line">            <span class="keyword">if</span>(ThisSum &gt; MaxSum) <span class="comment">//如果刚得到的这个子列和更大</span></span><br><span class="line">                MaxSum = ThisSum; <span class="comment">//则更新结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="thetan"><span class="math inline">\(\Theta(N)\)</span></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubseqSum</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ThisSum, MaxSum;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    ThisSum = MaxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ThisSum += A[i];        <span class="comment">//向右累加</span></span><br><span class="line">        <span class="keyword">if</span>(ThisSum &gt; MaxSum)</span><br><span class="line">            MaxSum = ThisSum;   <span class="comment">//发现更大和则更新当前结果</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ThisSum &lt; <span class="number">0</span>)    <span class="comment">//如果当前子列和为负</span></span><br><span class="line">            ThisSum = <span class="number">0</span>;        <span class="comment">//则不可能使后面的部分和增大，抛弃之</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方法可能不是很好理解，有必要的话可以根据上面的例子手动推演一下。</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>一元多项式的乘法与加法运算</title>
    <url>/2019/03/10/polynomial/</url>
    <content><![CDATA[<p>设计函数分别求两个一元多项式的乘积与和。 <a id="more"></a></p>
<h4 id="输入格式">输入格式</h4>
<p>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p>
<h4 id="输出格式">输出格式</h4>
<p>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出“0 0”。</p>
<h4 id="输入样例">输入样例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3 4 -5 2  6 1  -2 0</span><br><span class="line">3 5 20  -7 4  3 1</span><br></pre></td></tr></table></figure>
<h4 id="输出样例">输出样例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1</span><br><span class="line">5 20 -4 4 -5 2 9 1 -2 0</span><br></pre></td></tr></table></figure>
<h4 id="代码">代码</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NUM</span> * <span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NUM</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> coef;<span class="comment">//系数</span></span><br><span class="line">    <span class="keyword">int</span> expo;<span class="comment">//指数</span></span><br><span class="line">    List next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> coef, <span class="keyword">int</span> expo, List *rear)</span></span>;</span><br><span class="line"><span class="function">List <span class="title">add</span><span class="params">(List quem, List quen)</span></span>;</span><br><span class="line"><span class="function">List <span class="title">mul</span><span class="params">(List quem, List quen)</span></span>;</span><br><span class="line"><span class="function">List <span class="title">insertSortandMerge</span><span class="params">(List front)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(List res)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n,coef,expo;</span><br><span class="line">    List quem, quen, resadd, resmul;</span><br><span class="line">    List rearm = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM)), rearn = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM));</span><br><span class="line">    rearm-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    rearn-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    quem = rearm;</span><br><span class="line">    quen = rearn;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;coef, &amp;expo);</span><br><span class="line">        addNode(coef, expo, &amp;rearm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;coef, &amp;expo);</span><br><span class="line">        addNode(coef, expo, &amp;rearn);</span><br><span class="line">    &#125;</span><br><span class="line">    resadd = add(quem-&gt;next, quen-&gt;next);</span><br><span class="line">    resmul = mul(quem-&gt;next, quen-&gt;next);</span><br><span class="line">    Print(resmul);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    Print(resadd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> coef, <span class="keyword">int</span> expo, List *rear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//由于在本函数中需要改变当前结果表达式尾项指针的值</span></span><br><span class="line">    <span class="comment">//所以函数传递进来的是尾项结点指针的地址，*rear指向尾项</span></span><br><span class="line">    List P = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM));<span class="comment">//申请新节点并赋值</span></span><br><span class="line">    P-&gt;coef = coef;</span><br><span class="line">    P-&gt;expo = expo;</span><br><span class="line">    P-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将P指向的新节点插入到当前结果表达式尾项的后面</span></span><br><span class="line">    (*rear)-&gt;next = P;</span><br><span class="line">    *rear = (*rear)-&gt;next;<span class="comment">//修改rear值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">List <span class="title">add</span><span class="params">(List quem, List quen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List front, rear, temp;<span class="comment">//为方便表头插入，先产生一个临时空结点作为结果多项式链表头</span></span><br><span class="line">    rear = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM));</span><br><span class="line">    front = rear;<span class="comment">//由front记录结果多项式链表头结点</span></span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">while</span> (quem&amp;&amp;quen)<span class="comment">//当两个多项式都有非零项待处理时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (quem-&gt;expo == quen-&gt;expo)<span class="comment">//两数据项指数相等</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum = quem-&gt;coef + quen-&gt;coef;</span><br><span class="line">            <span class="keyword">if</span> (sum)</span><br><span class="line">                addNode(sum, quem-&gt;expo, &amp;rear);</span><br><span class="line">            quem = quem-&gt;next;</span><br><span class="line">            quen = quen-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (quem-&gt;expo &lt; quen-&gt;expo)<span class="comment">//quen中的数据项指数较大</span></span><br><span class="line">        &#123;</span><br><span class="line">            addNode(quen-&gt;coef, quen-&gt;expo, &amp;rear);</span><br><span class="line">            quen = quen-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (quem-&gt;expo &gt; quen-&gt;expo)<span class="comment">//quem中的数据项指数较大</span></span><br><span class="line">        &#123;</span><br><span class="line">            addNode(quem-&gt;coef, quem-&gt;expo, &amp;rear);</span><br><span class="line">            quem = quem-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将未处理完的另一个多项式的所有结点依次复制到结果多项式中去</span></span><br><span class="line">    <span class="keyword">while</span> (quem)</span><br><span class="line">    &#123;</span><br><span class="line">        addNode(quem-&gt;coef, quem-&gt;expo, &amp;rear);</span><br><span class="line">        quem = quem-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (quen)</span><br><span class="line">    &#123;</span><br><span class="line">        addNode(quen-&gt;coef, quen-&gt;expo, &amp;rear);</span><br><span class="line">        quen = quen-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    rear-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    temp = front;</span><br><span class="line">    front = front-&gt;next;<span class="comment">//令front指向结果多项式第一个非零项</span></span><br><span class="line">    <span class="built_in">free</span>(temp);<span class="comment">//释放临时空表头结点</span></span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">List <span class="title">mul</span><span class="params">(List quem, List quen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List front, rear, temp, Fquem;<span class="comment">//Fquem保存quem的位置</span></span><br><span class="line">    <span class="keyword">int</span> sum, mul;</span><br><span class="line">    rear = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM));</span><br><span class="line">    front = rear;</span><br><span class="line">    Fquem = quem;</span><br><span class="line">    <span class="keyword">while</span> (quen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (quem)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = (quem-&gt;coef) * (quen-&gt;coef);</span><br><span class="line">            mul = (quem-&gt;expo) + (quen-&gt;expo);</span><br><span class="line">            addNode(sum, mul, &amp;rear);</span><br><span class="line">            quem = quem-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        quem = Fquem;<span class="comment">//重置quem</span></span><br><span class="line">        quen = quen-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    rear-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    temp = front;</span><br><span class="line">    front = front-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    front = insertSortandMerge(front);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">List <span class="title">insertSortandMerge</span><span class="params">(List front)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//处理多项式乘法的结果</span></span><br><span class="line">    <span class="comment">/*按指数从大到小进行插入排序，第二个循环中顺便将要插入的项与之前排好序的“队列”中指数相同的项进行合并*/</span></span><br><span class="line">    List head, temp, front_to_free = front;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    head = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (front == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;coef = front-&gt;coef;</span><br><span class="line">        head-&gt;expo = front-&gt;expo;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (front)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (front-&gt;expo == temp-&gt;next-&gt;expo)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = temp-&gt;next-&gt;coef + front-&gt;coef;</span><br><span class="line">                <span class="keyword">if</span> (sum)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp-&gt;next-&gt;coef = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                front = front-&gt;next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (front-&gt;expo &gt; head-&gt;expo)</span><br><span class="line">            &#123;</span><br><span class="line">                List t = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM));</span><br><span class="line">                t-&gt;coef = front-&gt;coef;</span><br><span class="line">                t-&gt;expo = front-&gt;expo;</span><br><span class="line">                t-&gt;next = head;</span><br><span class="line">                head = t;</span><br><span class="line">                front = front-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(t);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (front-&gt;expo &lt; temp-&gt;expo &amp;&amp; front-&gt;expo&gt;temp-&gt;next-&gt;expo)</span><br><span class="line">            &#123;</span><br><span class="line">                List t = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM));</span><br><span class="line">                t-&gt;coef = front-&gt;coef;</span><br><span class="line">                t-&gt;expo = front-&gt;expo;</span><br><span class="line">                t-&gt;next = temp-&gt;next;</span><br><span class="line">                temp-&gt;next = t;</span><br><span class="line">                front = front-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(t);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            addNode(front-&gt;coef, front-&gt;expo, &amp;temp);</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(front_to_free);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(List res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输出操作，首先特判一下</span></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0 0"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">while</span> (res)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, res-&gt;coef, res-&gt;expo);</span><br><span class="line">        <span class="keyword">if</span> (res-&gt;next)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试点信息">测试点信息</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试点    提示</span><br><span class="line">0        sample换个数字</span><br><span class="line">1        同类项合并时有抵消</span><br><span class="line">2        系数和指数取上限，结果有零多项式</span><br><span class="line">3        输入有零多项式和常数多项式</span><br></pre></td></tr></table></figure>
<p><del>什么都不想说，因为写了六个小时，太累了。</del></p>
<p>好吧，时隔一个星期，我又回来补上了一部分注释。</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>修改文章底部标签图形</title>
    <url>/2019/09/27/%E4%BF%AE%E6%94%B9%E6%96%87%E7%AB%A0%E5%BA%95%E9%83%A8%E6%A0%87%E7%AD%BE%E5%9B%BE%E5%BD%A2/</url>
    <content><![CDATA[<p>可能有人会觉得自带的<code>#</code>标签比较丑，那么可以考虑更改<code>themes\next\layout\_macro\post.swig</code>来更换一个图标</p>
<a id="more"></a>
<img src="/2019/09/27/%E4%BF%AE%E6%94%B9%E6%96%87%E7%AB%A0%E5%BA%95%E9%83%A8%E6%A0%87%E7%AD%BE%E5%9B%BE%E5%BD%A2/tags_before.png" class="" title="更改前">
<img src="/2019/09/27/%E4%BF%AE%E6%94%B9%E6%96%87%E7%AB%A0%E5%BA%95%E9%83%A8%E6%A0%87%E7%AD%BE%E5%9B%BE%E5%BD%A2/tags_after.png" class="" title="更改后">
<p>在<code>post.swig</code>文件中搜索<code>tag_indicate</code>找到<code>set tag_indicate = '#'</code>,将其改成<code>set tag_indicate = '&lt;i class="fa fa-tag"&gt;&lt;/i&gt;'</code>。</p>
<p>更好的方法：可以直接在主题目录下的<code>_config.yml</code>中搜索<code>tag_icon</code>将其值改为true</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2019/01/13/selection-sort/</url>
    <content><![CDATA[<p>选择排序是一种很容易理解和实现的简单排序算法。<br />
<a id="more"></a><br />
首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。因为它在不断地选择剩余元素之中的最小者，所以这种方法叫选择排序。</p>
<p>它有两个很鲜明的特点：<br />
　　运行时间与输入无关。为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息。这种性质在某些情况下是缺点，因为使用选择排序的人可能会惊讶的发现，一个已经有序的数组或是主键全部相等的数组和一个元素随机排列的数组所用的排序时间竟然一样长！我们将会看到，其它算法会更善于利用输入的初始状态。<br />
　　数据移动是最少的。每次交换都会改变两个数组元素的值，因此选择排序用了Ｎ次交换——交换次数和数组大小是线性关系。其它的任何算法都不具备这个特征（大部分的增长数量级都是线性对数或平方级别）</p>
<p>简单的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *A;</span><br><span class="line">    <span class="keyword">int</span> length, i, j, t, <span class="built_in">min</span>, key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入要排序的数字个数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;length);</span><br><span class="line">    A = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(length * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//输入数字</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">min</span> = A[i];</span><br><span class="line">        key = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; <span class="built_in">min</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">min</span> = A[j];</span><br><span class="line">                key = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t = A[i];</span><br><span class="line">        A[i] = <span class="built_in">min</span>;</span><br><span class="line">        A[key] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    <span class="built_in">free</span>(A);<span class="comment">//别忘了释放malloc来的空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>Root Of AVL Tree</title>
    <url>/2019/03/23/root-of-AVL-tree/</url>
    <content><![CDATA[<p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. <a id="more"></a> Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.</p>
<h4 id="input-specification">Input Specification</h4>
<p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤20) which is the total number of keys to be inserted. Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p>
<h4 id="output-specification">Output Specification</h4>
<p>For each test case, print the root of the resulting AVL tree in one line.</p>
<h4 id="sample-input-1">Sample Input 1</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">88 70 61 96 120</span><br></pre></td></tr></table></figure>
<h4 id="sample-output-1">Sample Output 1</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">70</span><br></pre></td></tr></table></figure>
<h4 id="sample-input-2">Sample Input 2</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">88 70 61 96 120 90 65</span><br></pre></td></tr></table></figure>
<h4 id="sample-output-2">Sample Output 2</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">88</span><br></pre></td></tr></table></figure>
<h4 id="代码">代码</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> * <span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position AVLTree;   <span class="comment">//AVL树类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> &#123;</span></span><br><span class="line">    ElementType Data;   <span class="comment">//结点数据</span></span><br><span class="line">    AVLTree Left;   <span class="comment">//指向左子树</span></span><br><span class="line">    AVLTree Right;  <span class="comment">//指向右子树</span></span><br><span class="line">    <span class="keyword">int</span> Height; <span class="comment">//树高</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function">AVLTree <span class="title">Insert</span><span class="params">(AVLTree T, ElementType X)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHeight</span><span class="params">(AVLTree T)</span></span>;</span><br><span class="line"><span class="function">AVLTree <span class="title">SingleLeftRotation</span><span class="params">(AVLTree A)</span></span>;</span><br><span class="line"><span class="function">AVLTree <span class="title">SingleRightRotation</span><span class="params">(AVLTree A)</span></span>;</span><br><span class="line"><span class="function">AVLTree <span class="title">DoubleLeftRightRotation</span><span class="params">(AVLTree A)</span></span>;</span><br><span class="line"><span class="function">AVLTree <span class="title">DoubleRightLeftRotation</span><span class="params">(AVLTree A)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, num;</span><br><span class="line">    AVLTree T = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line">        T = Insert(T, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, T-&gt;Data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AVLTree <span class="title">Insert</span><span class="params">(AVLTree T, ElementType X)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//将X插入AVL树中，并且返回调整后的AVL树</span></span><br><span class="line">    <span class="keyword">if</span> (!T)<span class="comment">//若插入空树，则新建包含一个结点的树</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = (AVLTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct AVLNode));</span><br><span class="line">        T-&gt;Data = X;</span><br><span class="line">        T-&gt;Height = <span class="number">1</span>;</span><br><span class="line">        T-&gt;Left = T-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; T-&gt;Data)</span><br><span class="line">    &#123;<span class="comment">//插入左子树</span></span><br><span class="line">        T-&gt;Left = Insert(T-&gt;Left, X);</span><br><span class="line">        <span class="comment">//如果需要左旋</span></span><br><span class="line">        <span class="keyword">if</span> (GetHeight(T-&gt;Left) - GetHeight(T-&gt;Right) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (X &lt; T-&gt;Left-&gt;Data)</span><br><span class="line">                T = SingleLeftRotation(T);  <span class="comment">//左单旋</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T = DoubleLeftRightRotation(T); <span class="comment">//左-右双旋</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; T-&gt;Data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//插入右子树</span></span><br><span class="line">        T-&gt;Right = Insert(T-&gt;Right, X);</span><br><span class="line">        <span class="comment">//如果需要右旋</span></span><br><span class="line">        <span class="keyword">if</span> (GetHeight(T-&gt;Right) - GetHeight(T-&gt;Left) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (X &gt; T-&gt;Right-&gt;Data)</span><br><span class="line">                T = SingleRightRotation(T); <span class="comment">//右单旋</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T = DoubleRightLeftRotation(T); <span class="comment">//右-左双旋</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//else X==T-&gt;Data,无需插入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//别忘了更新树高</span></span><br><span class="line">    T-&gt;Height = Max(GetHeight(T-&gt;Left), GetHeight(T-&gt;Right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHeight</span><span class="params">(AVLTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T)</span><br><span class="line">        <span class="keyword">return</span> T-&gt;Height;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AVLTree <span class="title">SingleLeftRotation</span><span class="params">(AVLTree A)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//注意：A必须有一个左子结点B</span></span><br><span class="line">    <span class="comment">//将A与B做左单旋，更新A与B的高度，返回新的根节点B</span></span><br><span class="line">    AVLTree B = A-&gt;Left;</span><br><span class="line">    A-&gt;Left = B-&gt;Right;</span><br><span class="line">    B-&gt;Right = A;</span><br><span class="line">    A-&gt;Height = Max(GetHeight(A-&gt;Left), GetHeight(A-&gt;Right)) + <span class="number">1</span>;</span><br><span class="line">    B-&gt;Height = Max(GetHeight(B-&gt;Left), A-&gt;Height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AVLTree <span class="title">SingleRightRotation</span><span class="params">(AVLTree A)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//注意：A必须有一个右子结点B</span></span><br><span class="line">    <span class="comment">//将A与B做右单旋，更新A与B的高度，返回新的根节点B</span></span><br><span class="line">    AVLTree B = A-&gt;Right;</span><br><span class="line">    A-&gt;Right = B-&gt;Left;</span><br><span class="line">    B-&gt;Left = A;</span><br><span class="line">    A-&gt;Height = Max(GetHeight(A-&gt;Left), GetHeight(A-&gt;Right)) + <span class="number">1</span>;</span><br><span class="line">    B-&gt;Height = Max(GetHeight(B-&gt;Right), A-&gt;Height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AVLTree <span class="title">DoubleLeftRightRotation</span><span class="params">(AVLTree A)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//注意：A必须有一个左子结点B，且B必须有一个右子节点C</span></span><br><span class="line">    <span class="comment">//将A、B与C做两次单旋，返回新的根节点C</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//B与C做右单旋，返回C</span></span><br><span class="line">    A-&gt;Left = SingleRightRotation(A-&gt;Left);</span><br><span class="line">    <span class="comment">//A与C做左单旋，返回C</span></span><br><span class="line">    <span class="keyword">return</span> SingleLeftRotation(A);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AVLTree <span class="title">DoubleRightLeftRotation</span><span class="params">(AVLTree A)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//注意：A必须有一个右子结点B，且B必须有一个左子节点C</span></span><br><span class="line">    <span class="comment">//将A、B与C做两次单旋，返回新的根节点C</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//B与C做左单旋，返回C</span></span><br><span class="line">    A-&gt;Right = SingleLeftRotation(A-&gt;Right);</span><br><span class="line">    <span class="comment">//A与C做右单旋，返回C</span></span><br><span class="line">    <span class="keyword">return</span> SingleRightRotation(A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试点">测试点</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试点      提示</span><br><span class="line">0           fig 1 - LL</span><br><span class="line">1           fig 2 - RR</span><br><span class="line">2           fig 3 - RL</span><br><span class="line">3           fig 4 - LR</span><br><span class="line">4           深度LL旋转</span><br><span class="line">5           最大N，深度RL旋转</span><br><span class="line">6           最小N</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>八种常用排序算法总结</title>
    <url>/2019/07/06/%E5%85%AB%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>交换排序（冒泡排序，快速排序），插入排序（直接插入排序，希尔排序），选择排序（简单选择排序，堆排序），归并排序，基数排序</p>
<a id="more"></a>
<h2 id="冒泡排序bubble-sort">冒泡排序(Bubble Sort)</h2>
<p>冒泡排序步骤：</p>
<ol type="1">
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 冒泡排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 控制共比较多少轮</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 控制比较的次数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序quick-sort">快速排序(Quick Sort)</h2>
<p>  快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。</p>
<p>快速排序步骤</p>
<ol type="1">
<li>挑选基准值：从数列中挑出一个元素，称为“基准”（pivot）</li>
<li>分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成，</li>
<li>递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序</li>
</ol>
<p>  递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//快速排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="comment">// 把第0个数作为基准值</span></span><br><span class="line">            <span class="keyword">int</span> pivot = arr[start];</span><br><span class="line">            <span class="comment">// 记录需要排序的下标</span></span><br><span class="line">            <span class="keyword">int</span> low = start;</span><br><span class="line">            <span class="keyword">int</span> high = end;</span><br><span class="line">            <span class="comment">// 循环找比基准值大的数和比基准值小的数</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">                <span class="comment">// 右边的数字比基准值大</span></span><br><span class="line">                <span class="keyword">while</span> (low &lt; high &amp;&amp; pivot &lt;= arr[high]) &#123;</span><br><span class="line">                    high--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 使用右边的数字替换左边的数</span></span><br><span class="line">                arr[low] = arr[high];</span><br><span class="line">                <span class="comment">// 如果左边的数字比基准值小</span></span><br><span class="line">                <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;</span><br><span class="line">                    low++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 使用左边的数字替换右边的数</span></span><br><span class="line">                arr[high] = arr[low];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把基准值赋给低（或高）的那一边（这里low==high，所以都一样）</span></span><br><span class="line">            arr[low] = pivot;</span><br><span class="line">            <span class="comment">// 处理所有小的数字</span></span><br><span class="line">            quickSort(arr, start, low);</span><br><span class="line">            <span class="comment">// 处理所有大的数字</span></span><br><span class="line">            quickSort(arr, low + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序insert-sort">插入排序(Insert Sort)</h2>
<p>  插入排序原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。举个例子来说：插入排序的工作方式像许多人排序一手扑克牌。开始时，我们的左手为空并且桌面上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。</p>
<p>  插入排序所需的时间取决于输入中元素的初始顺序。例如，对一个很大且其中的元素已经有序（或接近有序）的数组进行排序将会比对随机顺序的数组或逆序数组进行排序要快得多。</p>
<p>插入排序步骤：</p>
<ol type="1">
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历所有数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 把当前遍历数字存起来</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果当前数字比temp大，就一直往前直到找到合适位置</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">                <span class="comment">// 把前一个数字赋给后一个数字</span></span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把临时变量赋给不满足条件的后一个值</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序shell-sort">希尔排序(Shell Sort)</h2>
<p>  希尔排序是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p>
<p>  希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ul>
<p>  希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//希尔排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历所有的步长</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = arr.length / <span class="number">2</span>; d &gt; <span class="number">0</span>; d /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历所有的元素</span></span><br><span class="line">            <span class="comment">//下面这个for循环取d=1和插入排序一样</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = d; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                <span class="keyword">int</span> j = i - d;</span><br><span class="line">                <span class="comment">// 遍历本组中所有的元素</span></span><br><span class="line">                <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前元素大于加上步长后的那个元素</span></span><br><span class="line">                    arr[j + d] = arr[j];</span><br><span class="line">                    j -= d;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j + d] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序selection-sort">选择排序(Selection Sort)</h2>
<p>  选择排序是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p>它有两个很鲜明的特点：<br />
　　运行时间与输入无关。为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息。这种性质在某些情况下是缺点，因为使用选择排序的人可能会惊讶的发现，一个已经有序的数组或是主键全部相等的数组和一个元素随机排列的数组所用的排序时间竟然一样长！相比之下，其它算法会更善于利用输入的初始状态。<br />
　　数据移动是最少的。每次交换都会改变两个数组元素的值，因此选择排序用了<span class="math inline">\(N\)</span>次交换——交换次数和数组大小是线性关系。其它的任何算法都不具备这个特征（大部分的增长数量级都是线性对数或平方级别）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 选择排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历所有的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 这里是记录最小数下标，也可以记录最小的数</span></span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="comment">// 把当前遍历的数和后面所有的数依次进行比较，并记录下最小的数的下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果后面比较的数比记录最小的数小</span></span><br><span class="line">                <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                    <span class="comment">// 记录下最小的那个数的下标</span></span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果最小的数和当前遍历的数的下标不一致,说明下标为minIndex的数比当前遍历的数更小</span></span><br><span class="line">            <span class="keyword">if</span> (i != minIndex) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[minIndex];</span><br><span class="line">                arr[minIndex] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序heap-sort">堆排序(Heap Sort)</h2>
<p>  堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p>
<p>通常堆是通过一维数组来实现的。在数组起始位置为0的情形中：</p>
<ul>
<li>父节点i的左子节点在位置<span class="math inline">\((2i+1)\)</span></li>
<li>父节点i的右子节点在位置<span class="math inline">\((2i+2)\)</span></li>
<li>子节点i的父节点在位置<span class="math inline">\(((i-1)/2)\)</span></li>
</ul>
<p>  堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余<span class="math inline">\(n-1\)</span>个元素重新构造成一个堆，这样会得到<span class="math inline">\(n\)</span>个元素的次小值。如此反复执行，便能得到一个有序序列了</p>
<p>堆排序的步骤</p>
<ol type="1">
<li>构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</li>
<li>将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//堆排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 开始位置是最后一个非叶子节点，即最后一个节点的父节点</span></span><br><span class="line">        <span class="keyword">int</span> start = (arr.length - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 调整大顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxHeap(arr, arr.length, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先把数组中第0个和堆中最后一个数交换位置，在把前面的处理为大顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            maxHeap(arr, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调整为大顶堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> size, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左子节点</span></span><br><span class="line">        <span class="keyword">int</span> leftNode = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 右子节点</span></span><br><span class="line">        <span class="keyword">int</span> rightNode = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> max = index;</span><br><span class="line">        <span class="comment">// 和两个子节点分别对比，找出最大的节点</span></span><br><span class="line">        <span class="keyword">if</span> (leftNode &lt; size &amp;&amp; arr[leftNode] &gt; arr[max]) &#123;</span><br><span class="line">            max = leftNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightNode &lt; size &amp;&amp; arr[rightNode] &gt; arr[max]) &#123;</span><br><span class="line">            max = rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换位置</span></span><br><span class="line">        <span class="keyword">if</span> (max != index) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[index];</span><br><span class="line">            arr[index] = arr[max];</span><br><span class="line">            arr[max] = temp;</span><br><span class="line">            <span class="comment">// 交换位置后可能破坏之前排好的堆，需要重新调整</span></span><br><span class="line">            maxHeap(arr, size, max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序merge-sort">归并排序(Merge Sort)</h2>
<p>  归并排序是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p>
<p>  归并排序的基本思路是将数组分成二组<span class="math inline">\(A，B\)</span>，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。要让<span class="math inline">\(A，B\)</span>两组内部数据有序，可以再将<span class="math inline">\(A，B\)</span>组各自分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数组，再合并数组就完成了归并排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//归并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="comment">// 处理左边</span></span><br><span class="line">            mergesort(arr, low, mid);</span><br><span class="line">            <span class="comment">// 处理右边</span></span><br><span class="line">            mergesort(arr, mid + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于存储归并后的临时数组</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 记录第一个数组中需要遍历的下标</span></span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="comment">// 记录第二个数组中需要遍历的下标</span></span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 用于记录在临时数组中存放的下标</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历两个数组，取出小的数字，放入临时数组中</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">            <span class="comment">// 如果第一个数组的数据更小</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 把小的数据放入临时数组中</span></span><br><span class="line">                temp[index] = arr[i];</span><br><span class="line">                <span class="comment">// 让下标向后移一位</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[index] = arr[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理多余的数据</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">            temp[index] = arr[j];</span><br><span class="line">            j++;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[index] = arr[i];</span><br><span class="line">            i++;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把临时数组中数据重新存入原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; temp.length; k++) &#123;</span><br><span class="line">            arr[k + low] = temp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基数排序radix-sort">基数排序(Radix Sort)</h2>
<p>  基数排序是一种非比较型整数排序算法，其原理是将所有待比较数值（正整数）统一为同样的数字长度，数字较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//基数排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixsort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存数组中最大的数字</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求最大数字的位数</span></span><br><span class="line">        <span class="keyword">int</span> maxlength = (max + <span class="string">""</span>).length();</span><br><span class="line">        <span class="comment">// 用于临时存储数据的数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">        <span class="comment">// 用于记录在temp中相应数组存放的数字数量；</span></span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">// 根据最大长度的数决定比较的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = <span class="number">1</span>; i &lt; maxlength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 把每一个数字分别计算余数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 计算余数</span></span><br><span class="line">                <span class="keyword">int</span> ys = arr[j] / n % <span class="number">10</span>;</span><br><span class="line">                <span class="comment">// 把当前遍历的数据放入指定的数组中</span></span><br><span class="line">                temp[ys][counts[ys]] = arr[j];</span><br><span class="line">                <span class="comment">// 记录数量</span></span><br><span class="line">                counts[ys]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录取的元素需要放的位置</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 把数字取出来</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; counts.length; k++) &#123;</span><br><span class="line">                <span class="comment">// 记录数量数组中当前余数记录的数量不为0</span></span><br><span class="line">                <span class="keyword">if</span> (counts[k] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 循环取出元素</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; counts[k]; l++) &#123;</span><br><span class="line">                        <span class="comment">// 取出元素</span></span><br><span class="line">                        arr[index] = temp[k][l];</span><br><span class="line">                        <span class="comment">// 记录下一个位置</span></span><br><span class="line">                        index++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 把数量置为0</span></span><br><span class="line">                    counts[k] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>矩阵乘法的Strassen算法</title>
    <url>/2019/02/02/strassen/</url>
    <content><![CDATA[<p>  最简单的矩阵乘法可以通过三重循环来实现，其时间复杂度为<span class="math inline">\(\Theta(n^{3})\)</span>，Strassen算法通过巧妙的增加加法来减少乘法实现了<span class="math inline">\(O(n^{2.81})\)</span>的时间复杂度</p>
<a id="more"></a>
<p>Strassen算法的四个步骤：</p>
<ol type="1">
<li>将输入矩阵A、B与输出矩阵C分解为<span class="math inline">\(n/2\times n/2\)</span>的子矩阵，采用下标计算方法，此步骤花费<span class="math inline">\(\Theta\)</span>(1)时间。<br />
</li>
<li>创建10个<span class="math inline">\(n/2\times n/2\)</span>的矩阵，每个矩阵保存步骤1中创建的两个子矩阵的和或差，花费<span class="math inline">\(\Theta(n^2)\)</span>。<br />
</li>
<li>用步骤1中创建的子矩阵和步骤2中创建的10个矩阵，递归的计算7个<span class="math inline">\(P_i\)</span>矩阵积。<br />
</li>
<li>通过<span class="math inline">\(P_i\)</span>矩阵的不同组合进行加减运算，计算出C的子矩阵，花费时间<span class="math inline">\(\Theta(n^2)\)</span>。</li>
</ol>
<p>  为了方便计算矩阵积C=A<span class="math inline">\(\cdot\)</span>B，假定三个矩阵均为<span class="math inline">\(n\times n\)</span>矩阵，其中n为2的幂。做出这个假设是因为在每个分解步骤中，<span class="math inline">\(n\times n\)</span>矩阵都被划分为4个<span class="math inline">\(n/2\times n/2\)</span>的子矩阵，如果假定<span class="math inline">\(n\)</span>是2的幂，则只要<span class="math inline">\(n\geq 2\)</span>即可保证子矩阵规模<span class="math inline">\(n/2\)</span>为整数。</p>
<p>假定将A、B和C均分解为4个<span class="math inline">\(n/2\times n/2\)</span>的子矩阵：</p>
<p><span class="math display">\[A=
 \left[
 \begin{matrix}
   A_{11} &amp; A_{12} \\
   A_{21} &amp; A_{22} \\
  \end{matrix}
  \right]
，B=
 \left[
 \begin{matrix}
   B_{11} &amp; B_{12} \\
   B_{21} &amp; B_{22} \\
  \end{matrix}
  \right]
，C=
 \left[
 \begin{matrix}
   C_{11} &amp; C_{12} \\
   C_{21} &amp; C_{22} \\
  \end{matrix}
  \right]
\]</span> 根据矩阵乘法的定义，可以得到如下4个公式： <span class="math display">\[
\begin{equation}\label{1}
\begin{aligned}
C_{11}&amp;=A_{11}\cdot B_{11}+A_{12}\cdot B_{21} \\
C_{12}&amp;=A_{11}\cdot B_{12}+A_{12}\cdot B_{22} \\
C_{21}&amp;=A_{21}\cdot B_{11}+A_{22}\cdot B_{21} \\
C_{22}&amp;=A_{21}\cdot B_{12}+A_{22}\cdot B_{22} \\
\end{aligned}
\end{equation}
\]</span></p>
<p>步骤2中，创建如下10个矩阵： <span class="math display">\[
\begin{equation}\label{2}
\begin{aligned}
S_1&amp;=B_{12}-B_{22}\\
S_2&amp;=A_{11}-A_{12}\\
S_3&amp;=A_{21}+A_{22}\\
S_4&amp;=B_{21}-B_{21}\\
S_5&amp;=A_{11}+A_{22}\\
S_6&amp;=B_{11}+B_{22}\\
S_7&amp;=A_{12}-A_{22}\\
S_8&amp;=B_{21}+B_{22}\\
S_9&amp;=A_{11}-A_{21}\\
S_{10}&amp;=B_{11}+B_{12}\\
\end{aligned}
\end{equation}
\]</span> 由于必须进行10次<span class="math inline">\(n/2\times n/2\)</span>矩阵的加减法，因此，该步骤花费<span class="math inline">\(\Theta(n^2)\)</span>时间。 步骤3中，递归的计算7次<span class="math inline">\(n/2\times n/2\)</span>矩阵的乘法，如下所示： <span class="math display">\[
\begin{align*}
P_1&amp;=A_{11}\cdot S_1\\
P_2&amp;=S_2\cdot B_{22}\\
P_3&amp;=S_3\cdot B_{11}\\
P_4&amp;=A_{22}\cdot S_4\\
P_5&amp;=S_5\cdot S_6\\
P_6&amp;=S_7\cdot S_8\\
P_7&amp;=S_9\cdot S_{10}\\
\end{align*}
\]</span> 步骤4中， <span class="math display">\[
\begin{align*}
C_{11}&amp;=P_5+P_4-P_2+P_6\\
C_{12}&amp;=P_1+P_2\\
C_{21}&amp;=P_3+P_4\\
C_{22}&amp;=P_5+P_1-P_3-P_7\\
\end{align*}
\]</span> 共进行了8次<span class="math inline">\(n/2\times n/2\)</span>矩阵的加减法，因此花费<span class="math inline">\(\Theta(n^2)\)</span>时间。 代值计算后可以发现(2)式结果与(1)式是相同的。</p>
<p>描述Strassen算法运行时间T(n)的递归式： <span class="math display">\[T(n)=\begin{cases}
\Theta(1)&amp;n=1\\
7T(n/2)+\Theta(n^2)&amp;n&gt;1\\
\end{cases}\]</span></p>
<p>  用主方法来求解这个递归式，可知解为<span class="math inline">\(T\left(n\right)=\Theta(n^{lg7})\)</span>，由于<span class="math inline">\(lg7\)</span>介于2.80和2.81之间，所以时间复杂度为<span class="math inline">\(O(n^{2.81})\)</span>。</p>
<p>天知道Strassen是怎么想到这个方法的QAQ</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>快速幂取模</title>
    <url>/2020/07/07/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%8F%96%E6%A8%A1/</url>
    <content><![CDATA[<p>现在让我们来计算<span class="math inline">\(a^b\%c\)</span> <a id="more"></a></p>
<h2 id="最简单的想法">最简单的想法</h2>
<p>将<span class="math inline">\(a\)</span>累计乘上<span class="math inline">\(b\)</span>次再对<span class="math inline">\(c\)</span>取模即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b--)</span><br><span class="line">        ans = ans * a;</span><br><span class="line">    ans = ans % c;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上去没有问题，但是当<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>的值很大时，就算是long long类型也有可能让累乘的结果溢出，而且在做乘法时一共要进行<span class="math inline">\(b\)</span>次运算，时间上的代价也很大，那么是否能从这两方面进行优化呢？</p>
<h2 id="快速幂">快速幂</h2>
<p>快速幂是一个计算<span class="math inline">\(a^b\)</span>的小技巧，它的时间复杂度为<span class="math inline">\(\Theta \left( \log n \right)\)</span>，从一个简单的例子开始：</p>
<p>现在你要计算<span class="math inline">\(62^9\)</span>这个数，假设你手上有个只能加减乘除的计算器，想必你肯定不会真的把<span class="math inline">\(62\)</span>这个数乘上<span class="math inline">\(9\)</span>次，因为这实在太慢了，我们会先计算<span class="math inline">\(62^4\)</span>的值，将其与自身相乘后再乘上一个<span class="math inline">\(62\)</span>就得到了结果，将这个规则递归下去，可以得到下面这样的流程</p>
<p><span class="math display">\[
62^9=\left( 62^4 \right) ^2*62=\left( \left( 62^2 \right) ^2 \right) ^2*62
\]</span></p>
<p>原本要进行9次乘法，现在只需要进行4次，幂越大时，效果越明显。</p>
<h3 id="递归实现">递归实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="built_in">pow</span>(a, b / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans * ans * a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ans * ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归实现">非递归实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取模">取模</h2>
<p>首先引入几个数学公式 <span class="math display">\[
\begin{align}
\left( a+b \right) \%c=\left[ \left( a\%c \right) +\left( b\%c \right) \right] \%c
\\
\left( a-b \right) \%c=\left[ \left( a\%c \right) -\left( b\%c \right) \right] \%c
\\
\left( a*b \right) \%c=\left[ \left( a\%c \right) *\left( b\%c \right) \right] \%c
\end{align}
\]</span></p>
<p>我们需要用到上面的第$( 3 ) $式，下面给出证明：</p>
<p><span class="math display">\[
\begin{align*}
a\%c &amp; =d\Rightarrow a=tc+d\\
b\%c &amp; =e\Rightarrow b=kc+e\\
ab\%c &amp; =\left( tc+d \right) \left( kc+e \right) \%c\\
&amp; =\left( tkc^2+\left( te+dk \right) c+de \right) \%c\\
&amp; =de\%c=\left[ \left( a\%c \right) *\left( b\%c \right) \right] \%c
\end{align*}
\]</span></p>
<p>根据这个公式，可以知道</p>
<p><span class="math display">\[
a^b\%c=\left( a\%c \right) ^b\%c
\]</span></p>
<h2 id="最终结果">最终结果</h2>
<p>根据以上结论，我们可以在循环乘积的过程中加入取模运算，这样就可以避免最终结果过大的情况，再结合之前的快速幂技巧，就可以得到最终的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a %= c;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = (ans * a) % c;</span><br><span class="line">        a = (a * a) % c;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>堆中的路径</title>
    <url>/2019/03/30/%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>将一系列给定数字插入一个初始为空的小顶堆<code>H[]</code>。随后对任意给定的下标<code>i</code>，打印从<code>H[i]</code>到根结点的路径。 <a id="more"></a></p>
<h4 id="输入格式">输入格式</h4>
<p>每组测试第1行包含2个正整数N和M(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的N个要被插入一个初始为空的小顶堆的整数。最后一行给出M个下标。</p>
<h4 id="输出格式">输出格式</h4>
<p>对输入中给出的每个下标<code>i</code>，在一行中输出从<code>H[i]</code>到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。</p>
<h4 id="输入样例">输入样例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">46 23 26 24 10</span><br><span class="line">5 4 3</span><br></pre></td></tr></table></figure>
<h4 id="输出样例">输出样例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">24 23 10</span><br><span class="line">46 23 10</span><br><span class="line">26 10</span><br></pre></td></tr></table></figure>
<h4 id="代码">代码</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINH -10001</span></span><br><span class="line"><span class="keyword">int</span> H[MAXN], <span class="built_in">size</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> X)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, x, i, j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    Create();<span class="comment">//堆初始化</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;<span class="comment">//以逐个插入方式建堆</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        Insert(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;j);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, H[j]);</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;<span class="comment">//沿根方向输出各节点</span></span><br><span class="line">            j /= <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>, H[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    H[<span class="number">0</span>] = MINH;</span><br><span class="line">    <span class="comment">//设置岗哨</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将X插入H，这里省略检查堆是否已满的代码</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = ++<span class="built_in">size</span>; H[i / <span class="number">2</span>] &gt; X; i /= <span class="number">2</span>)</span><br><span class="line">        H[i] = H[i / <span class="number">2</span>];</span><br><span class="line">    H[i] = X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试点">测试点</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试点      提示</span><br><span class="line">0           sample 调整到根、到中间位置，有不需要调整的元素</span><br><span class="line">1           路径更长，交错，index从中间开始，有负数</span><br><span class="line">2           最小N和M</span><br><span class="line">3           最大N和M随机，元素取到正负10000</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>OOP</title>
    <url>/2020/11/27/OOP/</url>
    <content><![CDATA[<p>C++OOP</p>
<a id="more"></a>
<h1 id="c的初步知识">C++的初步知识</h1>
<h2 id="c对c的扩充">C++对C的扩充</h2>
<h3 id="名字空间">名字空间</h3>
<h4 id="名字空间-1">名字空间</h4>
<ul>
<li><p>C++标准库中的类和函数是在名字空间std中声明的。</p></li>
<li><p>名字空间可以消除那些因重名而导致的命名冲突。</p></li>
<li><p>能在名字空间以外声明或定义的实体，同样也能在名字空间之内声明或定义。</p></li>
<li><p>一个名字空间由关键字namespace开始，通常后接一个标识符来标识名字空间。在名字空间开始和结束的地方分别用左右大括号标记。</p></li>
<li><p>假设两个名字空间都有变量inflag，那么定义的语法为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ns1&#123;</span><br><span class="line">    <span class="keyword">int</span> inflag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> ns2&#123;</span><br><span class="line">    <span class="keyword">int</span> inflag;</span><br><span class="line">&#125;</span><br><span class="line">==&gt;</span><br><span class="line">ns1::inflag=<span class="number">2</span>;</span><br><span class="line">ns2::inflag=<span class="number">-3</span>;</span><br><span class="line">==&gt;</span><br><span class="line"><span class="keyword">using</span> ns1::inflag;</span><br><span class="line">inflag=<span class="number">2</span>;</span><br><span class="line">ns2::inflag=<span class="number">-3</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="无名的名字空间">无名的名字空间</h4>
<ul>
<li><p>C++允许使用没有名字的名字空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> inflag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>由于名字空间没有名字，因此无法在其它文件中引用。</p></li>
<li><p>无名名字空间内的成员的作用域为本文件从声明无名名字空间的位置开始到文件结束。</p></li>
</ul>
<h3 id="c的输入输出">C++的输入/输出</h3>
<ul>
<li>C++的输入／输出是由I/O流类库提供的。流类对象cin和cout分别代表标准的输入设备和输出设备。它们在文件iostream声明。</li>
</ul>
<h4 id="用cout进行输出">用cout进行输出</h4>
<p>在C++中<strong>输出操作</strong>可理解为将数据插入到输出流对象中。<strong>屏幕</strong>输出是标准输出操作，用来将表达式的结果输出到显示器的屏幕上。其一般形式可表示为：</p>
<p>cout&lt;&lt;表达式1&lt;&lt;表达式2&lt;&lt;…&lt;&lt;表达式n；</p>
<p>其中，<strong>cout</strong>是预定义的标准<strong>输出流对象</strong>，<strong>&lt;&lt;</strong>是输出运算符。用它可以输出各种不同类型的数据。</p>
<h4 id="用cin进行输入">用cin进行输入</h4>
<p>在C++中<strong>输入操作</strong>可理解为从输入流对象中提取数据。<strong>键盘</strong>输入是标准输入，其一般形式可表示为：</p>
<p>cin&gt;&gt;变量1&gt;&gt;变量2&gt;&gt;…&gt;&gt;变量n；</p>
<p>其中，<strong>cin</strong>是预定义的标准<strong>输入流对象</strong>，<strong>&gt;&gt;</strong>是输入运算符。</p>
<h3 id="用const定义常量">用const定义常量</h3>
<ul>
<li><p>C语言中常用#define命令来定义符号常量</p>
<ul>
<li>在预编译时进行字符置换，又称宏替换</li>
</ul></li>
<li><p>C++通过给常量命名的方式定义常量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>&lt;数据类型名&gt;&lt;常量名&gt;=&lt;表达式&gt;;</span><br><span class="line"><span class="keyword">const</span>  <span class="keyword">int</span> MaxLine =<span class="number">1000</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>用const定义标识符常量时，<strong>一定要对其初始化。在说明时进行初始化是对这种常量置值的唯一方法</strong> ，不能用赋值运算符对这种常量进行赋值。如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MaxLine =<span class="number">35</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>const常量与宏常量相比的优点：</p>
<ul>
<li>const常量有数据类型，而宏常量没有数据类型。</li>
<li>有些集成化的调试工具可以对const常量进行调试，但不能对宏常量进行调试。</li>
</ul></li>
</ul>
<h3 id="函数原型声明">函数原型声明</h3>
<ul>
<li><p>在C语言中，如果函数调用的位置在函数定义之前，则应在函数调用之前对所调用的函数作声明。但如果所调用的函数是整型的，也可以不进行函数声明。</p></li>
<li><p>对于函数声明的形式，C语言<strong>建议</strong>采用函数原型声明。</p></li>
<li><p>在C++中，如果函数调用的位置在函数定义之前，则要求在函数调用之前<strong>必须</strong>对所调用的函数作函数原型声明。</p></li>
<li><p>函数声明的一般形式为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">函数类型 函数名（参数表）；</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="函数的重载">函数的重载</h3>
<ul>
<li><p>定义 在同一作用域中用<strong>同一函数名定义多个函数</strong>，这些函数的参数个数和参数类型不同，这些同名的函数用来实现不同的功能。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span>,<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;add(<span class="number">5</span>, <span class="number">10</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;add(<span class="number">5.0</span>, <span class="number">10.5</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15</span><br><span class="line">15.5</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="函数模板">函数模板</h3>
<ul>
<li><p>为什么引入函数模板？函数重载存在的问题。</p></li>
<li><p><em>定义</em> 实际上是一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来代表。</p></li>
<li><p>凡是函数体相同的函数都可以用这个模板来代替，不必定义多个函数，只需在模板中定义一次即可。</p></li>
<li><p>在调用函数时系统会根据实参的类型来取代模板中的虚拟类型，从而实现了不同函数的功能。</p></li>
<li><p>函数模板的定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> 或 <span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span>(a&gt;b)? a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只适用于函数的参数个数相同而类型不同，且函数体相同的情况。</p>
</blockquote></li>
<li><p>函数模板是对一组函数的描述，它以任意类型T为参数及函数返回值。</p></li>
<li><p>函数模板不是一个实实在在的函数，编译系统并不产生任何执行代码。</p></li>
<li><p>当编译系统在程序中发现有与函数模板中相匹配的函数调用时，便生成一个重载函数，该重载函数的函数体与函数模板的函数体相同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span>(a&gt;b)? a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该重载函数称为<strong>模板函数</strong>，它是函数模板的一个具体实例，只处理一种唯一的数据类型。</p>
</blockquote></li>
<li><p><em>定义</em> 函数模板时可以使用多个类型参数，每个类型参数前面只需加上关键字typename或class，用逗号分隔：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T1</span> <span class="title">max</span>(<span class="title">T1</span> <span class="title">a</span>,<span class="title">T2</span> <span class="title">b</span>)&#123;</span></span><br><span class="line">   <span class="keyword">return</span> (a&gt;b) ? a : (T1)b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数模板比函数重载更方便，程序更简洁。</p>
</blockquote></li>
</ul>
<h3 id="有默认参数的函数">有默认参数的函数</h3>
<ul>
<li><p>一般情况下，在函数调用时形参从实参那里取得值，因此实参的个数应与形参相同。</p></li>
<li><p>C++可以给形参一个默认值，这样形参就不必一定要从实参取值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">函数声明：<span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">(<span class="keyword">int</span> a=<span class="number">6</span>)</span></span>;</span><br><span class="line">(<span class="number">1</span>)  area(<span class="number">7</span>); </span><br><span class="line">(<span class="number">2</span>)  area(); &lt;==&gt; area(<span class="number">6</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>如果有多个形参，可以指定任意个默认值。</p></li>
<li><p>实参与形参的结合是从左至右进行的，因此指定默认值的参数必须放在形参列表中的<strong>最右端</strong>。</p></li>
<li><p>必须在函数调用之前将默认值的信息通知编译系统。</p></li>
<li><p>当重载函数与默认参数函数<strong>共同使用</strong>时，要注意出现<strong>二义性</strong>问题。</p></li>
</ul>
<h3 id="引用reference">引用(reference)</h3>
<h4 id="引用">引用</h4>
<ul>
<li><p><em>定义</em> 对变量起另外一个名字 (别名alias)，这个名字称为该变量的引用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;类型&gt;   &amp;&lt;引用变量名&gt; = &lt;原变量名&gt;；</span><br></pre></td></tr></table></figure></li>
<li><p>其中<strong>原变量名</strong>必须是一个已定义过的变量。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>   max ;</span><br><span class="line"><span class="keyword">int</span>  &amp;refmax=max;</span><br></pre></td></tr></table></figure></li>
<li><p>refmax并没有重新在内存中开辟存储单元，只是<strong>引用</strong>max的单元。max与refmax<strong>在内存中占用同一地址，即同一地址两个名字</strong>。</p></li>
<li><p>对引用类型的变量，说明以下几点：</p>
<ol type="1">
<li><p>引用在定义的时候要初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  &amp;refmax; <span class="comment">//错误，没有具体的引用对象</span></span><br><span class="line"><span class="keyword">int</span>  &amp;refmax=max; <span class="comment">//max是已定义过的变量</span></span><br></pre></td></tr></table></figure></li>
<li><p>对引用的操作就是对被引用的变量的操作</p></li>
<li><p>引用类型变量的初始化值不能是一个常数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  &amp;ref1 = <span class="number">5</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></li>
<li><p>一旦引用被声明，它就不能再指向其它的变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  a1, a2;</span><br><span class="line"><span class="keyword">int</span>  &amp;b=a1; <span class="comment">//使b成为变量a1的引用</span></span><br><span class="line"><span class="keyword">int</span>  &amp;b=a2; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li>
<li><p>对引用的初始化，可以用一个变量名，也可以用另一个引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  a=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span>  &amp;b=a; <span class="comment">//使b成为变量a的引用</span></span><br><span class="line"><span class="keyword">int</span>  &amp;c=b; <span class="comment">//使c成为引用b的别名</span></span><br></pre></td></tr></table></figure></li>
<li><p>引用同变量一样有地址，可以对其地址进行操作，即将其地址赋给一指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  a, *p;</span><br><span class="line"><span class="keyword">int</span>  &amp;m=a; <span class="comment">//&amp;是变量的引用</span></span><br><span class="line">p=&amp;m; <span class="comment">//&amp;是变量的地址</span></span><br><span class="line">*p=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当&amp;m的前面有<strong>类型符</strong>时（如int &amp;m），它必然是对引用的声明；如果前面无类型符（如cout&lt;&lt;&amp;m）,则是取变量的地址。</p>
</blockquote></li>
<li><p>对const常量的引用使用如下方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;a=i; <span class="comment">//声明常引用，不允许改变a的值</span></span><br><span class="line">a =<span class="number">3</span>； <span class="comment">//错误</span></span><br><span class="line">i =<span class="number">3</span>； <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></li>
</ol></li>
<li><p>以下的声明是非法的</p>
<ul>
<li>企图建立void类型的引用 void &amp;a</li>
<li>企图建立引用的数组 int &amp; a[6]</li>
<li>企图建立指向引用的指针 int &amp; *p</li>
</ul></li>
<li><p>指针与引用的区别：</p>
<ol type="1">
<li>指针是通过地址<strong>间接</strong>访问某个变量，而引用是通过别名<strong>直接</strong>访问某个变量。</li>
<li>引用必须初始化，而<strong>一旦被初始化后不得再作为其它变量的别名</strong>。指针若不进行初始化，编译器不会报错。</li>
</ol></li>
</ul>
<h4 id="引用与函数">引用与函数</h4>
<p>引用的用途主要是用来作<strong>函数的参数</strong>或<strong>函数的返回值</strong>。</p>
<h5 id="作函数的参数">作函数的参数</h5>
<ul>
<li><p>C语言中函数的参数传递有两种情况：</p>
<ul>
<li><p>将变量名作为实参</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapint</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">3</span>, j = <span class="number">5</span>;</span><br><span class="line">    swapint(i, j);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt;“,”&lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>,<span class="number">5</span></span><br></pre></td></tr></table></figure></li>
<li><p>传递变量的指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapint</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">3</span>, j = <span class="number">5</span>;</span><br><span class="line">    swapint(&amp;i, &amp;j);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt;“,”&lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>C++把变量的引用作为函数形参，即传送变量的别名。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapint</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> <span class="comment">//a,b是实参i,j的别名</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">3</span>, j = <span class="number">5</span>;</span><br><span class="line">    swapint(i, j); <span class="comment">//实参为变量</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt;“,”&lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5,3</span><br></pre></td></tr></table></figure></li>
<li><p>引用和指针变量作为形参的区别</p>
<ul>
<li>引用作为形参，实参是<strong>变量</strong>;指针变量作形参,实参是<strong>地址</strong>。</li>
<li>指针变量要另外开辟内存单元，其内容是地址；引用不是一个独立的变量，不单独占内存单元。</li>
<li>必须用指针运算符*来表示指针变量所指向的变量；而引用就代表该变量。</li>
<li>引用比指针更直观、方便、容易理解。</li>
</ul></li>
</ul>
<h5 id="作函数的返回值">作函数的返回值</h5>
<ul>
<li>一般情况下，<strong>函数不作为左值</strong>（即函数不能放在赋值号左边）。</li>
<li>如果将函数定义为返回引用类型，因为返回的是一个变量的别名，就可以将函数放在左边，即给这个变量赋值。</li>
<li>这一点类同于函数的返回值为指针类型 。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = a + x;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(t) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出9(a=9)</span></span><br><span class="line">    f(t) = <span class="number">20</span>;            <span class="comment">//先调用，再赋值 a=20</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(t) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出25(a=25)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>一个函数返回引用类型，<strong>必须返回某个类型的变量</strong>。</p></li>
<li><p>返回的变量的引用，<span style="color:red;">这个变量必须是全局变量或静态局部变量，即存储在静态区中的变量。</span></p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">f</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> t = <span class="number">2</span>;</span><br><span class="line">    t = x++;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出3   a=4   t=3</span></span><br><span class="line">    f(a) = <span class="number">20</span>;            <span class="comment">//t=20   a=5</span></span><br><span class="line">    a = a + <span class="number">5</span>;            <span class="comment">//a=10</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出10   a=11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内联函数">内联函数</h3>
<ul>
<li><p>调用函数需要一定的时间，如果有的函数需要频繁使用，则累计所用时间会很长，从而降低程序的执行效率。</p></li>
<li><p>C++提供一种提高效率的方法，即在编译时将所调用函数的代码嵌入到主函数中。这种嵌入到主函数中的函数称为<strong>内联函数</strong>(inline function，<strong>内置函数</strong>，<strong>内嵌函数</strong>)</p></li>
<li><p>内联函数是C++对C函数的扩充，是一种以<strong>空间效率换取时间效率</strong>的机制。</p></li>
<li><p>内联函数定义的一般格式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> &lt;函数值类型&gt;  &lt;函数名&gt;(&lt;参数表&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    &lt;函数体&gt;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调用内联函数时，编译器首先检查调用是否正确（类型安全检查或者自动进行类型转换）。<strong>如果正确，则将内联函数的代码直接替换函数调用，并且用实参换形参</strong>，于是省去了函数调用的开销。因此，内联机制增加了空间开销而节约了时间开销。</p></li>
<li><p>内联函数与用#define命令实现的带参宏定义有些相似，但不完全相同</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max(a,b) (a)&gt;(b) ? (a) : (b)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>用内联函数可以达到用#define宏置换的目的，但不会出现带参宏定义的副作用。</p></li>
<li><p>慎用内联</p>
<ul>
<li>使用内联函数可以节省运行时间，但却增加了目标程序的长度。</li>
<li>函数体内出现循环或递归等复杂的结构控制语句时，不适合定义为内联函数。</li>
<li>一个好的编译器将会根据函数的函数体，自动取消不值得的内联。</li>
</ul></li>
</ul>
<h3 id="作用域运算符">作用域运算符</h3>
<ul>
<li><p>每一个变量都有其有效的作用域，只能在变量的作用域内使用该变量，不能直接使用其它作用域中的变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">float</span> a = <span class="number">13.5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ::a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//::a表示全局作用域中的变量a。注意：不能用::访问函数中的局部变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">13.5</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="字符串变量">字符串变量</h3>
<ul>
<li><p>C++用一种更方便的字符串类型(string类型)定义字符串变量。string不是基本类型，是一个字符串类</p></li>
<li><p>定义字符串变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> string1;            <span class="built_in">string</span> string2=“China”;</span><br></pre></td></tr></table></figure></li>
<li><p>对字符串变量的赋值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string1=“Canada”;      string1=string2;</span><br></pre></td></tr></table></figure>
<ul>
<li>在定义字符串变量时不需指定长度，它的长度随其中的字符串长度而改变</li>
<li>可以对字符串变量中某一字符进行操作 string2[2]=‘a’;</li>
<li>字符串常量以‘\0’作为结束符，但将字符串常量存放到字符串变量中时，只存放字符串本身而不包括‘\0’</li>
</ul></li>
<li><p>字符串变量的输入输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>&gt;&gt;string1;          <span class="built_in">cout</span>&lt;&lt;string2;</span><br></pre></td></tr></table></figure></li>
<li><p>字符串变量的运算</p>
<ul>
<li><p>用赋值运算符实现字符串复制</p></li>
<li><p>```cpp string1=string2; 与strcpy(string1,string2);相似<br />
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 用加法运算符实现字符串连接</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;cpp</span><br><span class="line">  string1&#x3D;string1+string2;</span><br></pre></td></tr></table></figure></p></li>
<li><p>用关系运算符(==,&gt;,&lt;,!=,&gt;=,&lt;=)实现字符串比较</p></li>
</ul></li>
<li><p>字符串数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> name[<span class="number">3</span>]=&#123;“Zhang”,”Li”,”Wang”&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>在一个字符串数组中包含若干个元素，每个元素相当于一个字符串变量<br />
</li>
<li>不要求每个字符串元素具有相同的长度，即使对同一个元素而言，它的长度也可以变化</li>
<li>每一个字符串元素中只包含字符串本身的字符而不包括‘\0’</li>
</ul></li>
</ul>
<h3 id="动态分配撤销内存newdelete">动态分配/撤销内存(new/delete)</h3>
<ul>
<li><p>C语言利用malloc和free分配和撤销内存空间。</p></li>
<li><p>使用malloc必须指定需要开辟的内存空间的大小，而且其返回值为 void *类型，必须进行强制类型转换才能使其返回的指针指向具体的数据。</p></li>
<li><p>new运算从堆中分配一块与<类型>相适应的存储空间，若分配成功，将这块存储空间的起始地址存入<指针变量名>。new的使用格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;指针变量名&gt;&#x3D;new &lt;类型&gt;;</span><br><span class="line">&lt;指针变量名&gt;&#x3D;new &lt;类型&gt;(&lt;初值&gt;);</span><br><span class="line">&lt;指针变量名&gt;&#x3D;new &lt;类型&gt;[&lt;元素个数&gt;];</span><br></pre></td></tr></table></figure></li>
<li><p>delete运算符用来释放<指针变量名>指向的动态存储空间。使用格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete &lt;指针变量名&gt;  </span><br><span class="line">delete[] &lt;指针变量名&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>其中，第2种格式用于释放指针指向的连续存储空间，即释放数组占用的空间。</p></li>
<li><p>动态整数存储空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>) <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">//分配存放整数的空间</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">(<span class="number">2</span>) <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>); <span class="comment">//整数初值为3</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure></li>
<li><p>连续存储空间（即数组空间）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; <span class="comment">//该数组有5个元素</span></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="测试">测试</h2>
<p>1.找出下面程序的错误。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="keyword">int</span> a,b;</span><br><span class="line">   c=add(a,b)</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"a+b="</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#123;  z=x+y;</span><br><span class="line">   <span class="keyword">return</span>(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.写出下面程序的输出结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dd</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123; x=x+z;</span><br><span class="line">  y=y-x;</span><br><span class="line">  z=<span class="number">10</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">", "</span>&lt;&lt;y&lt;&lt;<span class="string">", "</span>&lt;&lt;z&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">int</span>  a=<span class="number">3</span>,b=<span class="number">4</span>,c=<span class="number">5</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span>  i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">    dd(a,b,c);</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">","</span>&lt;&lt;b&lt;&lt;<span class="string">", "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类和对象的特性">类和对象的特性</h1>
<h2 id="面向过程与面向对象">面向过程与面向对象</h2>
<ul>
<li>面向过程的软件开发方法
<ul>
<li>按照功能划分软件的结构</li>
<li>自顶向下的设计方法</li>
<li>以函数作为程序主体</li>
</ul></li>
<li>面向对象的软件开发方法
<ul>
<li>将软件系统看作各种对象的集合</li>
<li>系统结构比较稳定</li>
<li>对象将数据及函数的具体实现方式进行封装</li>
<li>提高了软件的可重用性、可维护性和可扩展性</li>
</ul></li>
<li>面向过程编程与面向对象编程的区别：
<ul>
<li>面向过程编程先确定算法，再确定数据结构；面向对象编程先确定数据结构，再确定运算。</li>
<li>面向过程编程的程序员，习惯于建立数据结构存放数据，并定义函数来操作数据；面向对象编程的程序员则构造一个对象模型，将数据与函数组织在一起。</li>
</ul></li>
<li>掌握面向对象的困难之处在于<strong>思路的转换</strong>
<ul>
<li>我们通常习惯于考虑解决问题的方法，而不是考虑将问题抽象成对象再去解决它。</li>
</ul></li>
</ul>
<h2 id="对象和类">对象和类</h2>
<h2 id="对象和类-1">对象和类</h2>
<ul>
<li><p>对象是什么？</p>
<ul>
<li><p>实际的对象</p>
<ul>
<li><p>可以被感官感知的实物</p></li>
<li><p>思想、感觉或行为所及的概念或物理上的东西</p></li>
</ul></li>
<li><p>软件对象</p>
<ul>
<li>将状态（数据）和行为（功能）捆绑在一起的软件结构/模块，这两个部分合起来表示实际（物理或概念）对象的抽象</li>
</ul></li>
<li><p>对象的状态/数据/属性</p>
<ul>
<li><p><strong>学生</strong>对象的状态/数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">姓名</span><br><span class="line">学号</span><br><span class="line">出生日期</span><br><span class="line">地址</span><br><span class="line">专业</span><br><span class="line">本学期选择的课程清单</span><br></pre></td></tr></table></figure></li>
<li><p><strong>课程</strong>对象的状态/数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">课程编号</span><br><span class="line">课程名称</span><br><span class="line">课程所需的学时</span><br><span class="line">讲授该课程的教师名单</span><br></pre></td></tr></table></figure></li>
<li><p>对象的行为/操作/函数</p>
<ul>
<li><p><strong>学生</strong>对象的行为/操作</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注册一门课程</span><br><span class="line">取消一门课程</span><br><span class="line">选定一个专业</span><br></pre></td></tr></table></figure></p></li>
<li><p>课程对象的行为/操作</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">允许学生注册</span><br><span class="line">确定某个学生是否注册了该课程</span><br><span class="line">告知该课程需要多少学时</span><br><span class="line">告知哪一位教师讲授这门课程</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul></li>
</ul></li>
<li><p>类是什么？</p>
<ul>
<li><p>类是描述一组相似对象共有特征的抽象</p>
<ul>
<li>每一个属于该类的对象的数据结构（也就是属性的名称和类型）</li>
<li>由这些对象执行的操作/函数 （如何命令对象执行这些操作，以及为了实际执行这些操作对象必须执行的后台动作 ）</li>
</ul></li>
<li><p>类定义的实例</p>
<p><img src="./image-20201127104123081.png" alt="image-20201127104123081" style="zoom:50%;" /></p></li>
<li><p>实例化对象</p>
<ul>
<li><p>从类创建某个对象的过程</p>
<p><img src="image-20201127104250435.png" alt="image-20201127104250435" style="zoom:50%;" /></p></li>
</ul></li>
<li><p>对象和类的关系</p>
<ul>
<li>对象是类的一个具有特定属性值的具体实例</li>
<li>从一个类可以创建（实例化）多个对象</li>
<li>相同类的两个对象具有相同的属性和函数，但属性值不同</li>
</ul></li>
</ul></li>
</ul>
<h2 id="类的定义">类的定义</h2>
<ul>
<li><p>概念的抽象</p></li>
<li><p>类的UML表示法</p></li>
<li><p>类的定义方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名             </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    &lt;类成员&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，类成员包括数据成员和成员函数。</p></li>
</ul>
<h3 id="账户account结构体类型">账户Account结构体类型</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">16</span>];          <span class="comment">//账号</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];   <span class="comment">//户名</span></span><br><span class="line">    <span class="keyword">char</span> pwd[<span class="number">6</span>];       <span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">double</span> balance;  <span class="comment">//余额</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Account</span> <span class="title">a</span>;</span>       <span class="comment">//C++中，可以省略struct</span></span><br><span class="line">    a.balance = <span class="number">10000</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"balance = "</span>&lt;&lt;a.balance &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在C++中，一个结构体代表一个所有成员都是public的类，该类不能对外界隐藏自己的重要信息和私密信息。结构体表示一个没有封装的类。</li>
<li>需要对账户类进行封装！C++提供了类机制。</li>
</ul>
<p><img src="image-20201127104622801.png" alt="image-20201127104622801" style="zoom:50%;" /></p>
<ul>
<li><p>账户类的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">16</span>];          <span class="comment">//账号</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];   <span class="comment">//户名</span></span><br><span class="line">    <span class="keyword">char</span> pwd[<span class="number">6</span>];       <span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">double</span> balance;  <span class="comment">//余额</span></span><br><span class="line">&#125;;                             <span class="comment">//以括号及分号结束</span></span><br></pre></td></tr></table></figure></li>
<li><p>同理，Account类对象可定义为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Account a;</span><br></pre></td></tr></table></figure></li>
<li><p>示例类的信息隐藏特性。</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">16</span>];          <span class="comment">//帐号</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];   <span class="comment">//户名</span></span><br><span class="line">    <span class="keyword">char</span> pwd[<span class="number">6</span>];       <span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">double</span> balance;  <span class="comment">//余额</span></span><br><span class="line">&#125;;                             <span class="comment">//以括号及分号结束</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Account a;</span><br><span class="line">    a.balance = <span class="number">10000</span>;   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>进一步细化类定义的一般格式为：</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;类名&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&lt;访问控制符&gt;:</span><br><span class="line">    &lt;成员函数&gt;</span><br><span class="line">&lt;访问控制符&gt;:</span><br><span class="line">    &lt;数据成员&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="访问权限控制">访问权限控制</h3>
<ul>
<li>访问控制符包括public（公有）、private（私有）和protected（保护）。</li>
<li>三种访问权限的成员<strong>与</strong>出现的先后<strong>顺序无关</strong>，并且允许多次出现，但是一个成员只能具有一种访问属性。</li>
<li>一般来说，将类的public成员放在类体的前面，将protected、private成员放在类体的后面。</li>
</ul>
<h4 id="时间类">时间类</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:	<span class="comment">//外部接口，公有成员函数</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">SetTime</span><span class="params">(<span class="keyword">int</span> NewH, <span class="keyword">int</span> NewM, <span class="keyword">int</span> NewS)</span></span>;</span><br><span class="line">	 <span class="function"><span class="keyword">void</span> <span class="title">ShowTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:	<span class="comment">//私有数据成员</span></span><br><span class="line">	 <span class="keyword">int</span> Hour,Minute,Second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="公有成员public-member">公有成员（public member）</h4>
<ul>
<li>公有成员在程序的<strong>任何地方</strong>都可以被访问，是类的<strong>对外接口</strong>。而且在类外只能访问类的公有成员（继承除外）。</li>
<li>一般来说，成员函数的访问权限设为公有的，类外通过公有成员函数来操纵该类对象的属性。</li>
</ul>
<h4 id="私有成员private-member">私有成员（private member）</h4>
<ul>
<li>私有成员<strong>只能</strong>被本类中的<strong>成员函数和友元</strong>访问，而不能被类外调用。所谓类外指的是普通函数或其他类的成员函数。</li>
<li>一般来说，数据成员的访问权限设为私有的或保护的（如果有继承关系时）。</li>
</ul>
<h4 id="保护成员protected-member">保护成员（protected member）</h4>
<ul>
<li>保护成员具有<strong>双重性</strong>，对其派生类而言，保护成员如同公有成员；对其他程序则表现得像私有成员。</li>
<li>一般来说，程序中有类继承时，可以将部分类成员定义为保护成员，以便派生类访问，同时，对类簇外又实现了信息隐藏。</li>
</ul>
<h4 id="进一步细化">进一步细化</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;类名&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&lt;访问控制符&gt;:</span><br><span class="line">    &lt;成员函数的声明&gt;</span><br><span class="line">&lt;访问控制符&gt;:</span><br><span class="line">    &lt;数据成员的声明&gt;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;成员函数的实现&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>类定义一般分为说明部分和实现部分。说明部分是说明该类中的成员，实现部分是对成员函数的定义。格式如下：</p>
<p><img src="image-20201127105530519.png" alt="image-20201127105530519" style="zoom:50%;" /></p></li>
</ul>
<h3 id="数据成员">数据成员</h3>
<ul>
<li><p>数据成员的声明看起来很像变量声明。但是，数据成员不能在类体中被显式地初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Hour=<span class="number">0</span>;     <span class="comment">// 错误</span></span><br><span class="line">    <span class="keyword">int</span> Minute=<span class="number">0</span>;   <span class="comment">// 错误</span></span><br><span class="line">    <span class="keyword">int</span> Second=<span class="number">0</span>;   <span class="comment">// 错误</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>类的数据成员将通过<strong>构造函数</strong>进行初始化。</p></li>
</ul>
<h3 id="成员函数">成员函数</h3>
<ul>
<li><p>类的成员函数的声明与一般函数的声明一样：</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;函数值类型&gt;  &lt;函数名&gt;(&lt;参数表&gt;);</span><br></pre></td></tr></table></figure></p>
<p>参数表中可以只含参数类型而不含参数名</p></li>
</ul>
<h3 id="成员函数的实现方式">成员函数的实现方式</h3>
<ul>
<li>成员函数是类中描述行为的成员，同时也是对封装的数据进行操作的唯一途径。</li>
<li>成员函数的实现既可以在<strong>类中</strong>，也可以在<strong>类外</strong>。从类定义的格式可知，<strong>一般</strong>在类中声明成员函数，在类外具体实现成员函数。</li>
<li>如果成员函数已经在类中定义，则不需要在类外实现。需要注意的是，<strong>在类中定义的成员函数自动成为内联函数。</strong></li>
</ul>
<h4 id="在类中实现成员函数">在类中实现成员函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>	//时间类的定义</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:	       <span class="comment">//外部接口，公有成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetTime</span><span class="params">(<span class="keyword">int</span> NewH, <span class="keyword">int</span> NewM, <span class="keyword">int</span> NewS)</span></span></span><br><span class="line"><span class="function">   </span>&#123;   Hour=NewH;</span><br><span class="line">       Minute=NewM;</span><br><span class="line">       Second=NewS; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">ShowTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;Hour&lt;&lt;<span class="string">":"</span>&lt;&lt;Minute&lt;&lt;<span class="string">":"</span>&lt;&lt;Second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">private</span>:	 <span class="comment">//私有数据成员</span></span><br><span class="line">   <span class="keyword">int</span> Hour,Minute,Second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="在类外实现成员函数">在类外实现成员函数</h4>
<ul>
<li><p>若在类体外实现，则需要使用<strong>作用域运算符“::”</strong>，用它来<strong>标识</strong>某个成员函数是属于哪个类的，其定义格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;函数值类型&gt; &lt;类名&gt;::&lt;成员函数名&gt;(&lt;参数表&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    &lt;函数体&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然在类外定义成员函数，但它仍能访问类的任何成员。成员函数必须先在类内声明，而且类体必须在成员函数定义之前出现。</p></li>
</ul>
<h4 id="时间类单文件">时间类（单文件）</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>   </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetTime</span><span class="params">(<span class="keyword">int</span> NewH,<span class="keyword">int</span> NewM,<span class="keyword">int</span> New S)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> Hour,Minute,Second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时间类成员函数的实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time::SetTime</span><span class="params">(<span class="keyword">int</span> NewH,<span class="keyword">int</span> NewM,<span class="keyword">int</span> New S)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    Hour=NewH;       <span class="comment">//成员函数可直接访问私有成员</span></span><br><span class="line">    Minute=NewM;</span><br><span class="line">    Second=NewS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time::ShowTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Hour&lt;&lt;<span class="string">":"</span>&lt;&lt;Minute&lt;&lt;<span class="string">":"</span>&lt;&lt;Second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="时间类多文件">时间类（多文件）</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//time.h                //头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>	       //时间类的声明</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:	              <span class="comment">//外部接口，公有成员函数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetTime</span><span class="params">(<span class="keyword">int</span> NewH, <span class="keyword">int</span> NewM, <span class="keyword">int</span> NewS)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ShowTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:	       <span class="comment">//私有数据成员</span></span><br><span class="line">  <span class="keyword">int</span> Hour,Minute,Second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//time.cpp                //源程序文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"time.h"</span>	<span class="comment">//包含类的声明所在的头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time::SetTime</span><span class="params">(<span class="keyword">int</span> NewH, <span class="keyword">int</span> NewM, <span class="keyword">int</span> NewS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Hour=NewH;       <span class="comment">//成员函数可直接访问私有成员</span></span><br><span class="line">   Minute=NewM;</span><br><span class="line">   Second=NewS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time::ShowTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;Hour&lt;&lt;<span class="string">":"</span>&lt;&lt;Minute&lt;&lt;<span class="string">":"</span>&lt;&lt;Second&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将类的声明和实现分别放在两个不同的文件中，这样做有以下几点好处：
<ul>
<li>类的实现文件通常较大，分开便于阅读、管理和维护。</li>
<li>对软件开发商而言，他们可以向用户提供一些程序模块的接口，而不公开程序的源代码。分开管理就可以很好地解决此问题。</li>
<li>将类定义放在头文件中，以后使用不必再定义，只须一条包含命令即可，实现了代码重用。</li>
<li>便于团队对大型软件的分工合作开发。</li>
</ul></li>
</ul>
<h2 id="创建对象">创建对象</h2>
<ul>
<li><p>对象的定义格式与普通变量相同。定义格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;类名&gt; &lt;对象名表&gt;;</span><br></pre></td></tr></table></figure></li>
<li><p><对象名表>中可以有一个或多个<strong>对象名</strong>。当有多个对象名时，用逗号分隔。<对象名表>中还可以是指向对象的<strong>指针名</strong>或<strong>引用名</strong>，也可以是<strong>对象数组名</strong>。</p></li>
</ul>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time time1,time2; <span class="comment">//声明对象time1,time2</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>对象创建的另一种方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;类名&gt;&#123;</span>…&#125; &lt;对象名&gt;;</span><br></pre></td></tr></table></figure>
<p>在声明类的同时创建对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>&#123;</span>…&#125; time1,time2;</span><br></pre></td></tr></table></figure></li>
<li><p>对象的UML表示法</p></li>
</ul>
<h2 id="类成员的访问">类成员的访问</h2>
<ul>
<li><p>面向对象程序设计中，对类成员的访问往往通过<strong>接口</strong>（类的成员函数）实现。</p></li>
<li><p>在设计接口时，应注意为该类可以<strong>暴露</strong>给外界的信息提供接口，同时<strong>隐藏</strong>私密信息。</p></li>
<li><p>定义了类及其对象，就可以通过对象来使用其公有成员，从而达到对对象内部属性的访问和修改。</p></li>
<li><p><strong>在类中</strong>可<strong>直接</strong>使用成员名<strong>访问</strong>类成员，public、private和protected属性的成员都可以被访问。</p></li>
<li><p>类外访问对象中的成员可以有3种方法：</p>
<ul>
<li><p>通过对象名和成员运算符访问对象中的成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;对象名&gt;.&lt;公有成员&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>通过指向对象的指针变量访问对象中的成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;对象指针名&gt; -&gt; &lt;公有成员&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>通过对象的引用访问对象中的成员。</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Setxy</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; x &lt;&lt;“,”&lt;&lt; y &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1, a2; <span class="comment">//定义对象</span></span><br><span class="line">    a1.m = <span class="number">10</span>;</span><br><span class="line">    a1.n = <span class="number">20</span>;      <span class="comment">//为公有成员数据赋值</span></span><br><span class="line">    a1.Setxy(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">//为私有成员数据赋值</span></span><br><span class="line">    a1.Print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>,<span class="number">5</span></span><br></pre></td></tr></table></figure></li>
<li><p>用成员运算符“.”只能访问对象的<strong>公有成员</strong>，而不能访问对象的私有成员或保护成员。</p></li>
<li><p>若要访问对象的私有的数据成员，<strong>只能通过对象的公有成员函数</strong>来获取。</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Setxy</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="comment">//必须通过类内公有函数访问私有数据成员</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; x &lt;&lt;“,”&lt;&lt; y &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1, a2;</span><br><span class="line">    a1.m = <span class="number">10</span>;</span><br><span class="line">    a1.n = <span class="number">20</span>;          <span class="comment">//为公有成员数据赋值</span></span><br><span class="line">    a1.x = <span class="number">2</span>, a1.y = <span class="number">5</span>; <span class="comment">//非法，私有成员不能在类外访问</span></span><br><span class="line">    a1.Setxy(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    a1.Print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类作用域">类作用域</h3>
<p>类体的区域称为<strong>类作用域</strong>。类的成员函数与数据成员，其作用域都是属于类的作用域，仅在该类的范围内有效，<strong>故不能在主函数中直接通过函数名和成员名来调用</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">float</span> m, n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Setxy</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; x &lt;&lt;“,”&lt;&lt; y &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1, a2;</span><br><span class="line">    m = <span class="number">20</span>;</span><br><span class="line">    n = <span class="number">10</span>;</span><br><span class="line">    Setxy(<span class="number">2.0</span>, <span class="number">5.0</span>); <span class="comment">//不能直接调用</span></span><br><span class="line">    Print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间类-1">时间类</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Time time1;            <span class="comment">//声明对象time1</span></span><br><span class="line">    time1.SetTime(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);  <span class="comment">//通过对象time1访问公有成员函数</span></span><br><span class="line">    time1.ShowTime();      <span class="comment">//通过对象time1访问公有成员函数</span></span><br><span class="line">    Time time2;            <span class="comment">//声明对象time2</span></span><br><span class="line">    time2.SetTime(<span class="number">8</span>,<span class="number">30</span>,<span class="number">5</span>); <span class="comment">//通过对象time2访问公有成员函数</span></span><br><span class="line">    time2.ShowTime();      <span class="comment">//通过对象time2访问公有成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:0:0</span><br><span class="line">8:30:5</span><br></pre></td></tr></table></figure>
<p>在主函数的末尾加上一句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(time1)&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="keyword">sizeof</span>(time2);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:0:0</span><br><span class="line">8:30:5</span><br><span class="line">12</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<p>由此说明，各对象空间中<strong>只有数据成员</strong>，<strong>而无成员函数</strong>的空间。成员函数只存储一份，由对象共享。</p>
<h2 id="测试-1">测试</h2>
<p>找出程序中的错误，并改正。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_time</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show_time</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">int</span> hour;</span><br><span class="line">    <span class="keyword">int</span> minute;</span><br><span class="line">    <span class="keyword">int</span> sec;  		                     </span><br><span class="line">&#125;;</span><br><span class="line">Time t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set_time();</span><br><span class="line">    show_time();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_time</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;   <span class="built_in">cin</span>&gt;&gt;t.hour;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t.minute;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t.sec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_time</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;t.hour&lt;&lt;“:”&lt;&lt;t.minute&lt;&lt;“:”&lt;&lt;t.sec&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
</search>
