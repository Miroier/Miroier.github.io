<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2019/01/03/hello-world/</url>
    <content><![CDATA[<p>大家好，这里是Miroier。 <a id="more"></a> 第一次拥有自己的博客真的很开心。</p>
<p>以后应该会用这个博客来记录我学习中练习的代码和写的习题以及其它有趣的东西(咕咕咕~)。</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>判定是否同一棵二叉搜索树</title>
    <url>/2019/03/23/is-multiple-binary-trees-the-same/</url>
    <content><![CDATA[<p>给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列<span class="math inline">\(\lbrace2, 1, 3\rbrace\)</span>和<span class="math inline">\(\lbrace2, 3, 1\rbrace\)</span>插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。 <a id="more"></a></p>
<h4 id="输入格式">输入格式</h4>
<p>输入包含若干组测试数据。每组数据的第1行给出两个正整数N (≤10)和L，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出N个以空格分隔的正整数，作为初始插入序列。最后L行，每行给出N个插入的元素，属于L个需要检查的序列。</p>
<p>简单起见，我们保证每个插入序列都是1到N的一个排列。当读到N为0时，标志输入结束，这组数据不要处理。</p>
<h4 id="输出格式">输出格式</h4>
<p>对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。</p>
<h4 id="输入样例">输入样例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">3 1 4 2</span><br><span class="line">3 4 1 2</span><br><span class="line">3 2 4 1</span><br><span class="line">2 1</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h4 id="输出样例">输出样例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<h4 id="代码">代码</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> * <span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    Tree Left, Right;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Tree <span class="title">MakeTree</span><span class="params">(<span class="keyword">int</span> N)</span></span>;</span><br><span class="line"><span class="function">Tree <span class="title">insert</span><span class="params">(Tree T, <span class="keyword">int</span> v)</span></span>;</span><br><span class="line"><span class="function">Tree <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> V)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(Tree T, <span class="keyword">int</span> V)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">(Tree T, <span class="keyword">int</span> N)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ResetT</span><span class="params">(Tree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span><span class="params">(Tree T)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, L, i;</span><br><span class="line">    Tree T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">while</span> (N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;L);</span><br><span class="line">        T = MakeTree(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Judge(T, N))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">            ResetT(T);</span><br><span class="line">        &#125;</span><br><span class="line">        FreeTree(T);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">MakeTree</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree T;</span><br><span class="line">    <span class="keyword">int</span> i, V;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;V);</span><br><span class="line">    T = NewNode(V);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;V);</span><br><span class="line">        T = insert(T, V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">insert</span><span class="params">(Tree T, <span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!T)</span><br><span class="line">        T = NewNode(V);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (V &gt; T-&gt;v)</span><br><span class="line">            T-&gt;Right = insert(T-&gt;Right, V);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T-&gt;Left = insert(T-&gt;Left, V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Tree <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree T = (Tree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct TreeNode));</span><br><span class="line">    T-&gt;v = V;</span><br><span class="line">    T-&gt;Left = T-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    T-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(Tree T, <span class="keyword">int</span> V)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (V &lt; T-&gt;v)</span><br><span class="line">            <span class="keyword">return</span> check(T-&gt;Left, V);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (V &gt; T-&gt;v)</span><br><span class="line">            <span class="keyword">return</span> check(T-&gt;Right, V);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (V == T-&gt;v)</span><br><span class="line">        &#123;</span><br><span class="line">            T-&gt;flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Judge</span><span class="params">(Tree T, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, V, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* flag: 0代表目前还一致，1代表已经不一致*/</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;V);</span><br><span class="line">    <span class="keyword">if</span> (V != T-&gt;v)</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        T-&gt;flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;V);</span><br><span class="line">        <span class="keyword">if</span> ((!flag) &amp;&amp; (!check(T, V)))<span class="comment">/*这么做是为了把所有的输入都读取完，以免对下一组数据造成影响*/</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ResetT</span><span class="params">(Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;Left)</span><br><span class="line">        ResetT(T-&gt;Left);</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;Right)</span><br><span class="line">        ResetT(T-&gt;Right);</span><br><span class="line">    T-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FreeTree</span><span class="params">(Tree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;Left)</span><br><span class="line">        FreeTree(T-&gt;Left);</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;Right)</span><br><span class="line">        FreeTree(T-&gt;Right);</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试点信息">测试点信息</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试点   提示</span><br><span class="line">0        sample 换顺序。有Yes，有No：根不同，子树根不同。树有单边、有双子树</span><br><span class="line">1        最大N，多组合</span><br><span class="line">2        N&#x3D;1，只有1个节点</span><br><span class="line">3        卡只判断数字相对先后位置的错误算法</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>matlab</title>
    <url>/2020/01/09/matlab/</url>
    <content><![CDATA[<p>笔记来自于《MATLAB2018从入门到精通》</p>
<a id="more"></a>
<h2 id="向量与多项式">向量与多项式</h2>
<h3 id="向量">向量</h3>
<h4 id="向量的生成">向量的生成</h4>
<h5 id="直接输入法">直接输入法</h5>
<img src="/2020/01/09/matlab/1_1.png" class="">
<img src="/2020/01/09/matlab/1_2.png" class="">
<h5 id="冒号法">冒号法</h5>
<img src="/2020/01/09/matlab/1_3.png" class="">
<h5 id="利用函数linspace创建向量">利用函数linspace创建向量</h5>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">linspace</span>(first_value, last_value, number)</span><br></pre></td></tr></table></figure>
<img src="/2020/01/09/matlab/1_4.png" class="">
<h5 id="利用函数logspace创建对数分割的向量">利用函数logspace创建对数分割的向量</h5>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">logspace</span>(first_value, last_value, number)</span><br></pre></td></tr></table></figure>
<img src="/2020/01/09/matlab/1_5.png" class="">
<h4 id="向量元素的引用">向量元素的引用</h4>
<table>
<thead>
<tr class="header">
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>x(n)</td>
<td>表示向量中的第n个元素</td>
</tr>
<tr class="even">
<td>x(n1:n2)</td>
<td>表示向量中的第n1至n2个元素</td>
</tr>
</tbody>
</table>
<h4 id="向量运算">向量运算</h4>
<h5 id="四则运算">四则运算</h5>
<img src="/2020/01/09/matlab/1_6.png" class="" title="对向量进行定义、赋值">
<img src="/2020/01/09/matlab/1_7.png" class="" title="加法">
<img src="/2020/01/09/matlab/1_8.png" class="" title="减法">
<img src="/2020/01/09/matlab/1_9.png" class="" title="乘法">
<img src="/2020/01/09/matlab/1_10.png" class="" title="除法">
<h5 id="点积运算">点积运算</h5>
<table>
<thead>
<tr class="header">
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>dot(a,b)</td>
<td>返回向量a与b的点积。a和b必须同维,当a、b都是列向量时，dot(a,b)等同于a.*b</td>
</tr>
<tr class="even">
<td>dot(a,b,dim)</td>
<td>返回向量a和b在dim维的点积</td>
</tr>
</tbody>
</table>
<img src="/2020/01/09/matlab/1_11.png" class="">
<h5 id="叉积运算">叉积运算</h5>
<table>
<thead>
<tr class="header">
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>cross(a,b)</td>
<td>返回向量a与b的叉积。a和b必须是三维的向量</td>
</tr>
<tr class="even">
<td>cross(a,b,dim)</td>
<td>返回向量a和b在dim维的点积。a和b需要有相同的维数，size(a,dim)和size(b,dim)的结果必须为3</td>
</tr>
</tbody>
</table>
<img src="/2020/01/09/matlab/1_12.png" class="">
<h5 id="混合积运算">混合积运算</h5>
<img src="/2020/01/09/matlab/1_13.png" class="">
<h3 id="多项式">多项式</h3>
<h4 id="多项式的创建">多项式的创建</h4>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">poly2sym(p) <span class="comment">%p为多项式的系数</span></span><br></pre></td></tr></table></figure>
<img src="/2020/01/09/matlab/1_14.png" class="">
<h4 id="多项式四则运算">多项式四则运算</h4>
<h5 id="乘法">乘法</h5>
<p><code>conv(p1,p2)</code> <img src="/2020/01/09/matlab/1_15.png" class=""></p>
<h5 id="除法">除法</h5>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[k,r]=deconv(p,q)</span><br></pre></td></tr></table></figure>
<p>k是p除以q的商，r是余式。 上式等价于</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">p=conv[q,k]+r;</span><br></pre></td></tr></table></figure>
<img src="/2020/01/09/matlab/1_16.png" class="">
<h4 id="多项式导数运算">多项式导数运算</h4>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">polyder(p) <span class="comment">%p为多项式的系数</span></span><br></pre></td></tr></table></figure>
<img src="/2020/01/09/matlab/1_17.png" class="">
<h2 id="矩阵运算">矩阵运算</h2>
<h3 id="矩阵创建">矩阵创建</h3>
<h4 id="利用m文件创建">利用M文件创建</h4>
<img src="/2020/01/09/matlab/2_1.png" class="">
<img src="/2020/01/09/matlab/2_2.png" class="">
<h4 id="利用文本创建">利用文本创建</h4>
<img src="/2020/01/09/matlab/2_3.png" class="">
<img src="/2020/01/09/matlab/2_4.png" class="">
<h4 id="创建特殊矩阵">创建特殊矩阵</h4>
<img src="/2020/01/09/matlab/2_5.png" class="">
<h3 id="矩阵元素的运算">矩阵元素的运算</h3>
<h4 id="矩阵元素的修改">矩阵元素的修改</h4>
<table>
<colgroup>
<col style="width: 43%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="header">
<th>命令名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>D=[A;B C]</td>
<td>A为原矩阵，B、C中包含要扩充的元素，D为扩充后的矩阵</td>
</tr>
<tr class="even">
<td>A(m;:)=[]</td>
<td>删除A的第m行</td>
</tr>
<tr class="odd">
<td>A(:,n)</td>
<td>删除A的第n列</td>
</tr>
<tr class="even">
<td>A(m,n)=a; A(m,:)=[a b ...]; A(:,n)=[a b ...]</td>
<td>对A的第m列第n行的元素赋值；对A的第m行赋值；对A的第n列赋值</td>
</tr>
</tbody>
</table>
<img src="/2020/01/09/matlab/2_6.png" class="">
<h4 id="矩阵的变维">矩阵的变维</h4>
<img src="/2020/01/09/matlab/2_7.png" class="">
<img src="/2020/01/09/matlab/2_8.png" class="">
<h4 id="矩阵的变向">矩阵的变向</h4>
<table>
<thead>
<tr class="header">
<th>命令名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Rot(90)</td>
<td>将A逆时针方向旋转90°</td>
</tr>
<tr class="even">
<td>Rot(90,k)</td>
<td>将A逆时针方向旋转90° *k，k可为正整数或负整数</td>
</tr>
<tr class="odd">
<td>Fliplr(X)</td>
<td>将X左右翻转</td>
</tr>
<tr class="even">
<td>flipud(X)</td>
<td>将X上下翻转</td>
</tr>
<tr class="odd">
<td>flipdim(X,dim)</td>
<td>dim=1时对行翻转,dim=2时对列翻转</td>
</tr>
</tbody>
</table>
<img src="/2020/01/09/matlab/2_9.png" class="">
<h4 id="矩阵的抽取">矩阵的抽取</h4>
<p>矩阵的抽取主要是指对角元素和上（下）三角阵的抽取。 <img src="/2020/01/09/matlab/2_10.png" class=""> <img src="/2020/01/09/matlab/2_11.png" class=""></p>
<h3 id="矩阵的数学运算">矩阵的数学运算</h3>
<h4 id="加减">加减</h4>
<p>只有相同维度的矩阵才能进行计算 <img src="/2020/01/09/matlab/2_12.png" class=""> 减法只需将<code>+</code>改成<code>-</code></p>
<h4 id="乘法-1">乘法</h4>
<h5 id="数乘">数乘</h5>
<img src="/2020/01/09/matlab/2_13.png" class="">
<h5 id="矩阵乘法">矩阵乘法</h5>
<img src="/2020/01/09/matlab/2_14.png" class="">
<h5 id="点乘">点乘</h5>
<img src="/2020/01/09/matlab/2_15.png" class="">
<h4 id="除法-1">除法</h4>
<p>计算左除A，A的行数要与B的行数一致，计算右除A/B时，A的列数要与B的列数一致。</p>
<h5 id="左除">左除</h5>
<img src="/2020/01/09/matlab/2_16.png" class="">
<h5 id="右除">右除</h5>
<img src="/2020/01/09/matlab/2_17.png" class="">
<h3 id="矩阵运算-1">矩阵运算</h3>
<img src="/2020/01/09/matlab/2_18.png" class="">
<h4 id="幂函数">幂函数</h4>
<img src="/2020/01/09/matlab/2_19.png" class="">
<p>另外还有指数函数，对数函数，平方根函数等。</p>
<h4 id="矩阵的逆">矩阵的逆</h4>
<img src="/2020/01/09/matlab/2_20.png" class="">
<img src="/2020/01/09/matlab/2_21.png" class="">
<p>操作的对象必须是方阵</p>
<h4 id="矩阵的条件数">矩阵的条件数</h4>
<img src="/2020/01/09/matlab/2_22.png" class="">
<h4 id="矩阵的范数">矩阵的范数</h4>
<img src="/2020/01/09/matlab/2_23.png" class="">
<h2 id="二维绘图">二维绘图</h2>
<h3 id="二维绘图-1">二维绘图</h3>
<h4 id="plot">plot</h4>
<p><code>plot(x)</code> <img src="/2020/01/09/matlab/3_1.png" class=""></p>
<p><code>plot(x,y)</code> <img src="/2020/01/09/matlab/3_2.png" class=""></p>
<p><code>subplot(x,y)</code> <img src="/2020/01/09/matlab/3_3.png" class=""></p>
<p><code>plot(x,y,s)</code> s用来设置所画数据点的类型、大小、颜色以及数据点之间连线的类型、粗细、颜色等。 <img src="/2020/01/09/matlab/3_4.png" class="" title="颜色控制字符表"> <img src="/2020/01/09/matlab/3_5.png" class="" title="线性符号及说明"> <img src="/2020/01/09/matlab/3_6.png" class="" title="hanzibuxing"></p>
<p><code>plot(x1,y1,s1,x2,y2,s2,···)</code> 运行此命令等价于依次执行plot(xi,yi,si),i=1,2,...</p>
<h4 id="fplot">fplot</h4>
<p>  fplot命令也是MATLAB提供的一个画图命令，它是一个专门用于画一元函数图像的命令。<br />
  虽然plot命令也可以画一元函数图像，但plot命令是依据我们给定的数据点来作图的，而在实际情况中，一般并不清楚函数的具体情况，因此依据我们所选取的数据点作的图像可能会忽略真实函数的某些重要特性，给科研工作造成不可估计的损失。MATLAB提供了专门绘制一元函数图像的fplot命令，它用来指导数据点的选取，通过其内部自适应算法，在函数变化比较平稳处，它所取的数据点就会相对稀疏一点，在函数变化明显处所取的数据点就会自动密一些，因此用fplot命令所作出的图像要比用plot命令作出的图像光滑准确。 <img src="/2020/01/09/matlab/3_7.png" class="" title="fplot的调用格式"> <img src="/2020/01/09/matlab/3_8.png" class="" title="对于上面用法的几点说明"></p>
<h4 id="ezplot">ezplot</h4>
<p>ezplot可以很容易地将一个符号函数图形化 <img src="/2020/01/09/matlab/3_9.png" class="" title="ezplot 命令的调用格式"> <img src="/2020/01/09/matlab/3_10.png" class=""> <img src="/2020/01/09/matlab/3_11.png" class=""></p>
<h3 id="不同坐标系下的绘图命令">不同坐标系下的绘图命令</h3>
<h4 id="极坐标系下绘图">极坐标系下绘图</h4>
<img src="/2020/01/09/matlab/3_12.png" class="">
<img src="/2020/01/09/matlab/3_13.png" class="">
<img src="/2020/01/09/matlab/3_14.png" class="">
<h2 id="图形标注">图形标注</h2>
<h3 id="图形属性设置">图形属性设置</h3>
<h4 id="坐标系与坐标轴">坐标系与坐标轴</h4>
<h5 id="坐标系的调整">坐标系的调整</h5>
<p>  MATLAB的绘图函数可根据要绘制的曲线数据的范围自动选择合适的坐标系，使得曲线尽可能清晰的显示出来。所以，一般情况下用户不必自己选择绘图坐标。但是有些图形，如果用户感觉自动选择的坐标不合适，则可以利用函数axis()选择新的坐标系。<br />
  函数axis()的调用格式为：<code>axis(xmin,xmax,ymin,ynax,zmin,zmax}</code>   这个函数格式的功能是设置x, y, z 坐标的最小值和最大值。函数输入参数可以是4个，也可以是6个，分别对应于二维或三维坐标系的最大和最小值。</p>
<h5 id="坐标轴的调整">坐标轴的调整</h5>
<p>axis命令用于控制坐标轴的显示、刻度、长度等特征</p>
<img src="/2020/01/09/matlab/4_1.png" class="" title="axis 命令的调用格式">
<img src="/2020/01/09/matlab/4_2.png" class="">
<img src="/2020/01/09/matlab/4_3.png" class="">
<img src="/2020/01/09/matlab/4_4.png" class="">
<h4 id="图形注释">图形注释</h4>
<h5 id="填充图形">填充图形</h5>
<p>fill 函数用于填充二维封闭多边形，其函数格式如下所示。 <img src="/2020/01/09/matlab/4_5.png" class=""> <img src="/2020/01/09/matlab/4_6.png" class=""> <img src="/2020/01/09/matlab/4_7.png" class=""></p>
<h5 id="注释图形标题及轴名称">注释图形标题及轴名称</h5>
<p>MATLAB中，title命令用于给图形对象加标题。</p>
<img src="/2020/01/09/matlab/4_8.png" class="" title="title 命令的格式调用">
<p><strong>说明：</strong>可以利用gcf 与gca 来获取当前图形窗口与当前坐标轴的旬柄。</p>
<p>  对坐标轴进行标注，相应的命令为xlabel、ylabel、zlabel，作用分别是对x轴、y轴、z轴进行标注，它们的调用格式都是一样的。</p>
<img src="/2020/01/09/matlab/4_9.png" class="" title="xlabel 命令的调用格式">
<h5 id="图形标注-1">图形标注</h5>
<p>  在给所绘得的图形进行详细的标注时，最常用的两个命令是text与gtext，它们均可以在图形的具体部位进行标注。</p>
<h5 id="text命令">text命令</h5>
<img src="/2020/01/09/matlab/4_10.png" class="" title="text 命令的调用格式">
<img src="/2020/01/09/matlab/4_11.png" class="" title="text 命令属性列表">
<img src="/2020/01/09/matlab/4_12.png" class="" title="续表">
<p>上表中的这些属性及相应的值都可以通过get 命令来查看，以及用set 命令来修改。</p>
<h5 id="gtext命令">gtext命令</h5>
<p>  gtext命令可以让鼠标在图形的任意位置进行标注。当光标进入图形窗口时，会变成一个大十字架形，等待用户的操作。调用格式如下：</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">gtext (<span class="string">'string'</span>,<span class="string">'property'</span>, propertyvalue,···)</span><br></pre></td></tr></table></figure>
<p>  调用这个函数后，图形窗口中的鼠标指针会成为十字光标，通过移动鼠标来进行定位，即光标移到预定位置后按下鼠标左键或键盘上的任意键都会在光标位置显示指定文本“string”。由于要用鼠标操作，该函数只能在MATLAB命令行窗口中进行。</p>
<h5 id="图例标注">图例标注</h5>
<p>  当在一幅图中出现多种曲线时，用户可以根据自己的需要，利用legend 命令对不同的图例进行说明。</p>
<img src="/2020/01/09/matlab/4_13.png" class="" title="legend 命令的调用格式">
<img src="/2020/01/09/matlab/4_14.png" class="" title="pos取值">
<h5 id="分隔线控制">分隔线控制</h5>
<img src="/2020/01/09/matlab/4_15.png" class="" title="grid 命令的调用格式">
<h3 id="特殊图形">特殊图形</h3>
<h4 id="统计图形">统计图形</h4>
<h5 id="条形图">条形图</h5>
<p>  绘制条形图时可分为二维情况和三维情况，其中绘制二维条形图的命令为bar（竖直条形图）与barh（水平条形图）；绘制三维条形图的命令为bar3（竖直条形图）与bar3h（水平条形图）。它们的调用格式都是一样的，因此我们只介绍bar的调用格式</p>
<img src="/2020/01/09/matlab/4_16.png" class="" title="bar 命令的调用格式">
<h5 id="面积图">面积图</h5>
<p>  面积图在实际中可以表现不同部分对整体的影响。在MATLAB中，绘制面积图的命令是area，它的调用格式见表</p>
<img src="/2020/01/09/matlab/4_17.png" class="" title="area 命令的调用格式">
<h5 id="饼图">饼图</h5>
<p>  饼图用来显示向量或矩阵中各元素所占的比例，它可以用在一些统计数据可视化中。在二维情况下，创建饼图的命令是pie，三维情况下创建饼图的命令是pie3，二者的调用格式也非常相似，因此我们只介绍pie的调用格式。</p>
<img src="/2020/01/09/matlab/4_18.png" class="" title="pie 命令的调用格式">
<h5 id="柱状图">柱状图</h5>
<p>MATLAB中，绘制柱状图的命令有两个：<br />
hist命令：它用来绘制直角坐标系下的柱状图。<br />
rose命令：它用来绘制极坐标系下的柱状图。</p>
<img src="/2020/01/09/matlab/4_19.png" class="" title="hist 命令的调用格式">
<img src="/2020/01/09/matlab/4_20.png" class="" title="rose 命令的调用格式">
<blockquote>
<p>实例一一各个季度所占营利总额的比例统计图 <img src="/2020/01/09/matlab/4_21.png" class=""> <img src="/2020/01/09/matlab/4_22.png" class=""></p>
</blockquote>
<p><strong>注意：</strong>饼图的标注比较特别，其标签是作为文本图形对象来处理的，如果要修改标注文本字符串或位置，则首先要获取相应对象的字符串及其范围，然后再加以修改。</p>
<blockquote>
<p>实例一一绘制柱状图 <img src="/2020/01/09/matlab/4_23.png" class=""> <img src="/2020/01/09/matlab/4_24.png" class=""> <img src="/2020/01/09/matlab/4_25.png" class="" title="直角坐标系和极坐标系下的柱状图"></p>
</blockquote>
<h4 id="离散数据图形">离散数据图形</h4>
<p>  除了上面提到的统计图形外，MATLAB还提供了一些在工程计算中常用的离散数据图形，例如误差棒图、火柴杆图与阶梯图等。</p>
<h5 id="误差棒图">误差棒图</h5>
<p>MATLAB 中绘制误差棒图的命令为errorbar</p>
<img src="/2020/01/09/matlab/4_26.png" class="" title="errorbar 命令的调用格式">
<blockquote>
<p>实例一一绘制铸件尺寸误差棒图 <img src="/2020/01/09/matlab/4_27.png" class=""></p>
</blockquote>
<h5 id="火柴杆图">火柴杆图</h5>
<p>  用线条显示数据点与x轴的距离，用一小圆圈（默认标记〉或用指定的其他标记符号与线条相连，并在y轴上标记数据点的值，这样的图形称为火柴杆图。在二维情况下，实现这种操作的命令是stem。</p>
<img src="/2020/01/09/matlab/4_28.png" class="" title="stem命令的调用格式">
<p>在三维情况下，也有相应的画火柴杆图的命令stem3。</p>
<img src="/2020/01/09/matlab/4_29.png" class="" title="stem3命令的调用格式">
<blockquote>
<p>实例一一绘制火柴杆图 <img src="/2020/01/09/matlab/4_30.png" class=""> <img src="/2020/01/09/matlab/4_31.png" class=""></p>
</blockquote>
<h5 id="阶梯图">阶梯图</h5>
<p>  阶梯图在电子信息工程以及控制理论中用得非常多，在MATLAB 中，实现这种作图的命令是stairs。</p>
<img src="/2020/01/09/matlab/4_32.png" class="" title="stairs 命令的调用格式">
<blockquote>
<p>实例一一给制阶梯图 <img src="/2020/01/09/matlab/4_33.png" class=""> <img src="/2020/01/09/matlab/4_34.png" class=""></p>
</blockquote>
<h4 id="向量图形">向量图形</h4>
<p>  由于物理等学科的需要，在实际中有时需要绘制一些带方向的图形，即向量图。对于这种图形的绘制， MATLAB 中也有相关的命令，本小节就来学一下几个常用的命令。</p>
<h5 id="罗盘图">罗盘图</h5>
<p>  罗盘图即起点为坐标原点的二维或三维向量，同时还在坐标系中显示圆形的分隔线。实现这种作图的命令是compass。</p>
<img src="/2020/01/09/matlab/4_35.png" class="" title="compass 命令的调用格式">
<h5 id="羽毛图">羽毛图</h5>
<p>  羽毛图是在横坐标上等距地显示向量的图形，看起来就像鸟的羽毛一样。它的绘制命令是feather。</p>
<img src="/2020/01/09/matlab/4_36.png" class="" title="feather 命令的调用格式">
<blockquote>
<p>实例一一罗盘图与羽毛图 <img src="/2020/01/09/matlab/4_37.png" class=""> <img src="/2020/01/09/matlab/4_38.png" class=""></p>
</blockquote>
<h5 id="箭头图">箭头图</h5>
<p>  上面两个命令绘制的图也可以叫做箭头图，但即将要讲的箭头图比上面两个箭头图更像数学中的向量，即它的箭头方向为向量方向，箭头的长短表示向量的大小。这种图的绘制命令是quiver与quiver3 ，前者绘制的是二维图形，后者绘制是三维图形。它们的调用格式也十分相似，只是后者比前者多一个坐标参数，因此我们只介绍一下quiver的调用格式。</p>
<img src="/2020/01/09/matlab/4_39.png" class="" title="quiver 命令的调用格式">
<p>quiver与quiver3这两个命令经常与其他的绘图命令配合使用，见下例。</p>
<blockquote>
<p>实例一一绘制箭头图形 <img src="/2020/01/09/matlab/4_40.png" class=""> <img src="/2020/01/09/matlab/4_41.png" class=""></p>
</blockquote>
<h2 id="三维绘图">三维绘图</h2>
<h3 id="三维绘图-1">三维绘图</h3>
<p>  在实际的工程设计中， 二维绘图功能在某些场合往往无法更直观地表达数据的分析结果，常常需要将结果表示成三维图形。MATLAB 为此提供了相应的三维绘图功能，三维绘图与二维绘图功能有异曲同工之效。用于三维绘图的MATLAB 高级绘图函数中，对于上述许多问题都设置了默认值，应尽量使用默认值。<br />
  为了显示三维图形， MATLAB 提供了各种各样的函数。有一些函数可在三维空间中画线，而另一些可以画曲面与线格框架。另外，颜色可以用来代表第四维。当颜色以这种方式使用时，不但它不再具有像照片中那样显示色彩的自然属性，而且也不具有基本数据的内在属性，所以把它称作为彩色。本章主要介绍三维图形的作图方法和效果。</p>
<h4 id="三维曲线绘图命令">三维曲线绘图命令</h4>
<h5 id="plot3">plot3</h5>
<p>  plot3命令是二维绘图plot命令的扩展，因此它们的使用格式也基本相同，只是在参数中多加了一个第三维的信息。例如plot(x,y,z)与plot3(x,y,z,s)的意义是一样的，前者绘的是二维图，后者绘的是三维图，后面的参数s也是用来控制曲线的类型、粗细、颜色等。</p>
<blockquote>
<p>实例一一绘制空间直线 <img src="/2020/01/09/matlab/5_1.png" class=""> <img src="/2020/01/09/matlab/5_2.png" class=""> 实例一一绘制三维曲线 <img src="/2020/01/09/matlab/5_3.png" class=""> <img src="/2020/01/09/matlab/5_4.png" class=""></p>
</blockquote>
<h5 id="ezplot3">ezplot3</h5>
<p>  同二维情况一样， 三维绘图里也有一个专门绘制符号函数的命令ezplot3。 <img src="/2020/01/09/matlab/5_5.png" class=""></p>
<h4 id="三维网格命令">三维网格命令</h4>
<h5 id="mesh">mesh</h5>
<p>  该命令生成的是由X、Y和Z指定的网线面，而不是单根曲线。</p>
<img src="/2020/01/09/matlab/5_6.png" class="">
<p>  在演示之前，我们先来学一个常用的命令meshgrid，它用来生成二元函数z=f(x,y)中xy平面上的矩形定义域中数据点矩阵X和Y，或者是三元函数u=f(x,y,z)中立方体定义域中的数据点矩阵X、Y和Z。</p>
<img src="/2020/01/09/matlab/5_7.png" class="">
<blockquote>
<p>实例一一绘制网格面 <img src="/2020/01/09/matlab/5_8.png" class=""> <img src="/2020/01/09/matlab/5_9.png" class=""></p>
</blockquote>
<p>  对于一个三维网格图，有时用户不想显示背后的网格，这时可以利用hidden 命令来实现这种要求。它的使用格式也非常简单。</p>
<img src="/2020/01/09/matlab/5_10.png" class="" title="hidden 命令的调用格式">
<blockquote>
<p>实例一一绘制山峰曲面 <img src="/2020/01/09/matlab/5_11.png" class=""> <img src="/2020/01/09/matlab/5_12.png" class=""></p>
</blockquote>
<p>  MATLAB还有两个同类的函数：meshc与meshz。meshc用来画图形的网格图加基本的等高线图，meshz用来画图形的网格图与零平面的网格图。</p>
<blockquote>
<p>实例一一绘制函数曲面 <img src="/2020/01/09/matlab/5_13.png" class=""> <img src="/2020/01/09/matlab/5_14.png" class=""></p>
</blockquote>
<h5 id="ezmesh">ezmesh</h5>
<p>  该命令专门用来绘制符号函数f(x, y) （即f是关于x 、y 的数学函数的字符串表示）的网格图形。</p>
<img src="/2020/01/09/matlab/5_15.png" class="" title="ezmesh 命令的调用格式">
<blockquote>
<p>实例一一绘制符号函数曲面 <img src="/2020/01/09/matlab/5_16.png" class=""> <img src="/2020/01/09/matlab/5_17.png" class=""></p>
</blockquote>
<h4 id="三维曲面命令">三维曲面命令</h4>
<h5 id="surf">surf</h5>
<p>  surf命令的调用格式与mesh命令完全一样，这里就不再详细说明了。下面给出几个例子。</p>
<blockquote>
<p>实例一一绘制山峰表面 <img src="/2020/01/09/matlab/5_18.png" class=""> <img src="/2020/01/09/matlab/5_19.png" class=""></p>
</blockquote>
<p>  如果想查看曲面背后图形的情况，可以在曲面的相应位置打个洞孔，即将数据设置为NaN,所有的MATLAB作图函数都忽略NaN的数据点，在该点出现的地方留下一个洞孔。</p>
<blockquote>
<p>实例一一绘制带洞孔的山峰表面 <img src="/2020/01/09/matlab/5_20.png" class=""> <img src="/2020/01/09/matlab/5_21.png" class=""></p>
</blockquote>
<h5 id="ezsurf">ezsurf</h5>
<p>  该命令专门用来绘制符号函数f(x,y)（即f是关于x、y的数学函数的字符串表示）的表面图形。</p>
<img src="/2020/01/09/matlab/5_22.png" class="" title="ezsurf 命令的调用格式">
<blockquote>
<p>绘制参数曲面 <img src="/2020/01/09/matlab/5_23.png" class=""> <img src="/2020/01/09/matlab/5_24.png" class=""></p>
</blockquote>
<h4 id="柱面与球面">柱面与球面</h4>
<p>  在MATLAB中，有专门绘制柱面与球面的命令cylinder与sphere，它们的使用格式也非常简单。首先来看cylinder命令。</p>
<img src="/2020/01/09/matlab/5_25.png" class="">
<blockquote>
<p>实例一一绘制柱面 <img src="/2020/01/09/matlab/5_26.png" class=""> <img src="/2020/01/09/matlab/5_27.png" class=""></p>
</blockquote>
<p><strong>小技巧：</strong>用cylinder可以作棱柱的图像，例如运行cylinder(2,6)将绘出底面为正六边形、半径为2的棱柱。</p>
<p>  sphere命令用来生成三维直角坐标系中的球面。</p>
<img src="/2020/01/09/matlab/5_28.png" class="" title="sphere 命令的调用格式">
<blockquote>
<p>实例一一绘制球面 <img src="/2020/01/09/matlab/5_29.png" class=""> <img src="/2020/01/09/matlab/5_30.png" class=""></p>
</blockquote>
<h4 id="三维图形等值线">三维图形等值线</h4>
<p>  在军事、地理等学科中经常会用到等值线。在MATLAB中有许多绘制等值线的命令，我们主要介绍以下几个。</p>
<h5 id="contour3">contour3</h5>
<p>  contour3是三维绘图中最常用的绘制等值线的命令，该命令生成一个定义在矩形格栅上曲面的三维等值线图。</p>
<img src="/2020/01/09/matlab/5_31.png" class="" title="contour 命令的调用格式">
<blockquote>
<p>实例一一三维等值线图 <img src="/2020/01/09/matlab/5_32.png" class=""> <img src="/2020/01/09/matlab/5_33.png" class=""></p>
</blockquote>
<h5 id="contour">contour</h5>
<p>  contour3用于绘制二维图时就等价于contour，后者用来绘制二维等值线，可以看作是一个三维曲面向xy平面上的投影。</p>
<img src="/2020/01/09/matlab/5_34.png" class="" title="contour">
<blockquote>
<p>实例一一绘制二维等值线图 <img src="/2020/01/09/matlab/5_35.png" class=""> <img src="/2020/01/09/matlab/5_36.png" class=""></p>
</blockquote>
<h5 id="contourf">contourf</h5>
<p>  此命令用来填充二维等值线图，即先画出不同等值线，然后将相邻的等值线之间用同一颜色进行填充，填充用的颜色决定于当前的色图颜色。</p>
<img src="/2020/01/09/matlab/5_37.png" class="" title="contourf 命令的调用格式">
<blockquote>
<p>实例一一绘制二维等值线图及颜色填充 <img src="/2020/01/09/matlab/5_38.png" class=""> <img src="/2020/01/09/matlab/5_39.png" class=""></p>
</blockquote>
<h5 id="contourc">contourc</h5>
<p>  该命令计算等值线矩阵C，该矩阵可用于命令contour、contour3 和contourf等。矩阵Z中的数值确定平面上的等值线高度值，等值线的计算结果用由矩阵Z维数决定的间隔的宽度。</p>
<img src="/2020/01/09/matlab/5_40.png" class="" title="contourc 命令的调用格式">
<h5 id="clabel">clabel</h5>
<p>  clabel命令用来在二维等值线图中添加高度标签。</p>
<img src="/2020/01/09/matlab/5_41.png" class="">
<p>对上面的使用格式，需要说明的一点是，若命令中有h，则会对标签进行恰当的旋转，否则标签会竖直放置，且在恰当的位置显示一个“＋” 号。</p>
<blockquote>
<p>实例一一绘制等值线 <img src="/2020/01/09/matlab/5_42.png" class=""> <img src="/2020/01/09/matlab/5_43.png" class=""></p>
</blockquote>
<h5 id="ezcontour">ezcontour</h5>
<p>  该命令专门用来绘制符号函数f(x,y)（即f是关于x、y的数学函数的字符串表示）的等值线图。</p>
<img src="/2020/01/09/matlab/5_44.png" class="" title="ezcontour 命令的调用格式">
<blockquote>
<p>实例一一绘制符号函数等值线图 <img src="/2020/01/09/matlab/5_45.png" class=""> <img src="/2020/01/09/matlab/5_46.png" class=""></p>
</blockquote>
<h5 id="ezsurfc">ezsurfc</h5>
<p>  该命令用来绘制函数f(x,y)的带等值线的三维表面图，其中函数f是一个以字符串形式给出的二元函数。</p>
<img src="/2020/01/09/matlab/5_47.png" class="" title="ezsurfc 命令的调用格式">
<blockquote>
<p>实例一一绘制带等值线的三维表面图 <img src="/2020/01/09/matlab/5_48.png" class=""> <img src="/2020/01/09/matlab/5_49.png" class=""></p>
</blockquote>
<h3 id="三维图像修饰处理">三维图像修饰处理</h3>
<h4 id="视角处理">视角处理</h4>
<p>  在现实空间中，从不同角度或位置观察某一事物就会有不同的效果，即会有“横看成岭侧成峰”的感觉。三维图形表现的正是一个空间内的图形，因此在不同视角及位置都会有不同的效果，这在工程实际中也是经常遇到的。MATLAB 提供的view 命令能够很好地满足这种需要。   view 命令用来控制三维图形的观察点和视角。</p>
<img src="/2020/01/09/matlab/5_50.png" class="" title="view 命令的调用格式">
<p>  对于这个命令需要说明的是，方位角az与仰角el为两个旋转角度。做一通过视点和z轴平行的平面，与xy平面有一交线，该交线与y轴的反方向的、按逆时针方向（从z轴的方向观察）计算的夹角，就是观察点的方位角az；若角度为负值，则按顺时针方向计算。在通过视点与z轴的平面上，用一直线连接视点与坐标原点，该直线与xy平面的夹角就是观察点的仰角el；若仰角为负值，则观察点转移到曲面下面。</p>
<blockquote>
<p>实例一一绘制网格面视图 <img src="/2020/01/09/matlab/5_51.png" class=""> <img src="/2020/01/09/matlab/5_52.png" class=""></p>
</blockquote>
<h4 id="颜色处理">颜色处理</h4>
<h5 id="色图明暗控制命令">色图明暗控制命令</h5>
<p>MATLAB中，控制色图明暗的命令是brighten命令。</p>
<img src="/2020/01/09/matlab/5_53.png" class="" title="brighten 命令的调用格式">
<h5 id="色轴刻度">色轴刻度</h5>
<p>  caxis命令控制着对应色图的数据值的映射图。它通过将被变址的颜色数据（CData）与颜色数据映射（CDataMapping）设置为scaled，影响着任何的表面、块、图像：该命令还改变坐标轴图形对象的属性Clim与ClimMode。</p>
<img src="/2020/01/09/matlab/5_54.png" class="" title="caxis 命令的调用格式">
<blockquote>
<p>实例一一映射球面表里颜色 <img src="/2020/01/09/matlab/5_55.png" class=""> <img src="/2020/01/09/matlab/5_56.png" class=""></p>
</blockquote>
<p>  在MATLAB中，还有一个画色轴的命令colorbar，这个命令在图形窗口的工具条中有相应的图标。</p>
<img src="/2020/01/09/matlab/5_57.png" class="" title="colorbar 命令的调用格式} ##### 颜色渲染设置 &amp;emsp;&amp;emsp;shading命令用来控制曲面与补片等的图形对象的颜色渲染，同时设置当前坐标轴中的所有曲面与补片图形对象的属性EdgeColor与FaceColor。 {% asset_img 5_58.png shading 命令的调用格式">
<blockquote>
<p>实例一一渲染图形 <img src="/2020/01/09/matlab/5_59.png" class=""> <img src="/2020/01/09/matlab/5_60.png" class=""></p>
</blockquote>
<h5 id="颜色映像使用">颜色映像使用</h5>
<p>  语句colormap(M)将矩阵M作为当前图形窗口所用的颜色映像。例如，colormap(cool)装入了一个有64个输入项的cool颜色映像。colormap default装入了默认的颜色映像（hsv）。<br />
  函数plot、plot3、contour和contour3不使用颜色映像，它们使用列在plot颜色和线形表中的颜色。而大多数其他绘图函数，比如mesh、surf、fill、pcolor和它们的各种变形函数，使用当前的颜色映像。<br />
  接受颜色参量的绘图函数中的颜色参量通常采用以下3 种形式之一:</p>
<ol type="1">
<li>字符串，代表plot颜色或线型表中的一种颜色，比如'r'代表红色。</li>
<li>3个输入的行向量，它代表一个单独的RGB值，比如[.25 .50 .75]。</li>
<li>矩阵，如果颜色参量是一个矩阵，其元素做了调整，并把它们用作当前颜色映射的下标。</li>
</ol>
<blockquote>
<p>实例一一颜色映像 <img src="/2020/01/09/matlab/5_61.png" class=""> <img src="/2020/01/09/matlab/5_62.png" class=""></p>
</blockquote>
<h4 id="光照处理">光照处理</h4>
<p>  在MATLAB中绘制三维图形时，我们不仅可以画出带光照模式的曲面，还能在绘图时指定光线的来源。</p>
<h5 id="带光照模式的三维曲面">带光照模式的三维曲面</h5>
<p>  surfl命令用来画一个带光照模式的三维曲面图，该命令显示一个带阴影的曲面，结合了周围的、散射的和镜面反射的光照模式。想获得较平滑的颜色过渡，则需要使用有线性强度变化的色图（如gray、copper、bone、pink等）。</p>
<img src="/2020/01/09/matlab/5_63.png" class="" title="surlf 命令的调用格式">
<p>  对于这个命令的调用格式需要说明的一点是，参数X, Y, Z确定的点定义了参数曲面的“里面”和“外面”，若用户想曲面的“里面”有光照模式，只要使用surfl(X',Y',Z')即可。</p>
<blockquote>
<p>实例一一三维图形添加光照 <img src="/2020/01/09/matlab/5_64.png" class=""> <img src="/2020/01/09/matlab/5_65.png" class=""></p>
</blockquote>
<h5 id="光源位置及照明模式">光源位置及照明模式</h5>
<p>  在绘制带光照的三维图像时，可以利用light命令与lightangle命令来确定光源位置，其中light命令使用格式非常简单，即为：<br />
  light('color',s1,'style',s2,'position',s3)，其中color、style与position的位置可以互换，s1、s2、s3为相应的可选值。例如，light(’position’,[1 0 0])表示光源从无穷远处沿x轴向原点照射过来。</p>
<img src="/2020/01/09/matlab/5_66.png" class="" title="lightangle 命令的调用格式">
<p>  在确定了光源位置后，用户可能还会用到一些照明模式，这一点可以利用lighting命令来实现，它主要用四种使用格式，即有四种照明模式。</p>
<img src="/2020/01/09/matlab/5_67.png" class="" title="lighting 命令的调用格式">
<blockquote>
<p>实例一一色彩变幻 <img src="/2020/01/09/matlab/5_68.png" class=""> <img src="/2020/01/09/matlab/5_69.png" class=""></p>
</blockquote>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>随机选择算法</title>
    <url>/2019/08/25/randSelect/</url>
    <content><![CDATA[<p>  有这样一个问题：如何从一个无序的数组里求出第<span class="math inline">\(K\)</span>大的数（为了简化讨论，假设数组中的数各不相同），例如，对数组<span class="math inline">\(\{ 5, 12, 7, 2, 9, 3\}\)</span>来说，第三大的数是5，第五大的数是9。</p>
<a id="more"></a>
<p>  最直接的想法就是对数组排一下序，然后直接取出第<span class="math inline">\(K\)</span>大元素即可。但是这样做法需要<span class="math inline">\(O(nlogn)\)</span>的时间复杂度，虽然看起来很好，但还有更优化的算法。下面介绍随机选择算法，它对任何输入都可以达到<span class="math inline">\(O(n)\)</span>的期望时间复杂度。</p>
<p>  随机选择算法的原理类似于随机快速排序算法。可以证明虽然随机选择算法的最坏时间复杂度是<span class="math inline">\(O(n^2)\)</span>，但是其对任意输入的期望时间复杂度却是<span class="math inline">\(O(n)\)</span>，这意味着不存在一组特定的数据能使这个算法出现最坏情况，是个相当实用和出色的算法。</p>
<p>下面以一道OJ题展示一下该算法的核心代码</p>
<p><strong>题目</strong><br />
  给定一个长度为<span class="math inline">\(n(1\leq n\leq 1,000,000)\)</span>的无序正整数序列，以及另一个数<span class="math inline">\(k(1\leq k\leq 1,000,000)\)</span>（关于第<span class="math inline">\(k\)</span>大的数：例如序列<span class="math inline">\(\{ 1, 2, 3, 4, 5, 6\}\)</span>）中第三大的数是4。）</p>
<p><strong>输入</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一行两个正整数n, m。</span><br><span class="line">第二行为n个正整数。</span><br></pre></td></tr></table></figure></p>
<p><strong>输出</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第m大的数。</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输入</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure></p>
<p><strong>样例输出</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p>
<p><strong>代码</strong> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"algorithm"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cmath"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cstdio"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cstdlib"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ctime"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> A[maxn], n;</span><br><span class="line"><span class="comment">//随机选取主元，对区间[left, right]进行划分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randPartition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//生成[left, right]内的随机数p</span></span><br><span class="line">    <span class="keyword">int</span> p = round(<span class="number">1.0</span> * rand() / RAND_MAX * (right - left) + left);</span><br><span class="line">    <span class="comment">//交换A[p]与A[left]</span></span><br><span class="line">    swap(A[p], A[left]);</span><br><span class="line">    <span class="comment">//以下为不随机选择基准时的划分过程，不需要改变</span></span><br><span class="line">    <span class="comment">//将A[left]存放至临时变量temp</span></span><br><span class="line">    <span class="keyword">int</span> temp = A[left];</span><br><span class="line">    <span class="comment">//只要left与right不相遇</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; A[right] &gt; temp)</span><br><span class="line">            right--;        <span class="comment">//反复左移right</span></span><br><span class="line">        A[left] = A[right]; <span class="comment">//将A[right]挪到A[left]</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; A[left] &lt;= temp)</span><br><span class="line">            left++;         <span class="comment">//反复右移left</span></span><br><span class="line">        A[right] = A[left]; <span class="comment">//将A[left]挪到A[right]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把temp放到left和right相遇的地方</span></span><br><span class="line">    A[left] = temp;</span><br><span class="line">    <span class="comment">//返回相遇的下标</span></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//随机选择算法，从A[left, right]中找到第K大的数，进行划分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randSelect</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> K)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">return</span> A[left];</span><br><span class="line">    <span class="comment">//划分后主元的位置为p</span></span><br><span class="line">    <span class="keyword">int</span> p = randPartition(A, left, right);</span><br><span class="line">    <span class="comment">//A[p]是A[left, right]中的第M大</span></span><br><span class="line">    <span class="keyword">int</span> M = p - left + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//找到第K大的数</span></span><br><span class="line">    <span class="keyword">if</span> (K == M) <span class="comment">//找到第K大的数</span></span><br><span class="line">        <span class="keyword">return</span> A[p];</span><br><span class="line">    <span class="keyword">if</span> (K &lt; M) <span class="comment">//第K大数在主元左侧</span></span><br><span class="line">        <span class="keyword">return</span> randSelect(A, left, p - <span class="number">1</span>, K);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//第K大数在主元右侧</span></span><br><span class="line">        <span class="keyword">return</span> randSelect(A, p + <span class="number">1</span>, right, K - M);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果直接填m-1的话找的是第K小的数字</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, randSelect(A, <span class="number">0</span>, n - <span class="number">1</span>, n - m + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>插入排序</title>
    <url>/2019/01/06/insertion-sort/</url>
    <content><![CDATA[<p>插入排序的平均时间复杂度是<span class="math inline">\(O(n^2)\)</span>,对于少量元素的排序，是个有效的算法</p>
<a id="more"></a>
<p>插入排序的工作方式像许多人排序一手扑克牌。开始时，我们的左手为空并且桌面上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。</p>
<p>插入排序所需的时间取决于输入中元素的初始顺序。例如，对一个很大且其中的元素已经有序（或接近有序）的数组进行排序将会比对随机顺序的数组或逆序数组进行排序要快得多。</p>
<h3 id="伪代码">伪代码</h3>
<p>INSERTION-SORT(A) //对于数组A</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for j &#x3D; 2 to A.length</span><br><span class="line">    key&#x3D;A[i]</span><br><span class="line">    &#x2F;&#x2F;Insert A[j] to the sorted sequence A[1..j-1].</span><br><span class="line">    i &#x3D; j - 1</span><br><span class="line">    while i &gt; 0 and A[i] &gt; key</span><br><span class="line">        A[i+1] &#x3D; A[i]</span><br><span class="line">        i &#x3D; i - 1</span><br><span class="line">    A[i+1] &#x3D; key</span><br></pre></td></tr></table></figure>
<h3 id="简单的实现">简单的实现</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *A;</span><br><span class="line">    <span class="keyword">int</span> length, i, j, key;</span><br><span class="line">    <span class="comment">//输入要排序的数字个数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;length);</span><br><span class="line">    A = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>((length+<span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//输入数字</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= length; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt;= length; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        key = A[j];</span><br><span class="line">        i = j - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; A[i] &gt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            A[i + <span class="number">1</span>] = A[i];</span><br><span class="line">            i = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        A[i + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= length; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    <span class="built_in">free</span>(A);<span class="comment">//别忘了释放malloc来的空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对插入排序做一些改进我们可以得到一种更高效的排序算法--希尔排序</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>最大子列和</title>
    <url>/2019/03/07/maxsubseqsum/</url>
    <content><![CDATA[<p>最大子列和问题，即给定N个整数的序列<span class="math inline">\(\{A_1,A_2,\ldots,A_N \}\)</span>，求函数<span class="math inline">\(f(i,j)=max\lbrace 0,\sum\limits_{i=0}^n{A_k}\rbrace\)</span>的最大值。 例如<span class="math inline">\(\lbrace-2,11,-4,13,-5,-2\rbrace\)</span>的最大子列和为20，子列为<span class="math inline">\(\lbrace11,-4,13\rbrace\)</span>. <span class="math inline">\(\lbrace-10, 1, 2, 3, 4, -5, -23, 3, 7, -21\rbrace\)</span>的最大子列和为10，子列为<span class="math inline">\(\lbrace1，2，3，4\rbrace\)</span>。 <a id="more"></a> 本文将给出实现这种算法的<span class="math inline">\(\Theta(N^2)\)</span>和<span class="math inline">\(\Theta(N)\)</span>算法</p>
<h2 id="thetan2"><span class="math inline">\(\Theta(N^2)\)</span></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubseqSum</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ThisSum,MaxSum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)    <span class="comment">//i是子列左端位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        ThisSum=<span class="number">0</span>;      <span class="comment">//ThisSum是从A[i]到A[j]的子列和</span></span><br><span class="line">        <span class="keyword">for</span>(j = i; j &lt; N; j++)<span class="comment">//j是子列右端位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            ThisSum += A[j];  <span class="comment">//对于相同的i，不同的j，只要在j-1次循环的基础上累加1项即可</span></span><br><span class="line">            <span class="keyword">if</span>(ThisSum &gt; MaxSum) <span class="comment">//如果刚得到的这个子列和更大</span></span><br><span class="line">                MaxSum = ThisSum; <span class="comment">//则更新结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="thetan"><span class="math inline">\(\Theta(N)\)</span></h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubseqSum</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ThisSum, MaxSum;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    ThisSum = MaxSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ThisSum += A[i];        <span class="comment">//向右累加</span></span><br><span class="line">        <span class="keyword">if</span>(ThisSum &gt; MaxSum)</span><br><span class="line">            MaxSum = ThisSum;   <span class="comment">//发现更大和则更新当前结果</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ThisSum &lt; <span class="number">0</span>)    <span class="comment">//如果当前子列和为负</span></span><br><span class="line">            ThisSum = <span class="number">0</span>;        <span class="comment">//则不可能使后面的部分和增大，抛弃之</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MaxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方法可能不是很好理解，有必要的话可以根据上面的例子手动推演一下。</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>一元多项式的乘法与加法运算</title>
    <url>/2019/03/10/polynomial/</url>
    <content><![CDATA[<p>设计函数分别求两个一元多项式的乘积与和。 <a id="more"></a></p>
<h4 id="输入格式">输入格式</h4>
<p>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p>
<h4 id="输出格式">输出格式</h4>
<p>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出“0 0”。</p>
<h4 id="输入样例">输入样例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3 4 -5 2  6 1  -2 0</span><br><span class="line">3 5 20  -7 4  3 1</span><br></pre></td></tr></table></figure>
<h4 id="输出样例">输出样例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1</span><br><span class="line">5 20 -4 4 -5 2 9 1 -2 0</span><br></pre></td></tr></table></figure>
<h4 id="代码">代码</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NUM</span> * <span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NUM</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> coef;<span class="comment">//系数</span></span><br><span class="line">    <span class="keyword">int</span> expo;<span class="comment">//指数</span></span><br><span class="line">    List next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> coef, <span class="keyword">int</span> expo, List *rear)</span></span>;</span><br><span class="line"><span class="function">List <span class="title">add</span><span class="params">(List quem, List quen)</span></span>;</span><br><span class="line"><span class="function">List <span class="title">mul</span><span class="params">(List quem, List quen)</span></span>;</span><br><span class="line"><span class="function">List <span class="title">insertSortandMerge</span><span class="params">(List front)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(List res)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n,coef,expo;</span><br><span class="line">    List quem, quen, resadd, resmul;</span><br><span class="line">    List rearm = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM)), rearn = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM));</span><br><span class="line">    rearm-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    rearn-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    quem = rearm;</span><br><span class="line">    quen = rearn;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;coef, &amp;expo);</span><br><span class="line">        addNode(coef, expo, &amp;rearm);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;coef, &amp;expo);</span><br><span class="line">        addNode(coef, expo, &amp;rearn);</span><br><span class="line">    &#125;</span><br><span class="line">    resadd = add(quem-&gt;next, quen-&gt;next);</span><br><span class="line">    resmul = mul(quem-&gt;next, quen-&gt;next);</span><br><span class="line">    Print(resmul);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    Print(resadd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> coef, <span class="keyword">int</span> expo, List *rear)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//由于在本函数中需要改变当前结果表达式尾项指针的值</span></span><br><span class="line">    <span class="comment">//所以函数传递进来的是尾项结点指针的地址，*rear指向尾项</span></span><br><span class="line">    List P = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM));<span class="comment">//申请新节点并赋值</span></span><br><span class="line">    P-&gt;coef = coef;</span><br><span class="line">    P-&gt;expo = expo;</span><br><span class="line">    P-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将P指向的新节点插入到当前结果表达式尾项的后面</span></span><br><span class="line">    (*rear)-&gt;next = P;</span><br><span class="line">    *rear = (*rear)-&gt;next;<span class="comment">//修改rear值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">List <span class="title">add</span><span class="params">(List quem, List quen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List front, rear, temp;<span class="comment">//为方便表头插入，先产生一个临时空结点作为结果多项式链表头</span></span><br><span class="line">    rear = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM));</span><br><span class="line">    front = rear;<span class="comment">//由front记录结果多项式链表头结点</span></span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">while</span> (quem&amp;&amp;quen)<span class="comment">//当两个多项式都有非零项待处理时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (quem-&gt;expo == quen-&gt;expo)<span class="comment">//两数据项指数相等</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum = quem-&gt;coef + quen-&gt;coef;</span><br><span class="line">            <span class="keyword">if</span> (sum)</span><br><span class="line">                addNode(sum, quem-&gt;expo, &amp;rear);</span><br><span class="line">            quem = quem-&gt;next;</span><br><span class="line">            quen = quen-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (quem-&gt;expo &lt; quen-&gt;expo)<span class="comment">//quen中的数据项指数较大</span></span><br><span class="line">        &#123;</span><br><span class="line">            addNode(quen-&gt;coef, quen-&gt;expo, &amp;rear);</span><br><span class="line">            quen = quen-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (quem-&gt;expo &gt; quen-&gt;expo)<span class="comment">//quem中的数据项指数较大</span></span><br><span class="line">        &#123;</span><br><span class="line">            addNode(quem-&gt;coef, quem-&gt;expo, &amp;rear);</span><br><span class="line">            quem = quem-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将未处理完的另一个多项式的所有结点依次复制到结果多项式中去</span></span><br><span class="line">    <span class="keyword">while</span> (quem)</span><br><span class="line">    &#123;</span><br><span class="line">        addNode(quem-&gt;coef, quem-&gt;expo, &amp;rear);</span><br><span class="line">        quem = quem-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (quen)</span><br><span class="line">    &#123;</span><br><span class="line">        addNode(quen-&gt;coef, quen-&gt;expo, &amp;rear);</span><br><span class="line">        quen = quen-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    rear-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    temp = front;</span><br><span class="line">    front = front-&gt;next;<span class="comment">//令front指向结果多项式第一个非零项</span></span><br><span class="line">    <span class="built_in">free</span>(temp);<span class="comment">//释放临时空表头结点</span></span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">List <span class="title">mul</span><span class="params">(List quem, List quen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List front, rear, temp, Fquem;<span class="comment">//Fquem保存quem的位置</span></span><br><span class="line">    <span class="keyword">int</span> sum, mul;</span><br><span class="line">    rear = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM));</span><br><span class="line">    front = rear;</span><br><span class="line">    Fquem = quem;</span><br><span class="line">    <span class="keyword">while</span> (quen)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (quem)</span><br><span class="line">        &#123;</span><br><span class="line">            sum = (quem-&gt;coef) * (quen-&gt;coef);</span><br><span class="line">            mul = (quem-&gt;expo) + (quen-&gt;expo);</span><br><span class="line">            addNode(sum, mul, &amp;rear);</span><br><span class="line">            quem = quem-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        quem = Fquem;<span class="comment">//重置quem</span></span><br><span class="line">        quen = quen-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    rear-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    temp = front;</span><br><span class="line">    front = front-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    front = insertSortandMerge(front);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">List <span class="title">insertSortandMerge</span><span class="params">(List front)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//处理多项式乘法的结果</span></span><br><span class="line">    <span class="comment">/*按指数从大到小进行插入排序，第二个循环中顺便将要插入的项与之前排好序的“队列”中指数相同的项进行合并*/</span></span><br><span class="line">    List head, temp, front_to_free = front;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    head = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (front == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;coef = front-&gt;coef;</span><br><span class="line">        head-&gt;expo = front-&gt;expo;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (front)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (front-&gt;expo == temp-&gt;next-&gt;expo)</span><br><span class="line">            &#123;</span><br><span class="line">                sum = temp-&gt;next-&gt;coef + front-&gt;coef;</span><br><span class="line">                <span class="keyword">if</span> (sum)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp-&gt;next-&gt;coef = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                front = front-&gt;next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (front-&gt;expo &gt; head-&gt;expo)</span><br><span class="line">            &#123;</span><br><span class="line">                List t = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM));</span><br><span class="line">                t-&gt;coef = front-&gt;coef;</span><br><span class="line">                t-&gt;expo = front-&gt;expo;</span><br><span class="line">                t-&gt;next = head;</span><br><span class="line">                head = t;</span><br><span class="line">                front = front-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(t);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (front-&gt;expo &lt; temp-&gt;expo &amp;&amp; front-&gt;expo&gt;temp-&gt;next-&gt;expo)</span><br><span class="line">            &#123;</span><br><span class="line">                List t = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct NUM));</span><br><span class="line">                t-&gt;coef = front-&gt;coef;</span><br><span class="line">                t-&gt;expo = front-&gt;expo;</span><br><span class="line">                t-&gt;next = temp-&gt;next;</span><br><span class="line">                temp-&gt;next = t;</span><br><span class="line">                front = front-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(t);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            addNode(front-&gt;coef, front-&gt;expo, &amp;temp);</span><br><span class="line">            front = front-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(front_to_free);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(List res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输出操作，首先特判一下</span></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0 0"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">while</span> (res)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, res-&gt;coef, res-&gt;expo);</span><br><span class="line">        <span class="keyword">if</span> (res-&gt;next)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        res = res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试点信息">测试点信息</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试点    提示</span><br><span class="line">0        sample换个数字</span><br><span class="line">1        同类项合并时有抵消</span><br><span class="line">2        系数和指数取上限，结果有零多项式</span><br><span class="line">3        输入有零多项式和常数多项式</span><br></pre></td></tr></table></figure>
<p><del>什么都不想说，因为写了六个小时，太累了。</del></p>
<p>好吧，时隔一个星期，我又回来补上了一部分注释。</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>修改文章底部标签图形</title>
    <url>/2019/09/27/%E4%BF%AE%E6%94%B9%E6%96%87%E7%AB%A0%E5%BA%95%E9%83%A8%E6%A0%87%E7%AD%BE%E5%9B%BE%E5%BD%A2/</url>
    <content><![CDATA[<p>可能有人会觉得自带的<code>#</code>标签比较丑，那么可以考虑更改<code>themes\next\layout\_macro\post.swig</code>来更换一个图标</p>
<a id="more"></a>
<img src="/2019/09/27/%E4%BF%AE%E6%94%B9%E6%96%87%E7%AB%A0%E5%BA%95%E9%83%A8%E6%A0%87%E7%AD%BE%E5%9B%BE%E5%BD%A2/tags_before.png" class="" title="更改前">
<img src="/2019/09/27/%E4%BF%AE%E6%94%B9%E6%96%87%E7%AB%A0%E5%BA%95%E9%83%A8%E6%A0%87%E7%AD%BE%E5%9B%BE%E5%BD%A2/tags_after.png" class="" title="更改后">
<p>在<code>post.swig</code>文件中搜索<code>tag_indicate</code>找到<code>set tag_indicate = '#'</code>,将其改成<code>set tag_indicate = '&lt;i class="fa fa-tag"&gt;&lt;/i&gt;'</code>。</p>
<p>更好的方法：可以直接在主题目录下的<code>_config.yml</code>中搜索<code>tag_icon</code>将其值改为true</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>选择排序</title>
    <url>/2019/01/13/selection-sort/</url>
    <content><![CDATA[<p>选择排序是一种很容易理解和实现的简单排序算法。<br />
<a id="more"></a><br />
首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。因为它在不断地选择剩余元素之中的最小者，所以这种方法叫选择排序。</p>
<p>它有两个很鲜明的特点：<br />
　　运行时间与输入无关。为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息。这种性质在某些情况下是缺点，因为使用选择排序的人可能会惊讶的发现，一个已经有序的数组或是主键全部相等的数组和一个元素随机排列的数组所用的排序时间竟然一样长！我们将会看到，其它算法会更善于利用输入的初始状态。<br />
　　数据移动是最少的。每次交换都会改变两个数组元素的值，因此选择排序用了Ｎ次交换——交换次数和数组大小是线性关系。其它的任何算法都不具备这个特征（大部分的增长数量级都是线性对数或平方级别）</p>
<p>简单的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *A;</span><br><span class="line">    <span class="keyword">int</span> length, i, j, t, <span class="built_in">min</span>, key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输入要排序的数字个数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;length);</span><br><span class="line">    A = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(length * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="comment">//输入数字</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">min</span> = A[i];</span><br><span class="line">        key = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; length; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j] &lt; <span class="built_in">min</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">min</span> = A[j];</span><br><span class="line">                key = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t = A[i];</span><br><span class="line">        A[i] = <span class="built_in">min</span>;</span><br><span class="line">        A[key] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">    <span class="built_in">free</span>(A);<span class="comment">//别忘了释放malloc来的空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>Root Of AVL Tree</title>
    <url>/2019/03/23/root-of-AVL-tree/</url>
    <content><![CDATA[<p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. <a id="more"></a> Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.</p>
<h4 id="input-specification">Input Specification</h4>
<p>Each input file contains one test case. For each case, the first line contains a positive integer N (≤20) which is the total number of keys to be inserted. Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p>
<h4 id="output-specification">Output Specification</h4>
<p>For each test case, print the root of the resulting AVL tree in one line.</p>
<h4 id="sample-input-1">Sample Input 1</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">88 70 61 96 120</span><br></pre></td></tr></table></figure>
<h4 id="sample-output-1">Sample Output 1</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">70</span><br></pre></td></tr></table></figure>
<h4 id="sample-input-2">Sample Input 2</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">88 70 61 96 120 90 65</span><br></pre></td></tr></table></figure>
<h4 id="sample-output-2">Sample Output 2</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">88</span><br></pre></td></tr></table></figure>
<h4 id="代码">代码</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> * <span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position AVLTree;   <span class="comment">//AVL树类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> &#123;</span></span><br><span class="line">    ElementType Data;   <span class="comment">//结点数据</span></span><br><span class="line">    AVLTree Left;   <span class="comment">//指向左子树</span></span><br><span class="line">    AVLTree Right;  <span class="comment">//指向右子树</span></span><br><span class="line">    <span class="keyword">int</span> Height; <span class="comment">//树高</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function">AVLTree <span class="title">Insert</span><span class="params">(AVLTree T, ElementType X)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHeight</span><span class="params">(AVLTree T)</span></span>;</span><br><span class="line"><span class="function">AVLTree <span class="title">SingleLeftRotation</span><span class="params">(AVLTree A)</span></span>;</span><br><span class="line"><span class="function">AVLTree <span class="title">SingleRightRotation</span><span class="params">(AVLTree A)</span></span>;</span><br><span class="line"><span class="function">AVLTree <span class="title">DoubleLeftRightRotation</span><span class="params">(AVLTree A)</span></span>;</span><br><span class="line"><span class="function">AVLTree <span class="title">DoubleRightLeftRotation</span><span class="params">(AVLTree A)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, num;</span><br><span class="line">    AVLTree T = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);</span><br><span class="line">        T = Insert(T, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, T-&gt;Data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AVLTree <span class="title">Insert</span><span class="params">(AVLTree T, ElementType X)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//将X插入AVL树中，并且返回调整后的AVL树</span></span><br><span class="line">    <span class="keyword">if</span> (!T)<span class="comment">//若插入空树，则新建包含一个结点的树</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = (AVLTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct AVLNode));</span><br><span class="line">        T-&gt;Data = X;</span><br><span class="line">        T-&gt;Height = <span class="number">1</span>;</span><br><span class="line">        T-&gt;Left = T-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &lt; T-&gt;Data)</span><br><span class="line">    &#123;<span class="comment">//插入左子树</span></span><br><span class="line">        T-&gt;Left = Insert(T-&gt;Left, X);</span><br><span class="line">        <span class="comment">//如果需要左旋</span></span><br><span class="line">        <span class="keyword">if</span> (GetHeight(T-&gt;Left) - GetHeight(T-&gt;Right) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (X &lt; T-&gt;Left-&gt;Data)</span><br><span class="line">                T = SingleLeftRotation(T);  <span class="comment">//左单旋</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T = DoubleLeftRightRotation(T); <span class="comment">//左-右双旋</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X &gt; T-&gt;Data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//插入右子树</span></span><br><span class="line">        T-&gt;Right = Insert(T-&gt;Right, X);</span><br><span class="line">        <span class="comment">//如果需要右旋</span></span><br><span class="line">        <span class="keyword">if</span> (GetHeight(T-&gt;Right) - GetHeight(T-&gt;Left) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (X &gt; T-&gt;Right-&gt;Data)</span><br><span class="line">                T = SingleRightRotation(T); <span class="comment">//右单旋</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                T = DoubleRightLeftRotation(T); <span class="comment">//右-左双旋</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//else X==T-&gt;Data,无需插入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//别忘了更新树高</span></span><br><span class="line">    T-&gt;Height = Max(GetHeight(T-&gt;Left), GetHeight(T-&gt;Right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHeight</span><span class="params">(AVLTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T)</span><br><span class="line">        <span class="keyword">return</span> T-&gt;Height;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AVLTree <span class="title">SingleLeftRotation</span><span class="params">(AVLTree A)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//注意：A必须有一个左子结点B</span></span><br><span class="line">    <span class="comment">//将A与B做左单旋，更新A与B的高度，返回新的根节点B</span></span><br><span class="line">    AVLTree B = A-&gt;Left;</span><br><span class="line">    A-&gt;Left = B-&gt;Right;</span><br><span class="line">    B-&gt;Right = A;</span><br><span class="line">    A-&gt;Height = Max(GetHeight(A-&gt;Left), GetHeight(A-&gt;Right)) + <span class="number">1</span>;</span><br><span class="line">    B-&gt;Height = Max(GetHeight(B-&gt;Left), A-&gt;Height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AVLTree <span class="title">SingleRightRotation</span><span class="params">(AVLTree A)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//注意：A必须有一个右子结点B</span></span><br><span class="line">    <span class="comment">//将A与B做右单旋，更新A与B的高度，返回新的根节点B</span></span><br><span class="line">    AVLTree B = A-&gt;Right;</span><br><span class="line">    A-&gt;Right = B-&gt;Left;</span><br><span class="line">    B-&gt;Left = A;</span><br><span class="line">    A-&gt;Height = Max(GetHeight(A-&gt;Left), GetHeight(A-&gt;Right)) + <span class="number">1</span>;</span><br><span class="line">    B-&gt;Height = Max(GetHeight(B-&gt;Right), A-&gt;Height) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AVLTree <span class="title">DoubleLeftRightRotation</span><span class="params">(AVLTree A)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//注意：A必须有一个左子结点B，且B必须有一个右子节点C</span></span><br><span class="line">    <span class="comment">//将A、B与C做两次单旋，返回新的根节点C</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//B与C做右单旋，返回C</span></span><br><span class="line">    A-&gt;Left = SingleRightRotation(A-&gt;Left);</span><br><span class="line">    <span class="comment">//A与C做左单旋，返回C</span></span><br><span class="line">    <span class="keyword">return</span> SingleLeftRotation(A);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AVLTree <span class="title">DoubleRightLeftRotation</span><span class="params">(AVLTree A)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//注意：A必须有一个右子结点B，且B必须有一个左子节点C</span></span><br><span class="line">    <span class="comment">//将A、B与C做两次单旋，返回新的根节点C</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//B与C做左单旋，返回C</span></span><br><span class="line">    A-&gt;Right = SingleLeftRotation(A-&gt;Right);</span><br><span class="line">    <span class="comment">//A与C做右单旋，返回C</span></span><br><span class="line">    <span class="keyword">return</span> SingleRightRotation(A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试点">测试点</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试点      提示</span><br><span class="line">0           fig 1 - LL</span><br><span class="line">1           fig 2 - RR</span><br><span class="line">2           fig 3 - RL</span><br><span class="line">3           fig 4 - LR</span><br><span class="line">4           深度LL旋转</span><br><span class="line">5           最大N，深度RL旋转</span><br><span class="line">6           最小N</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>八种常用排序算法总结</title>
    <url>/2019/07/06/%E5%85%AB%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>交换排序（冒泡排序，快速排序），插入排序（直接插入排序，希尔排序），选择排序（简单选择排序，堆排序），归并排序，基数排序</p>
<a id="more"></a>
<h2 id="冒泡排序bubble-sort">冒泡排序(Bubble Sort)</h2>
<p>冒泡排序步骤：</p>
<ol type="1">
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 冒泡排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 控制共比较多少轮</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 控制比较的次数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序quick-sort">快速排序(Quick Sort)</h2>
<p>  快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。</p>
<p>快速排序步骤</p>
<ol type="1">
<li>挑选基准值：从数列中挑出一个元素，称为“基准”（pivot）</li>
<li>分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成，</li>
<li>递归排序子序列：递归地将小于基准值元素的子序列和大于基准值元素的子序列排序</li>
</ol>
<p>  递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//快速排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="comment">// 把第0个数作为基准值</span></span><br><span class="line">            <span class="keyword">int</span> pivot = arr[start];</span><br><span class="line">            <span class="comment">// 记录需要排序的下标</span></span><br><span class="line">            <span class="keyword">int</span> low = start;</span><br><span class="line">            <span class="keyword">int</span> high = end;</span><br><span class="line">            <span class="comment">// 循环找比基准值大的数和比基准值小的数</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">                <span class="comment">// 右边的数字比基准值大</span></span><br><span class="line">                <span class="keyword">while</span> (low &lt; high &amp;&amp; pivot &lt;= arr[high]) &#123;</span><br><span class="line">                    high--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 使用右边的数字替换左边的数</span></span><br><span class="line">                arr[low] = arr[high];</span><br><span class="line">                <span class="comment">// 如果左边的数字比基准值小</span></span><br><span class="line">                <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;</span><br><span class="line">                    low++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 使用左边的数字替换右边的数</span></span><br><span class="line">                arr[high] = arr[low];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把基准值赋给低（或高）的那一边（这里low==high，所以都一样）</span></span><br><span class="line">            arr[low] = pivot;</span><br><span class="line">            <span class="comment">// 处理所有小的数字</span></span><br><span class="line">            quickSort(arr, start, low);</span><br><span class="line">            <span class="comment">// 处理所有大的数字</span></span><br><span class="line">            quickSort(arr, low + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序insert-sort">插入排序(Insert Sort)</h2>
<p>  插入排序原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。举个例子来说：插入排序的工作方式像许多人排序一手扑克牌。开始时，我们的左手为空并且桌面上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。</p>
<p>  插入排序所需的时间取决于输入中元素的初始顺序。例如，对一个很大且其中的元素已经有序（或接近有序）的数组进行排序将会比对随机顺序的数组或逆序数组进行排序要快得多。</p>
<p>插入排序步骤：</p>
<ol type="1">
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤2~5</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//插入排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历所有数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 把当前遍历数字存起来</span></span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果当前数字比temp大，就一直往前直到找到合适位置</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">                <span class="comment">// 把前一个数字赋给后一个数字</span></span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把临时变量赋给不满足条件的后一个值</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序shell-sort">希尔排序(Shell Sort)</h2>
<p>  希尔排序是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p>
<p>  希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ul>
<p>  希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//希尔排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历所有的步长</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = arr.length / <span class="number">2</span>; d &gt; <span class="number">0</span>; d /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历所有的元素</span></span><br><span class="line">            <span class="comment">//下面这个for循环取d=1和插入排序一样</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = d; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                <span class="keyword">int</span> j = i - d;</span><br><span class="line">                <span class="comment">// 遍历本组中所有的元素</span></span><br><span class="line">                <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前元素大于加上步长后的那个元素</span></span><br><span class="line">                    arr[j + d] = arr[j];</span><br><span class="line">                    j -= d;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j + d] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序selection-sort">选择排序(Selection Sort)</h2>
<p>  选择排序是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p>它有两个很鲜明的特点：<br />
　　运行时间与输入无关。为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息。这种性质在某些情况下是缺点，因为使用选择排序的人可能会惊讶的发现，一个已经有序的数组或是主键全部相等的数组和一个元素随机排列的数组所用的排序时间竟然一样长！相比之下，其它算法会更善于利用输入的初始状态。<br />
　　数据移动是最少的。每次交换都会改变两个数组元素的值，因此选择排序用了<span class="math inline">\(N\)</span>次交换——交换次数和数组大小是线性关系。其它的任何算法都不具备这个特征（大部分的增长数量级都是线性对数或平方级别）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectionSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 选择排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历所有的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 这里是记录最小数下标，也可以记录最小的数</span></span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="comment">// 把当前遍历的数和后面所有的数依次进行比较，并记录下最小的数的下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果后面比较的数比记录最小的数小</span></span><br><span class="line">                <span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                    <span class="comment">// 记录下最小的那个数的下标</span></span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果最小的数和当前遍历的数的下标不一致,说明下标为minIndex的数比当前遍历的数更小</span></span><br><span class="line">            <span class="keyword">if</span> (i != minIndex) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[minIndex];</span><br><span class="line">                arr[minIndex] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序heap-sort">堆排序(Heap Sort)</h2>
<p>  堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</p>
<p>通常堆是通过一维数组来实现的。在数组起始位置为0的情形中：</p>
<ul>
<li>父节点i的左子节点在位置<span class="math inline">\((2i+1)\)</span></li>
<li>父节点i的右子节点在位置<span class="math inline">\((2i+2)\)</span></li>
<li>子节点i的父节点在位置<span class="math inline">\(((i-1)/2)\)</span></li>
</ul>
<p>  堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余<span class="math inline">\(n-1\)</span>个元素重新构造成一个堆，这样会得到<span class="math inline">\(n\)</span>个元素的次小值。如此反复执行，便能得到一个有序序列了</p>
<p>堆排序的步骤</p>
<ol type="1">
<li>构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。</li>
<li>将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//堆排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 开始位置是最后一个非叶子节点，即最后一个节点的父节点</span></span><br><span class="line">        <span class="keyword">int</span> start = (arr.length - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 调整大顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxHeap(arr, arr.length, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先把数组中第0个和堆中最后一个数交换位置，在把前面的处理为大顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            maxHeap(arr, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调整为大顶堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> size, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左子节点</span></span><br><span class="line">        <span class="keyword">int</span> leftNode = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 右子节点</span></span><br><span class="line">        <span class="keyword">int</span> rightNode = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> max = index;</span><br><span class="line">        <span class="comment">// 和两个子节点分别对比，找出最大的节点</span></span><br><span class="line">        <span class="keyword">if</span> (leftNode &lt; size &amp;&amp; arr[leftNode] &gt; arr[max]) &#123;</span><br><span class="line">            max = leftNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightNode &lt; size &amp;&amp; arr[rightNode] &gt; arr[max]) &#123;</span><br><span class="line">            max = rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换位置</span></span><br><span class="line">        <span class="keyword">if</span> (max != index) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[index];</span><br><span class="line">            arr[index] = arr[max];</span><br><span class="line">            arr[max] = temp;</span><br><span class="line">            <span class="comment">// 交换位置后可能破坏之前排好的堆，需要重新调整</span></span><br><span class="line">            maxHeap(arr, size, max);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序merge-sort">归并排序(Merge Sort)</h2>
<p>  归并排序是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p>
<p>  归并排序的基本思路是将数组分成二组<span class="math inline">\(A，B\)</span>，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。要让<span class="math inline">\(A，B\)</span>两组内部数据有序，可以再将<span class="math inline">\(A，B\)</span>组各自分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数组，再合并数组就完成了归并排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//归并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="comment">// 处理左边</span></span><br><span class="line">            mergesort(arr, low, mid);</span><br><span class="line">            <span class="comment">// 处理右边</span></span><br><span class="line">            mergesort(arr, mid + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用于存储归并后的临时数组</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 记录第一个数组中需要遍历的下标</span></span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="comment">// 记录第二个数组中需要遍历的下标</span></span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 用于记录在临时数组中存放的下标</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历两个数组，取出小的数字，放入临时数组中</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">            <span class="comment">// 如果第一个数组的数据更小</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                <span class="comment">// 把小的数据放入临时数组中</span></span><br><span class="line">                temp[index] = arr[i];</span><br><span class="line">                <span class="comment">// 让下标向后移一位</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[index] = arr[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理多余的数据</span></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">            temp[index] = arr[j];</span><br><span class="line">            j++;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[index] = arr[i];</span><br><span class="line">            i++;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把临时数组中数据重新存入原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; temp.length; k++) &#123;</span><br><span class="line">            arr[k + low] = temp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基数排序radix-sort">基数排序(Radix Sort)</h2>
<p>  基数排序是一种非比较型整数排序算法，其原理是将所有待比较数值（正整数）统一为同样的数字长度，数字较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//基数排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixsort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存数组中最大的数字</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求最大数字的位数</span></span><br><span class="line">        <span class="keyword">int</span> maxlength = (max + <span class="string">""</span>).length();</span><br><span class="line">        <span class="comment">// 用于临时存储数据的数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">        <span class="comment">// 用于记录在temp中相应数组存放的数字数量；</span></span><br><span class="line">        <span class="keyword">int</span>[] counts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="comment">// 根据最大长度的数决定比较的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = <span class="number">1</span>; i &lt; maxlength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 把每一个数字分别计算余数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 计算余数</span></span><br><span class="line">                <span class="keyword">int</span> ys = arr[j] / n % <span class="number">10</span>;</span><br><span class="line">                <span class="comment">// 把当前遍历的数据放入指定的数组中</span></span><br><span class="line">                temp[ys][counts[ys]] = arr[j];</span><br><span class="line">                <span class="comment">// 记录数量</span></span><br><span class="line">                counts[ys]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录取的元素需要放的位置</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 把数字取出来</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; counts.length; k++) &#123;</span><br><span class="line">                <span class="comment">// 记录数量数组中当前余数记录的数量不为0</span></span><br><span class="line">                <span class="keyword">if</span> (counts[k] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 循环取出元素</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; counts[k]; l++) &#123;</span><br><span class="line">                        <span class="comment">// 取出元素</span></span><br><span class="line">                        arr[index] = temp[k][l];</span><br><span class="line">                        <span class="comment">// 记录下一个位置</span></span><br><span class="line">                        index++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 把数量置为0</span></span><br><span class="line">                    counts[k] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>矩阵乘法的Strassen算法</title>
    <url>/2019/02/02/strassen/</url>
    <content><![CDATA[<p>  最简单的矩阵乘法可以通过三重循环来实现，其时间复杂度为<span class="math inline">\(\Theta(n^{3})\)</span>，Strassen算法通过巧妙的增加加法来减少乘法实现了<span class="math inline">\(O(n^{2.81})\)</span>的时间复杂度</p>
<a id="more"></a>
<p>Strassen算法的四个步骤：</p>
<ol type="1">
<li>将输入矩阵A、B与输出矩阵C分解为<span class="math inline">\(n/2\times n/2\)</span>的子矩阵，采用下标计算方法，此步骤花费<span class="math inline">\(\Theta\)</span>(1)时间。<br />
</li>
<li>创建10个<span class="math inline">\(n/2\times n/2\)</span>的矩阵，每个矩阵保存步骤1中创建的两个子矩阵的和或差，花费<span class="math inline">\(\Theta(n^2)\)</span>。<br />
</li>
<li>用步骤1中创建的子矩阵和步骤2中创建的10个矩阵，递归的计算7个<span class="math inline">\(P_i\)</span>矩阵积。<br />
</li>
<li>通过<span class="math inline">\(P_i\)</span>矩阵的不同组合进行加减运算，计算出C的子矩阵，花费时间<span class="math inline">\(\Theta(n^2)\)</span>。</li>
</ol>
<p>  为了方便计算矩阵积C=A<span class="math inline">\(\cdot\)</span>B，假定三个矩阵均为<span class="math inline">\(n\times n\)</span>矩阵，其中n为2的幂。做出这个假设是因为在每个分解步骤中，<span class="math inline">\(n\times n\)</span>矩阵都被划分为4个<span class="math inline">\(n/2\times n/2\)</span>的子矩阵，如果假定<span class="math inline">\(n\)</span>是2的幂，则只要<span class="math inline">\(n\geq 2\)</span>即可保证子矩阵规模<span class="math inline">\(n/2\)</span>为整数。</p>
<p>假定将A、B和C均分解为4个<span class="math inline">\(n/2\times n/2\)</span>的子矩阵：</p>
<p><span class="math display">\[A=
 \left[
 \begin{matrix}
   A_{11} &amp; A_{12} \\
   A_{21} &amp; A_{22} \\
  \end{matrix}
  \right]
，B=
 \left[
 \begin{matrix}
   B_{11} &amp; B_{12} \\
   B_{21} &amp; B_{22} \\
  \end{matrix}
  \right]
，C=
 \left[
 \begin{matrix}
   C_{11} &amp; C_{12} \\
   C_{21} &amp; C_{22} \\
  \end{matrix}
  \right]
\]</span> 根据矩阵乘法的定义，可以得到如下4个公式： <span class="math display">\[
\begin{equation}\label{1}
\begin{aligned}
C_{11}&amp;=A_{11}\cdot B_{11}+A_{12}\cdot B_{21} \\
C_{12}&amp;=A_{11}\cdot B_{12}+A_{12}\cdot B_{22} \\
C_{21}&amp;=A_{21}\cdot B_{11}+A_{22}\cdot B_{21} \\
C_{22}&amp;=A_{21}\cdot B_{12}+A_{22}\cdot B_{22} \\
\end{aligned}
\end{equation}
\]</span></p>
<p>步骤2中，创建如下10个矩阵： <span class="math display">\[
\begin{equation}\label{2}
\begin{aligned}
S_1&amp;=B_{12}-B_{22}\\
S_2&amp;=A_{11}-A_{12}\\
S_3&amp;=A_{21}+A_{22}\\
S_4&amp;=B_{21}-B_{21}\\
S_5&amp;=A_{11}+A_{22}\\
S_6&amp;=B_{11}+B_{22}\\
S_7&amp;=A_{12}-A_{22}\\
S_8&amp;=B_{21}+B_{22}\\
S_9&amp;=A_{11}-A_{21}\\
S_{10}&amp;=B_{11}+B_{12}\\
\end{aligned}
\end{equation}
\]</span> 由于必须进行10次<span class="math inline">\(n/2\times n/2\)</span>矩阵的加减法，因此，该步骤花费<span class="math inline">\(\Theta(n^2)\)</span>时间。 步骤3中，递归的计算7次<span class="math inline">\(n/2\times n/2\)</span>矩阵的乘法，如下所示： <span class="math display">\[
\begin{align*}
P_1&amp;=A_{11}\cdot S_1\\
P_2&amp;=S_2\cdot B_{22}\\
P_3&amp;=S_3\cdot B_{11}\\
P_4&amp;=A_{22}\cdot S_4\\
P_5&amp;=S_5\cdot S_6\\
P_6&amp;=S_7\cdot S_8\\
P_7&amp;=S_9\cdot S_{10}\\
\end{align*}
\]</span> 步骤4中， <span class="math display">\[
\begin{align*}
C_{11}&amp;=P_5+P_4-P_2+P_6\\
C_{12}&amp;=P_1+P_2\\
C_{21}&amp;=P_3+P_4\\
C_{22}&amp;=P_5+P_1-P_3-P_7\\
\end{align*}
\]</span> 共进行了8次<span class="math inline">\(n/2\times n/2\)</span>矩阵的加减法，因此花费<span class="math inline">\(\Theta(n^2)\)</span>时间。 代值计算后可以发现(2)式结果与(1)式是相同的。</p>
<p>描述Strassen算法运行时间T(n)的递归式： <span class="math display">\[T(n)=\begin{cases}
\Theta(1)&amp;n=1\\
7T(n/2)+\Theta(n^2)&amp;n&gt;1\\
\end{cases}\]</span></p>
<p>  用主方法来求解这个递归式，可知解为<span class="math inline">\(T\left(n\right)=\Theta(n^{lg7})\)</span>，由于<span class="math inline">\(lg7\)</span>介于2.80和2.81之间，所以时间复杂度为<span class="math inline">\(O(n^{2.81})\)</span>。</p>
<p>天知道Strassen是怎么想到这个方法的QAQ</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>快速幂取模</title>
    <url>/2020/07/07/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%8F%96%E6%A8%A1/</url>
    <content><![CDATA[<p>现在让我们来计算<span class="math inline">\(a^b\%c\)</span> <a id="more"></a></p>
<h2 id="最简单的想法">最简单的想法</h2>
<p>将<span class="math inline">\(a\)</span>累计乘上<span class="math inline">\(b\)</span>次再对<span class="math inline">\(c\)</span>取模即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b--)</span><br><span class="line">        ans = ans * a;</span><br><span class="line">    ans = ans % c;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看上去没有问题，但是当<span class="math inline">\(a\)</span>和<span class="math inline">\(b\)</span>的值很大时，就算是long long类型也有可能让累乘的结果溢出，而且在做乘法时一共要进行<span class="math inline">\(b\)</span>次运算，时间上的代价也很大，那么是否能从这两方面进行优化呢？</p>
<h2 id="快速幂">快速幂</h2>
<p>快速幂是一个计算<span class="math inline">\(a^b\)</span>的小技巧，它的时间复杂度为<span class="math inline">\(\Theta \left( \log n \right)\)</span>，从一个简单的例子开始：</p>
<p>现在你要计算<span class="math inline">\(62^9\)</span>这个数，假设你手上有个只能加减乘除的计算器，想必你肯定不会真的把<span class="math inline">\(62\)</span>这个数乘上<span class="math inline">\(9\)</span>次，因为这实在太慢了，我们会先计算<span class="math inline">\(62^4\)</span>的值，将其与自身相乘后再乘上一个<span class="math inline">\(62\)</span>就得到了结果，将这个规则递归下去，可以得到下面这样的流程</p>
<p><span class="math display">\[
62^9=\left( 62^4 \right) ^2*62=\left( \left( 62^2 \right) ^2 \right) ^2*62
\]</span></p>
<p>原本要进行9次乘法，现在只需要进行4次，幂越大时，效果越明显。</p>
<h3 id="递归实现">递归实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="built_in">pow</span>(a, b / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans * ans * a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ans * ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归实现">非递归实现</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="取模">取模</h2>
<p>首先引入几个数学公式 <span class="math display">\[
\begin{align}
\left( a+b \right) \%c=\left[ \left( a\%c \right) +\left( b\%c \right) \right] \%c
\\
\left( a-b \right) \%c=\left[ \left( a\%c \right) -\left( b\%c \right) \right] \%c
\\
\left( a*b \right) \%c=\left[ \left( a\%c \right) *\left( b\%c \right) \right] \%c
\end{align}
\]</span></p>
<p>我们需要用到上面的第$( 3 ) $式，下面给出证明：</p>
<p><span class="math display">\[
\begin{align*}
a\%c &amp; =d\Rightarrow a=tc+d\\
b\%c &amp; =e\Rightarrow b=kc+e\\
ab\%c &amp; =\left( tc+d \right) \left( kc+e \right) \%c\\
&amp; =\left( tkc^2+\left( te+dk \right) c+de \right) \%c\\
&amp; =de\%c=\left[ \left( a\%c \right) *\left( b\%c \right) \right] \%c
\end{align*}
\]</span></p>
<p>根据这个公式，可以知道</p>
<p><span class="math display">\[
a^b\%c=\left( a\%c \right) ^b\%c
\]</span></p>
<h2 id="最终结果">最终结果</h2>
<p>根据以上结论，我们可以在循环乘积的过程中加入取模运算，这样就可以避免最终结果过大的情况，再结合之前的快速幂技巧，就可以得到最终的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a %= c;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = (ans * a) % c;</span><br><span class="line">        a = (a * a) % c;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>堆中的路径</title>
    <url>/2019/03/30/%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>将一系列给定数字插入一个初始为空的小顶堆<code>H[]</code>。随后对任意给定的下标<code>i</code>，打印从<code>H[i]</code>到根结点的路径。 <a id="more"></a></p>
<h4 id="输入格式">输入格式</h4>
<p>每组测试第1行包含2个正整数N和M(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的N个要被插入一个初始为空的小顶堆的整数。最后一行给出M个下标。</p>
<h4 id="输出格式">输出格式</h4>
<p>对输入中给出的每个下标<code>i</code>，在一行中输出从<code>H[i]</code>到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。</p>
<h4 id="输入样例">输入样例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">46 23 26 24 10</span><br><span class="line">5 4 3</span><br></pre></td></tr></table></figure>
<h4 id="输出样例">输出样例</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">24 23 10</span><br><span class="line">46 23 10</span><br><span class="line">26 10</span><br></pre></td></tr></table></figure>
<h4 id="代码">代码</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINH -10001</span></span><br><span class="line"><span class="keyword">int</span> H[MAXN], <span class="built_in">size</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> X)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, x, i, j;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    Create();<span class="comment">//堆初始化</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;<span class="comment">//以逐个插入方式建堆</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        Insert(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;j);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, H[j]);</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;<span class="comment">//沿根方向输出各节点</span></span><br><span class="line">            j /= <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>, H[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    H[<span class="number">0</span>] = MINH;</span><br><span class="line">    <span class="comment">//设置岗哨</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将X插入H，这里省略检查堆是否已满的代码</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = ++<span class="built_in">size</span>; H[i / <span class="number">2</span>] &gt; X; i /= <span class="number">2</span>)</span><br><span class="line">        H[i] = H[i / <span class="number">2</span>];</span><br><span class="line">    H[i] = X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试点">测试点</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试点      提示</span><br><span class="line">0           sample 调整到根、到中间位置，有不需要调整的元素</span><br><span class="line">1           路径更长，交错，index从中间开始，有负数</span><br><span class="line">2           最小N和M</span><br><span class="line">3           最大N和M随机，元素取到正负10000</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>OOP</title>
    <url>/2020/11/27/OOP/</url>
    <content><![CDATA[<p>C++OOP</p>
<a id="more"></a>
<h1 id="c的初步知识">C++的初步知识</h1>
<h2 id="c对c的扩充">C++对C的扩充</h2>
<h3 id="名字空间">名字空间</h3>
<h4 id="名字空间-1">名字空间</h4>
<p>C++标准库中的类和函数是在名字空间std中声明的。</p>
<p>名字空间可以消除那些因重名而导致的命名冲突。</p>
<p>能在名字空间以外声明或定义的实体，同样也能在名字空间之内声明或定义。</p>
<p>一个名字空间由关键字namespace开始，通常后接一个标识符来标识名字空间。在名字空间开始和结束的地方分别用左右大括号标记。</p>
<p>假设两个名字空间都有变量inflag，那么定义的语法为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ns1&#123;</span><br><span class="line">    <span class="keyword">int</span> inflag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> ns2&#123;</span><br><span class="line">    <span class="keyword">int</span> inflag;</span><br><span class="line">&#125;</span><br><span class="line">==&gt;</span><br><span class="line">ns1::inflag=<span class="number">2</span>;</span><br><span class="line">ns2::inflag=<span class="number">-3</span>;</span><br><span class="line">==&gt;</span><br><span class="line"><span class="keyword">using</span> ns1::inflag;</span><br><span class="line">inflag=<span class="number">2</span>;</span><br><span class="line">ns2::inflag=<span class="number">-3</span>;</span><br></pre></td></tr></table></figure>
<h4 id="无名的名字空间">无名的名字空间</h4>
<p>C++允许使用没有名字的名字空间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> inflag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于名字空间没有名字，因此无法在其它文件中引用。</p>
<p>无名名字空间内的成员的作用域为本文件从声明无名名字空间的位置开始到文件结束。</p>
<h3 id="c的输入输出">C++的输入/输出</h3>
<p>C++的输入／输出是由I/O流类库提供的。流类对象cin和cout分别代表标准的输入设备和输出设备。它们在文件iostream声明。</p>
<h4 id="用cout进行输出">用cout进行输出</h4>
<p>在C++中<strong>输出操作</strong>可理解为将数据插入到输出流对象中。<strong>屏幕</strong>输出是标准输出操作，用来将表达式的结果输出到显示器的屏幕上。其一般形式可表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;表达式1&lt;&lt;表达式2&lt;&lt;…&lt;&lt;表达式n；</span><br></pre></td></tr></table></figure>
<p>其中，<strong>cout</strong>是预定义的标准<strong>输出流对象</strong>，<strong>&lt;&lt;</strong>是输出运算符。用它可以输出各种不同类型的数据。</p>
<h4 id="用cin进行输入">用cin进行输入</h4>
<p>在C++中<strong>输入操作</strong>可理解为从输入流对象中提取数据。<strong>键盘</strong>输入是标准输入，其一般形式可表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;变量1&gt;&gt;变量2&gt;&gt;…&gt;&gt;变量n；</span><br></pre></td></tr></table></figure>
<p>其中，<strong>cin</strong>是预定义的标准<strong>输入流对象</strong>，<strong>&gt;&gt;</strong>是输入运算符。</p>
<h3 id="用const定义常量">用const定义常量</h3>
<p>C语言中常用#define命令来定义符号常量</p>
<ul>
<li>在预编译时进行字符置换，又称宏替换</li>
</ul>
<p>C++通过给常量命名的方式定义常量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>&lt;数据类型名&gt;&lt;常量名&gt;=&lt;表达式&gt;;</span><br><span class="line"><span class="keyword">const</span>  <span class="keyword">int</span> MaxLine =<span class="number">1000</span>;</span><br></pre></td></tr></table></figure>
<p>用const定义标识符常量时，<strong>一定要对其初始化。在说明时进行初始化是对这种常量置值的唯一方法</strong> ，不能用赋值运算符对这种常量进行赋值。如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MaxLine =<span class="number">35</span>;</span><br></pre></td></tr></table></figure>
<p>const常量与宏常量相比的优点：</p>
<ul>
<li>const常量有数据类型，而宏常量没有数据类型。</li>
<li>有些集成化的调试工具可以对const常量进行调试，但不能对宏常量进行调试。</li>
</ul>
<h3 id="函数原型声明">函数原型声明</h3>
<p>在C语言中，如果函数调用的位置在函数定义之前，则应在函数调用之前对所调用的函数作声明。但如果所调用的函数是整型的，也可以不进行函数声明。</p>
<p>对于函数声明的形式，C语言<strong>建议</strong>采用函数原型声明。</p>
<p>在C++中，如果函数调用的位置在函数定义之前，则要求在函数调用之前<strong>必须</strong>对所调用的函数作函数原型声明。</p>
<p>函数声明的一般形式为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">函数类型 函数名（参数表）；</span><br></pre></td></tr></table></figure>
<h3 id="函数的重载">函数的重载</h3>
<p>定义 在同一作用域中用<strong>同一函数名定义多个函数</strong>，这些函数的参数个数和参数类型不同，这些同名的函数用来实现不同的功能。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span>,<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;add(<span class="number">5</span>, <span class="number">10</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;add(<span class="number">5.0</span>, <span class="number">10.5</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15</span><br><span class="line">15.5</span><br></pre></td></tr></table></figure>
<h3 id="函数模板">函数模板</h3>
<p>为什么引入函数模板？函数重载存在的问题。</p>
<p><em>定义</em> 实际上是一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来代表。</p>
<p>凡是函数体相同的函数都可以用这个模板来代替，不必定义多个函数，只需在模板中定义一次即可。</p>
<p>在调用函数时系统会根据实参的类型来取代模板中的虚拟类型，从而实现了不同函数的功能。</p>
<p>函数模板的定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> 或 <span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span>(a&gt;b)? a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只适用于函数的参数个数相同而类型不同，且函数体相同的情况。</p>
</blockquote>
<p>函数模板是对一组函数的描述，它以任意类型T为参数及函数返回值。</p>
<p>函数模板不是一个实实在在的函数，编译系统并不产生任何执行代码。</p>
<p>当编译系统在程序中发现有与函数模板中相匹配的函数调用时，便生成一个重载函数，该重载函数的函数体与函数模板的函数体相同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span>(a&gt;b)? a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该重载函数称为<strong>模板函数</strong>，它是函数模板的一个具体实例，只处理一种唯一的数据类型。</p>
</blockquote>
<p><em>定义</em> 函数模板时可以使用多个类型参数，每个类型参数前面只需加上关键字typename或class，用逗号分隔：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T1</span> <span class="title">max</span>(<span class="title">T1</span> <span class="title">a</span>,<span class="title">T2</span> <span class="title">b</span>)&#123;</span></span><br><span class="line">   <span class="keyword">return</span> (a&gt;b) ? a : (T1)b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数模板比函数重载更方便，程序更简洁。</p>
</blockquote>
<h3 id="有默认参数的函数">有默认参数的函数</h3>
<p>一般情况下，在函数调用时形参从实参那里取得值，因此实参的个数应与形参相同。</p>
<p>C++可以给形参一个默认值，这样形参就不必一定要从实参取值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">函数声明：<span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">(<span class="keyword">int</span> a=<span class="number">6</span>)</span></span>;</span><br><span class="line">(<span class="number">1</span>)  area(<span class="number">7</span>); </span><br><span class="line">(<span class="number">2</span>)  area(); &lt;==&gt; area(<span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<p>如果有多个形参，可以指定任意个默认值。</p>
<p>实参与形参的结合是从左至右进行的，因此指定默认值的参数必须放在形参列表中的<strong>最右端</strong>。</p>
<p>必须在函数调用之前将默认值的信息通知编译系统。</p>
<p>当重载函数与默认参数函数<strong>共同使用</strong>时，要注意出现<strong>二义性</strong>问题。</p>
<h3 id="引用reference">引用(reference)</h3>
<h4 id="引用">引用</h4>
<p><em>定义</em> 对变量起另外一个名字 (别名alias)，这个名字称为该变量的引用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;类型&gt;   &amp;&lt;引用变量名&gt; = &lt;原变量名&gt;；</span><br></pre></td></tr></table></figure>
<p>其中<strong>原变量名</strong>必须是一个已定义过的变量。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>   max ;</span><br><span class="line"><span class="keyword">int</span>  &amp;refmax=max;</span><br></pre></td></tr></table></figure>
<p>refmax并没有重新在内存中开辟存储单元，只是<strong>引用</strong>max的单元。max与refmax<strong>在内存中占用同一地址，即同一地址两个名字</strong>。</p>
<p>对引用类型的变量，说明以下几点：</p>
<ol type="1">
<li><p>引用在定义的时候要初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  &amp;refmax; <span class="comment">//错误，没有具体的引用对象</span></span><br><span class="line"><span class="keyword">int</span>  &amp;refmax=max; <span class="comment">//max是已定义过的变量</span></span><br></pre></td></tr></table></figure></li>
<li><p>对引用的操作就是对被引用的变量的操作</p></li>
<li><p>引用类型变量的初始化值不能是一个常数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  &amp;ref1 = <span class="number">5</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></li>
<li><p>一旦引用被声明，它就不能再指向其它的变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  a1, a2;</span><br><span class="line"><span class="keyword">int</span>  &amp;b=a1; <span class="comment">//使b成为变量a1的引用</span></span><br><span class="line"><span class="keyword">int</span>  &amp;b=a2; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li>
<li><p>对引用的初始化，可以用一个变量名，也可以用另一个引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  a=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span>  &amp;b=a; <span class="comment">//使b成为变量a的引用</span></span><br><span class="line"><span class="keyword">int</span>  &amp;c=b; <span class="comment">//使c成为引用b的别名</span></span><br></pre></td></tr></table></figure></li>
<li><p>引用同变量一样有地址，可以对其地址进行操作，即将其地址赋给一指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  a, *p;</span><br><span class="line"><span class="keyword">int</span>  &amp;m=a; <span class="comment">//&amp;是变量的引用</span></span><br><span class="line">p=&amp;m; <span class="comment">//&amp;是变量的地址</span></span><br><span class="line">*p=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当&amp;m的前面有<strong>类型符</strong>时（如int &amp;m），它必然是对引用的声明；如果前面无类型符（如cout&lt;&lt;&amp;m）,则是取变量的地址。</p>
</blockquote></li>
<li><p>对const常量的引用使用如下方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;a=i; <span class="comment">//声明常引用，不允许改变a的值</span></span><br><span class="line">a =<span class="number">3</span>； <span class="comment">//错误</span></span><br><span class="line">i =<span class="number">3</span>； <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>以下的声明是非法的</p>
<ul>
<li>企图建立void类型的引用 void &amp;a</li>
<li>企图建立引用的数组 int &amp; a[6]</li>
<li>企图建立指向引用的指针 int &amp; *p</li>
</ul>
<p>指针与引用的区别： 1. 指针是通过地址<strong>间接</strong>访问某个变量，而引用是通过别名<strong>直接</strong>访问某个变量。 2. 引用必须初始化，而<strong>一旦被初始化后不得再作为其它变量的别名</strong>。指针若不进行初始化，编译器不会报错。</p>
<h4 id="引用与函数">引用与函数</h4>
<p>引用的用途主要是用来作<strong>函数的参数</strong>或<strong>函数的返回值</strong>。</p>
<h5 id="作函数的参数">作函数的参数</h5>
<p>C语言中函数的参数传递有两种情况：</p>
<ul>
<li><p>将变量名作为实参</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapint</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">3</span>, j = <span class="number">5</span>;</span><br><span class="line">    swapint(i, j);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt;“,”&lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span>,<span class="number">5</span></span><br></pre></td></tr></table></figure></li>
<li><p>传递变量的指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapint</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">3</span>, j = <span class="number">5</span>;</span><br><span class="line">    swapint(&amp;i, &amp;j);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt;“,”&lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>C++把变量的引用作为函数形参，即传送变量的别名。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapint</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> <span class="comment">//a,b是实参i,j的别名</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">3</span>, j = <span class="number">5</span>;</span><br><span class="line">    swapint(i, j); <span class="comment">//实参为变量</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt;“,”&lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5,3</span><br></pre></td></tr></table></figure>
<p>引用和指针变量作为形参的区别</p>
<p>引用作为形参，实参是<strong>变量</strong>;指针变量作形参,实参是<strong>地址</strong>。</p>
<p>指针变量要另外开辟内存单元，其内容是地址；引用不是一个独立的变量，不单独占内存单元。</p>
<p>必须用指针运算符*来表示指针变量所指向的变量；而引用就代表该变量。</p>
<p>引用比指针更直观、方便、容易理解。</p>
<h5 id="作函数的返回值">作函数的返回值</h5>
<p>一般情况下，<strong>函数不作为左值</strong>（即函数不能放在赋值号左边）。</p>
<p>如果将函数定义为返回引用类型，因为返回的是一个变量的别名，就可以将函数放在左边，即给这个变量赋值。</p>
<p>这一点类同于函数的返回值为指针类型 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = a + x;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(t) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出9(a=9)</span></span><br><span class="line">    f(t) = <span class="number">20</span>;            <span class="comment">//先调用，再赋值 a=20</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(t) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出25(a=25)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个函数返回引用类型，<strong>必须返回某个类型的变量</strong>。</p>
<p>返回的变量的引用，<span style="color:red;">这个变量必须是全局变量或静态局部变量，即存储在静态区中的变量。</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> &amp;<span class="title">f</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> t = <span class="number">2</span>;</span><br><span class="line">    t = x++;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出3   a=4   t=3</span></span><br><span class="line">    f(a) = <span class="number">20</span>;            <span class="comment">//t=20   a=5</span></span><br><span class="line">    a = a + <span class="number">5</span>;            <span class="comment">//a=10</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出10   a=11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内联函数">内联函数</h3>
<p>调用函数需要一定的时间，如果有的函数需要频繁使用，则累计所用时间会很长，从而降低程序的执行效率。</p>
<p>C++提供一种提高效率的方法，即在编译时将所调用函数的代码嵌入到主函数中。这种嵌入到主函数中的函数称为<strong>内联函数</strong>(inline function，<strong>内置函数</strong>，<strong>内嵌函数</strong>)</p>
<p>内联函数是C++对C函数的扩充，是一种以<strong>空间效率换取时间效率</strong>的机制。</p>
<p>内联函数定义的一般格式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> &lt;函数值类型&gt;  &lt;函数名&gt;(&lt;参数表&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    &lt;函数体&gt;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用内联函数时，编译器首先检查调用是否正确（类型安全检查或者自动进行类型转换）。<strong>如果正确，则将内联函数的代码直接替换函数调用，并且用实参换形参</strong>，于是省去了函数调用的开销。因此，内联机制增加了空间开销而节约了时间开销。</p>
<p>内联函数与用#define命令实现的带参宏定义有些相似，但不完全相同</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max(a,b) (a)&gt;(b) ? (a) : (b)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用内联函数可以达到用#define宏置换的目的，但不会出现带参宏定义的副作用。</p>
<p>慎用内联 * 使用内联函数可以节省运行时间，但却增加了目标程序的长度。 * 函数体内出现循环或递归等复杂的结构控制语句时，不适合定义为内联函数。 * 一个好的编译器将会根据函数的函数体，自动取消不值得的内联。</p>
<h3 id="作用域运算符">作用域运算符</h3>
<p>每一个变量都有其有效的作用域，只能在变量的作用域内使用该变量，不能直接使用其它作用域中的变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">float</span> a = <span class="number">13.5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ::a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//::a表示全局作用域中的变量a。注意：不能用::访问函数中的局部变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">13.5</span><br></pre></td></tr></table></figure>
<h3 id="字符串变量">字符串变量</h3>
<p>C++用一种更方便的字符串类型(string类型)定义字符串变量。string不是基本类型，是一个字符串类</p>
<p>定义字符串变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> string1;            <span class="built_in">string</span> string2=“China”;</span><br></pre></td></tr></table></figure>
<p>对字符串变量的赋值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string1=“Canada”;      string1=string2;</span><br></pre></td></tr></table></figure>
<ul>
<li>在定义字符串变量时不需指定长度，它的长度随其中的字符串长度而改变</li>
<li>可以对字符串变量中某一字符进行操作 string2[2]=‘a’;</li>
<li>字符串常量以‘\0’作为结束符，但将字符串常量存放到字符串变量中时，只存放字符串本身而不包括‘\0’</li>
</ul>
<p>字符串变量的输入输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span>&gt;&gt;string1;          <span class="built_in">cout</span>&lt;&lt;string2;</span><br></pre></td></tr></table></figure>
<p>字符串变量的运算</p>
<ul>
<li><p>用赋值运算符实现字符串复制</p></li>
<li><p>```cpp string1=string2; 与strcpy(string1,string2);相似<br />
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 用加法运算符实现字符串连接</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;cpp</span><br><span class="line">  string1&#x3D;string1+string2;</span><br></pre></td></tr></table></figure></p></li>
<li><p>用关系运算符(==,&gt;,&lt;,!=,&gt;=,&lt;=)实现字符串比较</p></li>
</ul>
<p>字符串数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> name[<span class="number">3</span>]=&#123;“Zhang”,”Li”,”Wang”&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>在一个字符串数组中包含若干个元素，每个元素相当于一个字符串变量<br />
</li>
<li>不要求每个字符串元素具有相同的长度，即使对同一个元素而言，它的长度也可以变化</li>
<li>每一个字符串元素中只包含字符串本身的字符而不包括‘\0’</li>
</ul>
<h3 id="动态分配撤销内存newdelete">动态分配/撤销内存(new/delete)</h3>
<p>C语言利用malloc和free分配和撤销内存空间。</p>
<p>使用malloc必须指定需要开辟的内存空间的大小，而且其返回值为 void *类型，必须进行强制类型转换才能使其返回的指针指向具体的数据。</p>
<p>new运算从堆中分配一块与<类型>相适应的存储空间，若分配成功，将这块存储空间的起始地址存入<指针变量名>。new的使用格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;指针变量名&gt;&#x3D;new &lt;类型&gt;;</span><br><span class="line">&lt;指针变量名&gt;&#x3D;new &lt;类型&gt;(&lt;初值&gt;);</span><br><span class="line">&lt;指针变量名&gt;&#x3D;new &lt;类型&gt;[&lt;元素个数&gt;];</span><br></pre></td></tr></table></figure>
<p>delete运算符用来释放<指针变量名>指向的动态存储空间。使用格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete &lt;指针变量名&gt;  </span><br><span class="line">delete[] &lt;指针变量名&gt;</span><br></pre></td></tr></table></figure>
<p>其中，第2种格式用于释放指针指向的连续存储空间，即释放数组占用的空间。</p>
<p>动态整数存储空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>) <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">//分配存放整数的空间</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">(<span class="number">2</span>) <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">3</span>); <span class="comment">//整数初值为3</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>
<p>连续存储空间（即数组空间）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; <span class="comment">//该数组有5个元素</span></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2>
<p>1.找出下面程序的错误。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="keyword">int</span> a,b;</span><br><span class="line">   c=add(a,b)</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"a+b="</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#123;  z=x+y;</span><br><span class="line">   <span class="keyword">return</span>(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.写出下面程序的输出结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dd</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123; x=x+z;</span><br><span class="line">  y=y-x;</span><br><span class="line">  z=<span class="number">10</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">", "</span>&lt;&lt;y&lt;&lt;<span class="string">", "</span>&lt;&lt;z&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">int</span>  a=<span class="number">3</span>,b=<span class="number">4</span>,c=<span class="number">5</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span>  i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">    dd(a,b,c);</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">","</span>&lt;&lt;b&lt;&lt;<span class="string">", "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类和对象的特性">类和对象的特性</h1>
<h2 id="面向过程与面向对象">面向过程与面向对象</h2>
<p>面向过程的软件开发方法 * 按照功能划分软件的结构 * 自顶向下的设计方法 * 以函数作为程序主体</p>
<p>面向对象的软件开发方法 * 将软件系统看作各种对象的集合 * 系统结构比较稳定 * 对象将数据及函数的具体实现方式进行封装 * 提高了软件的可重用性、可维护性和可扩展性</p>
<p>面向过程编程与面向对象编程的区别： * 面向过程编程先确定算法，再确定数据结构；面向对象编程先确定数据结构，再确定运算。 * 面向过程编程的程序员，习惯于建立数据结构存放数据，并定义函数来操作数据；面向对象编程的程序员则构造一个对象模型，将数据与函数组织在一起。</p>
<p>掌握面向对象的困难之处在于<strong>思路的转换</strong></p>
<ul>
<li>我们通常习惯于考虑解决问题的方法，而不是考虑将问题抽象成对象再去解决它。</li>
</ul>
<h2 id="对象和类">对象和类</h2>
<p>对象是什么？</p>
<ul>
<li><p>实际的对象</p>
<ul>
<li><p>可以被感官感知的实物</p></li>
<li><p>思想、感觉或行为所及的概念或物理上的东西</p></li>
</ul></li>
<li><p>软件对象</p>
<ul>
<li>将状态（数据）和行为（功能）捆绑在一起的软件结构/模块，这两个部分合起来表示实际（物理或概念）对象的抽象</li>
</ul></li>
<li><p>对象的状态/数据/属性</p>
<ul>
<li><p><strong>学生</strong>对象的状态/数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">姓名</span><br><span class="line">学号</span><br><span class="line">出生日期</span><br><span class="line">地址</span><br><span class="line">专业</span><br><span class="line">本学期选择的课程清单</span><br></pre></td></tr></table></figure></li>
<li><p><strong>课程</strong>对象的状态/数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">课程编号</span><br><span class="line">课程名称</span><br><span class="line">课程所需的学时</span><br><span class="line">讲授该课程的教师名单</span><br></pre></td></tr></table></figure></li>
<li><p>对象的行为/操作/函数</p>
<ul>
<li><p><strong>学生</strong>对象的行为/操作</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注册一门课程</span><br><span class="line">取消一门课程</span><br><span class="line">选定一个专业</span><br></pre></td></tr></table></figure></p></li>
<li><p>课程对象的行为/操作</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">允许学生注册</span><br><span class="line">确定某个学生是否注册了该课程</span><br><span class="line">告知该课程需要多少学时</span><br><span class="line">告知哪一位教师讲授这门课程</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul></li>
</ul>
<p>类是什么？</p>
<ul>
<li><p>类是描述一组相似对象共有特征的抽象</p>
<ul>
<li>每一个属于该类的对象的数据结构（也就是属性的名称和类型）</li>
<li>由这些对象执行的操作/函数 （如何命令对象执行这些操作，以及为了实际执行这些操作对象必须执行的后台动作 ）</li>
</ul></li>
<li><p>类定义的实例</p>
<p><img src="image-20201127104123081.png" alt="image-20201127104123081" style="zoom:50%;" /></p></li>
<li><p>实例化对象</p>
<ul>
<li><p>从类创建某个对象的过程</p>
<p><img src="image-20201127104250435.png" alt="image-20201127104250435" style="zoom:50%;" /></p></li>
</ul></li>
<li><p>对象和类的关系</p>
<ul>
<li>对象是类的一个具有特定属性值的具体实例</li>
<li>从一个类可以创建（实例化）多个对象</li>
<li>相同类的两个对象具有相同的属性和函数，但属性值不同</li>
</ul></li>
</ul>
<h2 id="类的定义">类的定义</h2>
<p>概念的抽象</p>
<p>类的UML表示法</p>
<p>类的定义方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名             </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    &lt;类成员&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，类成员包括数据成员和成员函数。</p>
<h3 id="账户account结构体类型">账户Account结构体类型</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">16</span>];          <span class="comment">//账号</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];   <span class="comment">//户名</span></span><br><span class="line">    <span class="keyword">char</span> pwd[<span class="number">6</span>];       <span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">double</span> balance;  <span class="comment">//余额</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Account</span> <span class="title">a</span>;</span>       <span class="comment">//C++中，可以省略struct</span></span><br><span class="line">    a.balance = <span class="number">10000</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"balance = "</span>&lt;&lt;a.balance &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在C++中，一个结构体代表一个所有成员都是public的类，该类不能对外界隐藏自己的重要信息和私密信息。结构体表示一个没有封装的类。</p>
<p>需要对账户类进行封装！C++提供了类机制。</p>
<p><img src="image-20201127104622801.png" alt="image-20201127104622801" style="zoom:50%;" /></p>
<p>账户类的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">16</span>];          <span class="comment">//账号</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];   <span class="comment">//户名</span></span><br><span class="line">    <span class="keyword">char</span> pwd[<span class="number">6</span>];       <span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">double</span> balance;  <span class="comment">//余额</span></span><br><span class="line">&#125;;                             <span class="comment">//以括号及分号结束</span></span><br></pre></td></tr></table></figure>
<p>同理，Account类对象可定义为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Account a;</span><br></pre></td></tr></table></figure>
<p>示例类的信息隐藏特性。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">16</span>];          <span class="comment">//帐号</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">50</span>];   <span class="comment">//户名</span></span><br><span class="line">    <span class="keyword">char</span> pwd[<span class="number">6</span>];       <span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">double</span> balance;  <span class="comment">//余额</span></span><br><span class="line">&#125;;                             <span class="comment">//以括号及分号结束</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Account a;</span><br><span class="line">    a.balance = <span class="number">10000</span>;   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步细化类定义的一般格式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;类名&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&lt;访问控制符&gt;:</span><br><span class="line">    &lt;成员函数&gt;</span><br><span class="line">&lt;访问控制符&gt;:</span><br><span class="line">    &lt;数据成员&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="访问权限控制">访问权限控制</h3>
<p>访问控制符包括public（公有）、private（私有）和protected（保护）。</p>
<p>三种访问权限的成员<strong>与</strong>出现的先后<strong>顺序无关</strong>，并且允许多次出现，但是一个成员只能具有一种访问属性。</p>
<p>一般来说，将类的public成员放在类体的前面，将protected、private成员放在类体的后面。</p>
<h4 id="时间类">时间类</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:	<span class="comment">//外部接口，公有成员函数</span></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">SetTime</span><span class="params">(<span class="keyword">int</span> NewH, <span class="keyword">int</span> NewM, <span class="keyword">int</span> NewS)</span></span>;</span><br><span class="line">	 <span class="function"><span class="keyword">void</span> <span class="title">ShowTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:	<span class="comment">//私有数据成员</span></span><br><span class="line">	 <span class="keyword">int</span> Hour,Minute,Second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="公有成员public-member">公有成员（public member）</h4>
<p>公有成员在程序的<strong>任何地方</strong>都可以被访问，是类的<strong>对外接口</strong>。而且在类外只能访问类的公有成员（继承除外）。</p>
<p>一般来说，成员函数的访问权限设为公有的，类外通过公有成员函数来操纵该类对象的属性。</p>
<h4 id="私有成员private-member">私有成员（private member）</h4>
<p>私有成员<strong>只能</strong>被本类中的<strong>成员函数和友元</strong>访问，而不能被类外调用。所谓类外指的是普通函数或其他类的成员函数。</p>
<p>一般来说，数据成员的访问权限设为私有的或保护的（如果有继承关系时）。</p>
<h4 id="保护成员protected-member">保护成员（protected member）</h4>
<p>保护成员具有<strong>双重性</strong>，对其派生类而言，保护成员如同公有成员；对其他程序则表现得像私有成员。</p>
<p>一般来说，程序中有类继承时，可以将部分类成员定义为保护成员，以便派生类访问，同时，对类簇外又实现了信息隐藏。</p>
<h4 id="进一步细化">进一步细化</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;类名&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&lt;访问控制符&gt;:</span><br><span class="line">    &lt;成员函数的声明&gt;</span><br><span class="line">&lt;访问控制符&gt;:</span><br><span class="line">    &lt;数据成员的声明&gt;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;成员函数的实现&gt;</span><br></pre></td></tr></table></figure>
<p>类定义一般分为说明部分和实现部分。说明部分是说明该类中的成员，实现部分是对成员函数的定义。格式如下：</p>
<p><img src="image-20201127105530519.png" alt="image-20201127105530519" style="zoom:50%;" /></p>
<h3 id="数据成员">数据成员</h3>
<p>数据成员的声明看起来很像变量声明。但是，数据成员不能在类体中被显式地初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Hour=<span class="number">0</span>;     <span class="comment">// 错误</span></span><br><span class="line">    <span class="keyword">int</span> Minute=<span class="number">0</span>;   <span class="comment">// 错误</span></span><br><span class="line">    <span class="keyword">int</span> Second=<span class="number">0</span>;   <span class="comment">// 错误</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类的数据成员将通过<strong>构造函数</strong>进行初始化。</p>
<h3 id="成员函数">成员函数</h3>
<p>类的成员函数的声明与一般函数的声明一样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;函数值类型&gt;  &lt;函数名&gt;(&lt;参数表&gt;);</span><br></pre></td></tr></table></figure>
<p>参数表中可以只含参数类型而不含参数名</p>
<h3 id="成员函数的实现方式">成员函数的实现方式</h3>
<p>成员函数是类中描述行为的成员，同时也是对封装的数据进行操作的唯一途径。</p>
<p>成员函数的实现既可以在<strong>类中</strong>，也可以在<strong>类外</strong>。从类定义的格式可知，<strong>一般</strong>在类中声明成员函数，在类外具体实现成员函数。</p>
<p>如果成员函数已经在类中定义，则不需要在类外实现。需要注意的是，<strong>在类中定义的成员函数自动成为内联函数。</strong></p>
<h4 id="在类中实现成员函数">在类中实现成员函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>	//时间类的定义</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:	       <span class="comment">//外部接口，公有成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetTime</span><span class="params">(<span class="keyword">int</span> NewH, <span class="keyword">int</span> NewM, <span class="keyword">int</span> NewS)</span></span></span><br><span class="line"><span class="function">   </span>&#123;   Hour=NewH;</span><br><span class="line">       Minute=NewM;</span><br><span class="line">       Second=NewS; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">ShowTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;Hour&lt;&lt;<span class="string">":"</span>&lt;&lt;Minute&lt;&lt;<span class="string">":"</span>&lt;&lt;Second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">private</span>:	 <span class="comment">//私有数据成员</span></span><br><span class="line">   <span class="keyword">int</span> Hour,Minute,Second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="在类外实现成员函数">在类外实现成员函数</h4>
<p>若在类体外实现，则需要使用<strong>作用域运算符“::”</strong>，用它来<strong>标识</strong>某个成员函数是属于哪个类的，其定义格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;函数值类型&gt; &lt;类名&gt;::&lt;成员函数名&gt;(&lt;参数表&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    &lt;函数体&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然在类外定义成员函数，但它仍能访问类的任何成员。成员函数必须先在类内声明，而且类体必须在成员函数定义之前出现。</p>
<h4 id="时间类单文件">时间类（单文件）</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>   </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetTime</span><span class="params">(<span class="keyword">int</span> NewH,<span class="keyword">int</span> NewM,<span class="keyword">int</span> New S)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ShowTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> Hour,Minute,Second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时间类成员函数的实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time::SetTime</span><span class="params">(<span class="keyword">int</span> NewH,<span class="keyword">int</span> NewM,<span class="keyword">int</span> New S)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    Hour=NewH;       <span class="comment">//成员函数可直接访问私有成员</span></span><br><span class="line">    Minute=NewM;</span><br><span class="line">    Second=NewS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time::ShowTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Hour&lt;&lt;<span class="string">":"</span>&lt;&lt;Minute&lt;&lt;<span class="string">":"</span>&lt;&lt;Second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="时间类多文件">时间类（多文件）</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//time.h                //头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;	</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>	       //时间类的声明</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:	              <span class="comment">//外部接口，公有成员函数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetTime</span><span class="params">(<span class="keyword">int</span> NewH, <span class="keyword">int</span> NewM, <span class="keyword">int</span> NewS)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ShowTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:	       <span class="comment">//私有数据成员</span></span><br><span class="line">  <span class="keyword">int</span> Hour,Minute,Second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//time.cpp                //源程序文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"time.h"</span>	<span class="comment">//包含类的声明所在的头文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time::SetTime</span><span class="params">(<span class="keyword">int</span> NewH, <span class="keyword">int</span> NewM, <span class="keyword">int</span> NewS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Hour=NewH;       <span class="comment">//成员函数可直接访问私有成员</span></span><br><span class="line">   Minute=NewM;</span><br><span class="line">   Second=NewS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time::ShowTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;Hour&lt;&lt;<span class="string">":"</span>&lt;&lt;Minute&lt;&lt;<span class="string">":"</span>&lt;&lt;Second&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将类的声明和实现分别放在两个不同的文件中，这样做有以下几点好处： * 类的实现文件通常较大，分开便于阅读、管理和维护。 * 对软件开发商而言，他们可以向用户提供一些程序模块的接口，而不公开程序的源代码。分开管理就可以很好地解决此问题。 * 将类定义放在头文件中，以后使用不必再定义，只须一条包含命令即可，实现了代码重用。 * 便于团队对大型软件的分工合作开发。</p>
<h2 id="创建对象">创建对象</h2>
<p>对象的定义格式与普通变量相同。定义格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;类名&gt; &lt;对象名表&gt;;</span><br></pre></td></tr></table></figure>
<p><对象名表>中可以有一个或多个<strong>对象名</strong>。当有多个对象名时，用逗号分隔。<对象名表>中还可以是指向对象的<strong>指针名</strong>或<strong>引用名</strong>，也可以是<strong>对象数组名</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time time1,time2; <span class="comment">//声明对象time1,time2</span></span><br></pre></td></tr></table></figure>
<p>对象创建的另一种方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;类名&gt;&#123;</span>…&#125; &lt;对象名&gt;;</span><br></pre></td></tr></table></figure>
<p>在声明类的同时创建对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>&#123;</span>…&#125; time1,time2;</span><br></pre></td></tr></table></figure>
<p>对象的UML表示法</p>
<h2 id="类成员的访问">类成员的访问</h2>
<p>面向对象程序设计中，对类成员的访问往往通过<strong>接口</strong>（类的成员函数）实现。</p>
<p>在设计接口时，应注意为该类可以<strong>暴露</strong>给外界的信息提供接口，同时<strong>隐藏</strong>私密信息。</p>
<p>定义了类及其对象，就可以通过对象来使用其公有成员，从而达到对对象内部属性的访问和修改。</p>
<p><strong>在类中</strong>可<strong>直接</strong>使用成员名<strong>访问</strong>类成员，public、private和protected属性的成员都可以被访问。</p>
<p>类外访问对象中的成员可以有3种方法：</p>
<ul>
<li><p>通过对象名和成员运算符访问对象中的成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;对象名&gt;.&lt;公有成员&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>通过指向对象的指针变量访问对象中的成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;对象指针名&gt; -&gt; &lt;公有成员&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>通过对象的引用访问对象中的成员。</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Setxy</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; x &lt;&lt;“,”&lt;&lt; y &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1, a2; <span class="comment">//定义对象</span></span><br><span class="line">    a1.m = <span class="number">10</span>;</span><br><span class="line">    a1.n = <span class="number">20</span>;      <span class="comment">//为公有成员数据赋值</span></span><br><span class="line">    a1.Setxy(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">//为私有成员数据赋值</span></span><br><span class="line">    a1.Print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>,<span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>用成员运算符“.”只能访问对象的<strong>公有成员</strong>，而不能访问对象的私有成员或保护成员。</p>
<p>若要访问对象的私有的数据成员，<strong>只能通过对象的公有成员函数</strong>来获取。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Setxy</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="comment">//必须通过类内公有函数访问私有数据成员</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; x &lt;&lt;“,”&lt;&lt; y &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1, a2;</span><br><span class="line">    a1.m = <span class="number">10</span>;</span><br><span class="line">    a1.n = <span class="number">20</span>;          <span class="comment">//为公有成员数据赋值</span></span><br><span class="line">    a1.x = <span class="number">2</span>, a1.y = <span class="number">5</span>; <span class="comment">//非法，私有成员不能在类外访问</span></span><br><span class="line">    a1.Setxy(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    a1.Print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类作用域">类作用域</h3>
<p>类体的区域称为<strong>类作用域</strong>。类的成员函数与数据成员，其作用域都是属于类的作用域，仅在该类的范围内有效，<strong>故不能在主函数中直接通过函数名和成员名来调用</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">float</span> m, n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Setxy</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; x &lt;&lt;“,”&lt;&lt; y &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1, a2;</span><br><span class="line">    m = <span class="number">20</span>;</span><br><span class="line">    n = <span class="number">10</span>;</span><br><span class="line">    Setxy(<span class="number">2.0</span>, <span class="number">5.0</span>); <span class="comment">//不能直接调用</span></span><br><span class="line">    Print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间类-1">时间类</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Time time1;            <span class="comment">//声明对象time1</span></span><br><span class="line">    time1.SetTime(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);  <span class="comment">//通过对象time1访问公有成员函数</span></span><br><span class="line">    time1.ShowTime();      <span class="comment">//通过对象time1访问公有成员函数</span></span><br><span class="line">    Time time2;            <span class="comment">//声明对象time2</span></span><br><span class="line">    time2.SetTime(<span class="number">8</span>,<span class="number">30</span>,<span class="number">5</span>); <span class="comment">//通过对象time2访问公有成员函数</span></span><br><span class="line">    time2.ShowTime();      <span class="comment">//通过对象time2访问公有成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:0:0</span><br><span class="line">8:30:5</span><br></pre></td></tr></table></figure>
<p>在主函数的末尾加上一句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(time1)&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="keyword">sizeof</span>(time2);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:0:0</span><br><span class="line">8:30:5</span><br><span class="line">12</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<p>由此说明，各对象空间中<strong>只有数据成员</strong>，<strong>而无成员函数</strong>的空间。成员函数只存储一份，由对象共享。</p>
<h2 id="测试-1">测试</h2>
<p>找出程序中的错误，并改正。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_time</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show_time</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">int</span> hour;</span><br><span class="line">    <span class="keyword">int</span> minute;</span><br><span class="line">    <span class="keyword">int</span> sec;  		                     </span><br><span class="line">&#125;;</span><br><span class="line">Time t;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set_time();</span><br><span class="line">    show_time();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_time</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;   <span class="built_in">cin</span>&gt;&gt;t.hour;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t.minute;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t.sec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_time</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;t.hour&lt;&lt;“:”&lt;&lt;t.minute&lt;&lt;“:”&lt;&lt;t.sec&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用类和对象">使用类和对象</h1>
<h2 id="构造函数和析构函数">构造函数和析构函数</h2>
<p>当没有给数据成员赋值时，其运行结果是随机数。</p>
<p>不少难以察觉的程序错误是由于变量没有被正确初始化或清除造成的，而初始化和清除工作很容易被人遗忘。</p>
<p>C++语言充分考虑了这个问题并很好地予以解决：<strong>把对象的初始化工作放在构造函数中，把清除工作放在析构函数中</strong>。</p>
<p>当对象被创建时，构造函数被自动执行，当对象消亡前，析构函数被自动执行。</p>
<h3 id="构造函数">构造函数</h3>
<p>构造函数的功能是在定义对象时被编译系统自动调用来创建对象并初始化对象。</p>
<p>其定义格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;类名&gt;::&lt;类名&gt;(&lt;参数表&gt;)</span><br><span class="line">&#123;</span><br><span class="line">　　&lt;函数体&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数名<strong>与类名相同</strong>；<strong>没有</strong>函数值类型</p>
<h3 id="无参构造函数">无参构造函数</h3>
<p>之前的例子都没有定义构造函数，那么它们的对象是怎么创建的呢???</p>
<h4 id="默认的无参构造函数">默认的无参构造函数</h4>
<p>事实上，如果在类中没有显式定义构造函数，那么编译系统就会<strong>自动生成一个默认形式的构造函数</strong>，这个构造函数的功能仅用于创建对象。其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;类名&gt;::&lt;类名&gt;()&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>默认的构造函数并不对所产生对象的数据成员赋初值；即新产生对象的数据成员的值是不确定的。</strong></p>
<p>在定义类时，<strong>只要显式定义了一个类的构造函数，则编译器就不产生默认的构造函数</strong></p>
<p><strong>不存在没有构造函数的对象！</strong></p>
<h4 id="带参数的构造函数">带参数的构造函数</h4>
<p>一般格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;构造函数名&gt;（&lt;类型1&gt; &lt;形参1&gt;，&lt;类型2&gt; &lt;形参2&gt;，…）；</span><br></pre></td></tr></table></figure>
<p>则定义对象的格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;类名&gt; &lt;对象名&gt;（&lt;实参1&gt;，&lt;实参2&gt;，…）；</span><br></pre></td></tr></table></figure>
<p>将无参构造函数Time()与SetTime(…)合二为一，形成带参构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time(<span class="keyword">int</span> NewH, <span class="keyword">int</span> NewM, <span class="keyword">int</span> NewS);      </span><br><span class="line"><span class="comment">//带参构造函数的声明</span></span><br><span class="line">Time::Time(<span class="keyword">int</span> NewH, <span class="keyword">int</span> NewM, <span class="keyword">int</span> NewS)     <span class="comment">//带参构造函数的实现</span></span><br><span class="line">&#123;</span><br><span class="line">	Hour=NewH;</span><br><span class="line">	Minute=NewM;</span><br><span class="line">	Second=NewS;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"构造函数被调用！"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类的数据成员的初始化">类的数据成员的初始化</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Box::Box(<span class="keyword">int</span> h,<span class="keyword">int</span> w,<span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">   height=h;</span><br><span class="line">   width=w;<span class="comment">//数据成员在构造函数体内被初始化</span></span><br><span class="line">   legth=len;</span><br><span class="line">&#125;</span><br><span class="line">Box::Box(<span class="keyword">int</span> h,<span class="keyword">int</span> w,<span class="keyword">int</span> len)</span><br><span class="line">:height(h),width(w),length(len)<span class="comment">//构造函数成员（参数）初始化表</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="带默认参数的构造函数">带默认参数的构造函数</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Box(<span class="keyword">int</span> w=<span class="number">10</span>,<span class="keyword">int</span> h=<span class="number">10</span>,<span class="keyword">int</span> len=<span class="number">10</span>); </span><br><span class="line">Box::Box(<span class="keyword">int</span> w,<span class="keyword">int</span> h,<span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    height=h;</span><br><span class="line">    width=w;</span><br><span class="line">    length=len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在声明构造函数时，形参名可以省略</p>
<p>带默认参数的构造函数和重载构造函数同时使用时，要注意二义性问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a=<span class="number">3</span>,<span class="keyword">int</span> b=<span class="number">2</span>)&#123;x=a;	y=b;	&#125;</span><br><span class="line">    A( )&#123; x=<span class="number">0</span>; y=<span class="number">0</span>; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">( )</span></span>&#123;	<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;“,”&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>：<span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="function">A  <span class="title">a2</span><span class="params">(<span class="number">7</span>,<span class="number">5</span>)</span></span>; </span><br><span class="line">    A  a1;<span class="comment">//两个构造函数均可供调用，构造函数不唯一，编译错误</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数的特点">构造函数的特点</h3>
<ol type="1">
<li>构造函数是成员函数，函数体可写在类中，也可写在类外。</li>
<li>构造函数的名字<strong>必须</strong>与类名同名，而不能由用户任意命名。</li>
<li>构造函数<strong>不能</strong>指定函数值类型，甚至void也不行。</li>
<li>构造函数可以没有参数，也可以有参数，允许重载，即可以定义参数不同的多个构造函数。</li>
<li>每个类都必须有一个构造函数，且是公有成员。如果用户自己没有定义构造函数，则C++系统会自动生成一个构造函数，只是这个构造函数没有参数，函数体也是空的，不执行初始化操作。</li>
<li>在定义类对象时，构造函数由系统自动调用，而不是像其他成员函数一样，由用户显式调用。</li>
</ol>
<h3 id="析构函数">析构函数</h3>
<p>析构函数的功能是在对象的生存期即将结束的时刻，由编译系统自动调用来完成一些<strong>清理</strong>工作。</p>
<p>析构函数也是类的一个公有成员函数，它的名称是由类名前面加“~”构成，也<strong>不指定返回值类型</strong>。</p>
<p>其定义格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;类名&gt;::~&lt;类名&gt;()</span><br><span class="line">&#123;</span><br><span class="line">　　&lt;函数体&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">~Box();        <span class="comment">//析构函数的声明</span></span><br><span class="line">Box::~Box()  <span class="comment">//析构函数的实现</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;“This is destructor!”&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有定义析构函数，同构造函数一样，编译系统会提供默认形式的析构函数：</p>
<p><类名>::~<类名>(){}</p>
<h3 id="析构函数的特点">析构函数的特点</h3>
<p>析构函数是成员函数，函数体可写在类体内，也可以写在类体外。</p>
<p>析构函数的<strong>函数名与类名相同</strong>，并在前面加“~”字符，用来与构造函数加以区别。析构函数<strong>不指定返回值类型</strong>。</p>
<p>析构函数<strong>没有参数</strong>，因此<strong>不能重载</strong>。一个类中只能定义一个析构函数。</p>
<p>每个类都<strong>必须有一个</strong>析构函数。如果类中没有显式定义析构函数，则编译系统自动生成一个<strong>默认</strong>形式的析构函数，作为该类的公有成员。</p>
<p>析构函数在对象生存期结束前由编译系统自动调用。</p>
<h3 id="构造函数和析构函数的调用顺序">构造函数和析构函数的调用顺序</h3>
<p>在一般情况下，调用构造函数与声明对象的顺序相同，而调用析构函数的次序正好与创建对象的顺序相反。</p>
<p><img src="image-20201206215738802.png" alt="image-20201206215738802" style="zoom:50%;" /></p>
<p>### 构造函数析构函数的调用时机</p>
<p><strong>全局对象</strong>的构造函数在文件中的所有函数（包括main函数）执行之前调用。当main函数执行完毕或调用exit函数时，调用析构函数。</p>
<p><strong>局部自动对象</strong>在建立对象时调用构造函数。在函数调用结束、对象释放时先调用析构函数。</p>
<p>函数中的<strong>静态局部对象</strong>，在第一次调用此函数建立对象时调用一次构造函数，在调用结束时对象并不释放，因此也不调用析构函数， 只在main函数执行完毕或调用exit函数时，调用析构函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Student stud1;<span class="comment">//定义自动局部对象</span></span><br><span class="line"><span class="keyword">static</span> Student stud2;<span class="comment">//定义静态局部对象</span></span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数调用顺序为：stud1的构造函数，stud2的构造函数，stud1的析构函数，stud2的析构函数。</p>
<h3 id="复制拷贝构造函数">复制（拷贝）构造函数</h3>
<p>生成一个对象的副本有两种途径：对象的赋值和复制。</p>
<p><strong>对象的赋值</strong>（同类对象）</p>
<p><对象1> = <对象2>;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Setxy</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">","</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="string">","</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1, a2;</span><br><span class="line">    a1.m = <span class="number">10</span>;</span><br><span class="line">    a1.n = <span class="number">20</span>; <span class="comment">//为公有成员数据赋值</span></span><br><span class="line">    a1.Setxy(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    a2 = a1; <span class="comment">//同类型的对象之间可以整体赋值，与对象中成员的访问权限无关</span></span><br><span class="line">    a1.Print();</span><br><span class="line">    a2.Print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2,5</span><br><span class="line">10,20</span><br><span class="line">2,5</span><br><span class="line">10,20</span><br></pre></td></tr></table></figure>
<p>相当于数据成员间相互赋值</p>
<p><strong>对象的复制</strong></p>
<p><类名> <对象2>(<对象1>); <类名> <对象2>=<对象1>;</p>
<p>对象赋值与对象复制的不同</p>
<ul>
<li>对象的赋值是对一个已经存在的对象赋值，因此必须先定义被赋值的对象，才能进行赋值。</li>
<li>对象的复制是从无到有地建立一个新对象，并使它与一个已有的对象完全相同。</li>
<li>用一个类对象初始化该类的另一个对象被称为<strong>默认按成员初始化</strong>。</li>
<li>类的设计者也可以通过提供特殊的<strong>复制构造函数</strong>（copy constructor）来改变默认的行为。</li>
<li>复制构造函数是一种特殊的构造函数，它的功能是<strong>用一个已知的对象</strong>来<strong>初始化</strong>一个被定义的<strong>同类的对象</strong>。</li>
</ul>
<p>复制构造函数的定义格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class &lt;类名&gt;</span><br><span class="line">&#123;</span><br><span class="line">public：</span><br><span class="line">    &lt;类名&gt;(&lt;参数表&gt;);　          　　&#x2F;&#x2F;构造函数</span><br><span class="line">    &lt;类名&gt;(const &lt;类名&gt;&amp; &lt;对象名&gt;);  &#x2F;&#x2F;复制构造函数的声明</span><br><span class="line">…</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;类名&gt;::&lt;类名&gt;(const &lt;类名&gt;&amp; &lt;对象名&gt;)</span><br><span class="line">                                &#x2F;&#x2F;复制构造函数的实现</span><br><span class="line">&#123;</span><br><span class="line">    &lt;函数体&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果程序员没有显式定义复制构造函数，编译系统就会自动生成一个默认形式的复制构造函数</p>
<p>其功能是创建新对象把已知对象的每个数据成员的值都复制到新创建的对象中，而不做其他处理。其格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;类名&gt;::&lt;类名&gt;( const &lt;类名&gt;&amp; &lt;对象名&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    …  &#x2F;&#x2F;把已知对象的每个数据成员的值都</span><br><span class="line">        &#x2F;&#x2F;复制到新创建的对象中，而不做其他处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三种构造函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Box();            &#x2F;&#x2F;无参构造函数</span><br><span class="line">Box(int h,int w ,int len):height(h),width(w),length(len)&#123;&#125;&#x2F;&#x2F;带参构造函数</span><br><span class="line">Box(const Box&amp; b);&#x2F;&#x2F;复制构造函数</span><br></pre></td></tr></table></figure>
<h3 id="复制构造函数与普通构造函数的区别">复制构造函数与普通构造函数的区别</h3>
<p>形式上不同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;类名&gt;(&lt;参数表&gt;);　          　　</span><br><span class="line">&lt;类名&gt;(const &lt;类名&gt;&amp; &lt;对象名&gt;);</span><br></pre></td></tr></table></figure>
<p>在建立对象时，实参类型不同</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Box box1(15,30,25);&#x2F;&#x2F;实参为整数</span><br><span class="line">Box box2(box1);&#x2F;&#x2F;实参是对象名</span><br></pre></td></tr></table></figure>
<p>被调用的情况不同</p>
<ul>
<li>普通构造函数在程序中创建对象时被调用</li>
<li>复制构造函数在用已有对象复制一个新对象时被调用，在以下3种情况下需要复制对象</li>
</ul>
<p>程序中需要新建立一个对象，并用另一个同类的对象对它初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Box <span class="title">box1</span><span class="params">(<span class="number">15</span>,<span class="number">30</span>,<span class="number">25</span>)</span></span>;</span><br><span class="line">Box box2=box1;或<span class="function">Box <span class="title">box2</span><span class="params">(box1)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当函数的参数为类对象时，在调用函数时需要将实参对象完整地传递给形参：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Box b)</span> <span class="comment">//形参是类的对象</span></span></span><br><span class="line"><span class="function"></span>&#123; … &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Box <span class="title">box1</span><span class="params">(<span class="number">12</span>,<span class="number">15</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">    fun(box1);           </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当函数的返回值是类的对象，在函数调用完毕将返回值带回函数调用处时：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Box <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="function">Box <span class="title">box1</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> box1; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Box box2;</span><br><span class="line">    box2=f(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复制构造函数的特点">复制构造函数的特点</h3>
<p>复制构造函数是成员函数，函数体可写在类中，也可以写在类外。</p>
<p>复制构造函数名与类名相同，并且也不指定函数值类型。</p>
<p>复制构造函数<strong>只有一个参数</strong>，并且<strong>是对同类对象的引用</strong>。</p>
<p>每个类都必须有一个复制构造函数。如果类中没有显式定义复制构造函数，则编译系统自动生成一个默认形式的复制构造函数，作为该类的公有成员。</p>
<h2 id="对象间的数据共享">对象间的数据共享</h2>
<p>静态成员是C++提供的解决同一个类的不同对象之间数据和函数共享问题的机制。</p>
<p>类的静态成员分为静态数据成员和静态成员函数。</p>
<h3 id="类的非静态数据成员">类的非静态数据成员</h3>
<p>一个类的所有对象具有相同的属性是指属性的个数、名称、数据类型相同，各个对象的属性值则可以各不相同。</p>
<p>这样的属性在面向对象方法中称为“<strong>实例属性</strong>”，在C++程序中以类的<strong>非静态数据成员</strong>表示。</p>
<h3 id="类的静态数据成员">类的静态数据成员</h3>
<p>面向对象方法中还有“<strong>类属性</strong>”的概念。如果某个属性为整个类所共有，不属于任何一个具体对象，则采用static关键字来声明为<strong>静态成员</strong>。</p>
<p><strong>静态成员</strong>是类的所有对象共享的成员，而不是某个对象的成员，它<strong>在对象中不占存储空间</strong>，是<strong>属于整个类的成员</strong>。</p>
<p>静态数据成员不随对象的建立而分配空间，也不随对象的撤销而释放。它是在程序编译时分配空间，到程序结束时才释放空间。</p>
<h3 id="静态成员的定义">静态成员的定义</h3>
<p>定义格式如下：</p>
<p>static　<静态成员的定义>;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> x,y;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> z;</span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Setxy</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;x=a; y=b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">A a1, a2;</span><br></pre></td></tr></table></figure>
<h3 id="静态数据成员">静态数据成员</h3>
<p>静态数据成员是在所有对象之外单独开辟空间。</p>
<p>只要在类中定义了静态数据成员，即使不定义对象，也为静态数据成员分配空间，它可以被访问。</p>
<p>在一个类中可以有一个或多个静态数据成员，所有的对象共享这些静态数据成员，都可以访问它。</p>
<h3 id="静态数据成员的初始化">静态数据成员的初始化</h3>
<p><strong>不能</strong>用参数初始化表对静态数据成员初始化，<strong>也不能</strong>在构造函数体内初始化，静态数据成员<strong>只能</strong>在<strong>类体外</strong>进行初始化。</p>
<p>静态数据成员初始化格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;数据类型&gt; &lt;类名&gt;::&lt;静态数据成员名&gt;&#x3D;&lt;值&gt;;</span><br></pre></td></tr></table></figure>
<p>不能在初始化语句中加static</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x, y; <span class="comment">//定义静态成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>, <span class="keyword">int</span> c = <span class="number">0</span>, <span class="keyword">int</span> d = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i = a;</span><br><span class="line">        j = b;</span><br><span class="line">        x = c;</span><br><span class="line">        y = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"i ="</span> &lt;&lt; i &lt;&lt; <span class="string">","</span></span><br><span class="line">             &lt;&lt; <span class="string">"j="</span> &lt;&lt; j &lt;&lt; <span class="string">","</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"x="</span> &lt;&lt; x &lt;&lt; <span class="string">","</span></span><br><span class="line">             &lt;&lt; <span class="string">"y="</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> A::x = <span class="number">0</span>; <span class="comment">//给静态数据成员分配空间和初始化</span></span><br><span class="line"><span class="keyword">int</span> A::y = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    a.Show();</span><br><span class="line">    <span class="function">A <span class="title">b</span><span class="params">(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>)</span></span>;</span><br><span class="line">    b.Show();</span><br><span class="line">    a.Show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i&#x3D;2,j&#x3D;3,x&#x3D;4,y&#x3D;5</span><br><span class="line">i&#x3D;100,j&#x3D;200,x&#x3D;300,y&#x3D;400</span><br><span class="line">i&#x3D;2,j&#x3D;3,x&#x3D;300,y&#x3D;400</span><br></pre></td></tr></table></figure>
<h3 id="静态数据成员的使用">静态数据成员的使用</h3>
<p>在类的成员函数中可以<strong>直接</strong>访问该类的静态数据成员，而不必使用成员访问运算符或作用域运算符。</p>
<p>在类外<strong>必须</strong>使用成员访问运算符或作用域运算符访问<strong>公有</strong>静态数据成员。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;对象名&gt;.&lt;静态数据成员&gt;</span><br><span class="line">&lt;类名&gt;::&lt;静态数据成员&gt;</span><br></pre></td></tr></table></figure>
<p>静态数据成员与全局变量一样都是静态分配存储空间的，<strong>但全局变量在程序中的任何位置都可以访问它，而静态数据成员受到访问权限的约束。必须是public权限时，才可能在类外进行访问。</strong></p>
<p>公有静态数据成员的作用域只限于定义该类的作用域内。在此作用域内，可以通过类名和作用域运算符访问静态数据成员，而不论类对象是否存在。</p>
<h3 id="静态成员函数">静态成员函数</h3>
<p>静态成员函数就是使用<strong>static</strong>关键字声明的成员函数。</p>
<p>和静态数据成员一样，静态成员函数是类的一部分，而不是对象的一部分。</p>
<p>静态成员函数的作用是为了能处理静态数据成员。</p>
<p>静态成员函数没有this 指针。</p>
<p>静态成员函数可以<strong>直接访问</strong>该类的静态成员，但<strong>不能直接访问</strong>类中的<strong>非</strong>静态成员。</p>
<p>如果静态成员函数中要使用非静态成员时，必须通过参数传递方式得到对象名，然后可以通过对象名来访问非静态成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b; <span class="comment">//静态数据成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tc(<span class="keyword">int</span> c)</span><br><span class="line">    &#123;</span><br><span class="line">        a = c;</span><br><span class="line">        b += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Tc C)</span> <span class="comment">//Tc的对象为形参</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; C.a &lt;&lt; <span class="string">",b="</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="comment">// C.a非静态成员，用对象名来引用，b静态成员，直接引用</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Tc::b = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tc A(2), B(4);</span><br><span class="line">    Tc::display(A);<span class="comment">//直接用类名来调用静态成员函数</span></span><br><span class="line">    Tc::display(B);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;2,b&#x3D;8</span><br><span class="line">a&#x3D;4,b&#x3D;8</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tc</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b; <span class="comment">//静态数据成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Tc(<span class="keyword">int</span> c)</span><br><span class="line">    &#123;</span><br><span class="line">        a = c;</span><br><span class="line">        b += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Tc C)</span></span>; <span class="comment">//Tc的对象为形参</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tc::display</span><span class="params">(Tc C)</span> <span class="comment">//不用static修饰</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; C.a &lt;&lt; <span class="string">",b="</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Tc::b = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tc A(2), B(4);</span><br><span class="line">    Tc::display(A);</span><br><span class="line">    Tc::display(B);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象指针">对象指针</h2>
<p>与基本数据类型的变量一样，每一个对象在创建之后都会在内存中占有一定的空间。</p>
<p>因此，既可以通过对象名访问对象，也可以通过对象的起始地址来访问一个对象，即对象指针。</p>
<p>对象指针就是用于存放对象数据起始地址的变量。</p>
<p>声明对象指针的一般格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;类名&gt;  *&lt;对象指针名&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="对象指针的初始化">对象指针的初始化</h3>
<p>一般格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;类名&gt; *&lt;对象指针名&gt;&#x3D;&amp;&lt;对象名&gt;;</span><br><span class="line">&lt;对象指针名&gt;&#x3D;&amp;&lt;对象名&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="通过指针访问对象成员">通过指针访问对象成员</h3>
<p>一般格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;对象指针名&gt; -&gt; &lt;公有成员&gt; </span><br><span class="line">boxp-&gt;volumn();</span><br><span class="line">(*&lt;对象指针名&gt;).&lt;公有成员&gt;</span><br><span class="line">(*boxp).volumn();</span><br></pre></td></tr></table></figure>
<p>通过对象指针访问学生类的成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Student s1;                    <span class="comment">//定义Student类的对象s1</span></span><br><span class="line">s1.input(<span class="number">1</span>, <span class="string">"Zhang Hua"</span>, <span class="number">95</span>);  <span class="comment">//通过s1访问公有成员函数</span></span><br><span class="line">s1.display();                  <span class="comment">//通过对象访问公有成员函数</span></span><br><span class="line">Student *pstu = &amp;s1;           <span class="comment">//定义Student类的对象指针pstu,并指向对象s1</span></span><br><span class="line">pstu-&gt;input(<span class="number">2</span>, <span class="string">"Wang Li"</span>, <span class="number">90</span>); <span class="comment">//通过指针访问公有成员函数</span></span><br><span class="line">pstu-&gt;display();               <span class="comment">//通过指针访问公有成员函数</span></span><br><span class="line">(*pstu).modify(<span class="number">85</span>);</span><br><span class="line">(*pstu).display();</span><br></pre></td></tr></table></figure>
<h3 id="动态对象">动态对象</h3>
<p>用new运算符创建动态对象的一般格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new &lt;类名&gt;;</span><br><span class="line">new &lt;类名&gt;(&lt;初值列表&gt;);</span><br></pre></td></tr></table></figure>
<p>用delete运算符删除new建立的对象，释放指针所指向的内存空间。使用格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete &lt;指向对象的指针变量名&gt;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Box *pbox1 &#x3D; new Box; &#x2F;&#x2F;定义指向Box对象的指针变量pbox1</span><br><span class="line">    cout &lt;&lt; &quot;The volume of box1 is &quot; &lt;&lt; pbox1-&gt;volume() &lt;&lt; endl;</span><br><span class="line">    delete pbox1;                     &#x2F;&#x2F;释放pbox1指向的对象空间</span><br><span class="line">    Box *pbox2 &#x3D; new Box(15, 30, 25); &#x2F;&#x2F;定义指向Box对象的指针变量pbox2，</span><br><span class="line">                                      &#x2F;&#x2F;在pbox2中存放对象的起始地址并初始化对象</span><br><span class="line">    cout &lt;&lt; &quot;The volume of box2 is &quot; &lt;&lt; pbox2-&gt;volume() &lt;&lt; endl;</span><br><span class="line">    &#x2F;&#x2F;指针访问成员</span><br><span class="line">    delete pbox2; &#x2F;&#x2F;释放pbox2指向的对象空间</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="this指针">this指针</h3>
<p>this指针是一个特殊的<strong>隐含</strong>指针，它隐含于每一个成员函数（静态成员函数除外）中，也就是说，<strong>每个成员函数都有一个this指针参数</strong>。</p>
<p>this指针指向调用该函数的对象，即this指针的值是<strong>当前被调用的成员函数所在的对象的起始地址</strong>。</p>
<p>当一个对象调用成员函数时，编译系统先将<strong>对象的地址赋给this指针</strong>，然后调用成员函数，每次成员函数存取数据成员时，则隐含使用this指针。</p>
<p>通常不显式地使用this指针来调用数据成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Box a(15, 18, 20), b(16, 20, 26);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"volume of a is "</span> &lt;&lt; a.volume() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"volume of b is "</span> &lt;&lt; b.volume() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Box::volume</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (height * width * length);<span class="comment">//隐含使用this指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Box::volume</span><span class="params">(Box *<span class="keyword">this</span>)</span><span class="comment">//在实际编程时，函数的声明中并没有包含这个参数。编译器会把该对象的地址加入到参数列表中。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;height) * (<span class="keyword">this</span>-&gt;width) * (<span class="keyword">this</span>-&gt;length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制构造函数中隐含使用this指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TAdd(<span class="keyword">const</span> TAdd&amp; p) </span><br><span class="line">&#123;  <span class="comment">/* this-&gt;*/</span>x=p.x; <span class="comment">/*this-&gt;*/</span>y=p.y;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"copy constructor."</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数中显式使用this指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TAdd(<span class="keyword">int</span> x,<span class="keyword">int</span> y) </span><br><span class="line">&#123;   <span class="keyword">this</span>-&gt;x=x; <span class="keyword">this</span>-&gt;y=y;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"constructor."</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>this指针一般用于返回当前对象自身。</p>
<p>同样也可以使用*<strong>this</strong>来标识调用该成员函数的当前对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x	this-&gt;x	(*this).x</span><br></pre></td></tr></table></figure>
<p>this指针是一个const指针，成员函数不能对其进行赋值。</p>
<p>静态成员中不能访问this指针，因为静态成员函数不从属于任何对象。</p>
<p>this指针的另一种用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Student::copy_stud(const Student &amp; stu)</span><br><span class="line">&#123;</span><br><span class="line">   if(this!&#x3D;&amp;stu) &#x2F;&#x2F;this指针中含有被调用的类对象的地址</span><br><span class="line">&#123;…         &#x2F;&#x2F;把stu的值复制到*this中</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###　成员指针</p>
<p>类的成员可能是一些变量、函数或者对象等，因此可以将它们的地址存放到一个指针变量中。这样，就可以使指针直接指向对象的成员，进而可以通过这些指针访问对象的成员。</p>
<p>这样的指针称为<strong>成员指针</strong>，或者说是指向对象的成员的指针变量。</p>
<h3 id="指向非静态数据成员的指针">指向非静态数据成员的指针</h3>
<p>定义指向对象数据成员的指针变量的方法和定义指向普通变量的指针变量方法相同。</p>
<p>一般形式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据类型名  *指针变量名；</span><br></pre></td></tr></table></figure>
<h3 id="指向非静态成员函数的指针">指向非静态成员函数的指针</h3>
<p>定义指向公有成员函数的指针变量的一般形式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数据类型名 (类名:: *指针变量名)(参数列表)；</span><br></pre></td></tr></table></figure>
<p>使指针变量指向一个公有成员函数的一般形式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指针变量名&#x3D;&amp;类名::成员函数名 &#x2F;&#x2F;&amp;可省略</span><br></pre></td></tr></table></figure>
<p>通过成员函数指针、对象指针、对象访问公有成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> xx=<span class="number">0</span>,<span class="keyword">int</span> yy=<span class="number">0</span>)</span><br><span class="line">     &#123; X=xx; Y=yy; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> X;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetY</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> Y;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> X,Y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Point <span class="title">A</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>)</span></span>;<span class="comment">//声明对象A</span></span><br><span class="line">Point *p1=&amp;A;</span><br><span class="line">      <span class="comment">//声明对象指针并初始化</span></span><br><span class="line"><span class="keyword">int</span> (Point::*pGetX)()= Point::GetX;</span><br><span class="line">      <span class="comment">//声明成员函数指针并初始化</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(A.*pGetX)()&lt;&lt; <span class="string">'\t'</span>;</span><br><span class="line">      <span class="comment">//使用成员函数指针访问成员函数</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(p1-&gt;GetX)()&lt;&lt; <span class="string">'\t'</span>;</span><br><span class="line">      <span class="comment">//使用对象指针访问成员函数</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;A.GetX()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="comment">//使用对象名访问成员函数</span></span><br></pre></td></tr></table></figure>
<h3 id="指向类的静态成员的指针">指向类的静态成员的指针</h3>
<p>对类的静态成员的访问是不依赖于对象的，因此可以用普通的指针来指向和访问静态成员。</p>
<p>【例】通过指针访问类的静态数据成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> xx = <span class="number">0</span>, <span class="keyword">int</span> yy = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        X = xx;</span><br><span class="line">        Y = yy;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;                      <span class="comment">//构造函数</span></span><br><span class="line">    Point(<span class="keyword">const</span> Point &amp;p); <span class="comment">//复制构造函数的声明</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> X; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Y; &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count; <span class="comment">//静态数据成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> X, Y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Point::count = <span class="number">0</span>; <span class="comment">//静态数据成员的初始化</span></span><br><span class="line">Point::Point(<span class="keyword">const</span> Point &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    X = p.X;</span><br><span class="line">    Y = p.Y;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *countp = &amp;Point::count;</span><br><span class="line">    <span class="comment">//声明一个int型指针，指向类的//静态成员</span></span><br><span class="line">    <span class="function">Point <span class="title">A</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Point A: "</span> &lt;&lt; A.GetX() &lt;&lt; <span class="string">","</span> &lt;&lt; A.GetY();</span><br><span class="line">    <span class="comment">//通过对象访问成员函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" Object id= "</span> &lt;&lt; *countp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//通过指针访问静态数据成员</span></span><br><span class="line">    <span class="function">Point <span class="title">B</span><span class="params">(A)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Point B: "</span> &lt;&lt; B.GetX() &lt;&lt; <span class="string">","</span> &lt;&lt; B.GetY();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" Object id= "</span> &lt;&lt; *countp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Point A：4,5 Object id&#x3D;1</span><br><span class="line">Point B：4,5 Object id&#x3D;2</span><br></pre></td></tr></table></figure>
<p>【例】定义函数指针访问类的静态成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> xx = <span class="number">0</span>, <span class="keyword">int</span> yy = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        X = xx;</span><br><span class="line">        Y = yy;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;                      <span class="comment">//构造函数</span></span><br><span class="line">    Point(<span class="keyword">const</span> Point &amp;p); <span class="comment">//复制构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> X; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetC</span><span class="params">()</span> <span class="comment">//静态成员函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object id="</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> X, Y;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count; <span class="comment">//静态数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line">Point::Point(<span class="keyword">const</span> Point &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    X = p.X;</span><br><span class="line">    Y = p.Y;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Point::count = <span class="number">0</span>; <span class="comment">//静态数据成员  //的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (*gc)() = Point::GetC;</span><br><span class="line">    <span class="comment">//声明一个指向函数的指针，指向类的 //静态成员函数</span></span><br><span class="line">    <span class="function">Point <span class="title">A</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>)</span></span>; <span class="comment">//声明对象A</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Point A: "</span> &lt;&lt; A.GetX() &lt;&lt; <span class="string">","</span> &lt;&lt; A.GetY();</span><br><span class="line">    (*gc)();    <span class="comment">//通过指针访问静态成员函数</span></span><br><span class="line">    <span class="function">Point <span class="title">B</span><span class="params">(A)</span></span>; <span class="comment">//声明对象B</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Point B: "</span> &lt;&lt; B.GetX() &lt;&lt; <span class="string">","</span> &lt;&lt; B.GetY();</span><br><span class="line">    gc(); <span class="comment">//通过指针访问静态成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象引用">对象引用</h3>
<p>引用（Reference）是某个变量（对象）的别名（alias）。</p>
<p>指针通过地址间接访问对象，而引用是直接访问对象。</p>
<p>【例】示例对象的引用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time myTime;</span><br><span class="line">Time &amp;refTime=myTime; <span class="comment">//声明引用时必须初始化为一个对象</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"First Time set and output:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">refTime.SetTime(<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span>); </span><br><span class="line">refTime.ShowTime(); </span><br><span class="line">myTime.ShowTime();</span><br></pre></td></tr></table></figure>
<p>如果实参是对象，那么“通过值来传递一个对象”的具体含义是由这个对象的复制构造函数定义的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Student <span class="title">returnS</span><span class="params">(Student s)</span></span>&#123;<span class="keyword">return</span> s;&#125;</span><br><span class="line">Student stu1;</span><br><span class="line">stu1.returnS(stu1);</span><br></pre></td></tr></table></figure>
<p>避免通过值来传递对象，而是通过引用来传递。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Student&amp; <span class="title">returnS</span><span class="params">(Student&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> s;&#125;</span><br></pre></td></tr></table></figure>
<p>参数传递的是引用，没有构造函数或析构函数被调用，节约了系统资源，提高了运行效率。</p>
<h2 id="共享数据的保护">共享数据的保护</h2>
<p>常量定义格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &lt;数据类型名&gt; &lt;常量名&gt;&#x3D;&lt;表达式&gt;;</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const float PI;			</span><br><span class="line">PI&#x3D;3.1415926;　　　　　&#x2F;&#x2F;错误,常量在程序运行过程中不允许改变，因此在定义时必须初始化。</span><br></pre></td></tr></table></figure>
<h3 id="常对象">常对象</h3>
<p>常对象是其<strong>数据成员值</strong>在对象的整个生存期间内<strong>不能被改变</strong>的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const  &lt;类名&gt;　&lt;对象名&gt;(&lt;初始化值&gt;);</span><br><span class="line"></span><br><span class="line">&lt;类名&gt; const &lt;对象名&gt;(&lt;初始化值&gt;);</span><br></pre></td></tr></table></figure>
<p>常对象的所有数据成员都是常量，不能改变。因此，常对象必须初始化。</p>
<p><strong>不能</strong>通过常对象调用普通的成员函数，可以调用常成员函数。</p>
<p>如果要修改常对象中某个数据成员的值，可以将数据成员声明为<strong>mutable</strong>，这样就可以用声明为const的成员函数来修改它的值。</p>
<h3 id="类的常成员">类的常成员</h3>
<p>类的数据成员和成员函数可以声明为const，分别为常数据成员和常成员函数。</p>
<h4 id="常数据成员">常数据成员</h4>
<p>在任何函数中都不能对常数据成员赋值。</p>
<p><strong>只能</strong>通过构造函数的参数初始化表对常数据成员进行初始化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int Hour;</span><br><span class="line">Time::Time(int h):Hour(h)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>类的所有对象中的常数据成员的值均不能改变，但不同对象中的该数据成员的值可以不同（在定义对象时给出）。</p>
<p>【例】示例常数据成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> i);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;        <span class="comment">//非静态常数据成员</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> b; <span class="comment">//静态常数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> A::b = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//静态常数据成员在类外初始化</span></span><br><span class="line">A::A(<span class="keyword">int</span> i) : a(i)</span><br><span class="line"><span class="comment">//非静态常数据成员只能通过初始化表来获得初值</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt;”:”&lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1(100), a2(0);</span><br><span class="line">    <span class="comment">//定义并初始化对象a1和a2</span></span><br><span class="line">    a1.print();</span><br><span class="line">    a2.print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100:10</span><br><span class="line">0:10</span><br></pre></td></tr></table></figure>
<h4 id="常成员函数">常成员函数</h4>
<p>通过常成员函数来引用本类中的数据成员，但不能修改它们。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;数据类型&gt;&lt;函数名&gt;(&lt;参数表&gt;)const;</span><br></pre></td></tr></table></figure>
<p>const是函数类型的一部分，在声明函数和定义函数时都要有const，在调用时不必加const。</p>
<p>常成员函数<strong>不能更新</strong>对象的数据成员，也<strong>不能调用</strong>该类中的<strong>非const成员函数</strong>。</p>
<p>通过常对象只能调用它的常成员函数，而不能调用其他成员函数。</p>
<p>常对象中的成员函数不是常成员函数，除非成员函数有const修饰。</p>
<p>const关键字可以用于对重载函数的区分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">R</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    R(<span class="keyword">int</span> r1, <span class="keyword">int</span> r2)</span><br><span class="line">    &#123;</span><br><span class="line">        R1 = r1;</span><br><span class="line">        R2 = r2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> R1, R2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; R1 &lt;&lt; <span class="string">"-"</span> &lt;&lt; R2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R::print</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; R1 &lt;&lt; <span class="string">"+"</span> &lt;&lt; R2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">a</span><span class="params">(<span class="number">5</span>, <span class="number">4</span>)</span></span>;         <span class="comment">//声明普通对象a</span></span><br><span class="line">    a.print();         <span class="comment">//普通对象a调用普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> R <span class="title">b</span><span class="params">(<span class="number">20</span>, <span class="number">52</span>)</span></span>; <span class="comment">//常对象b</span></span><br><span class="line">    b.print();         <span class="comment">//常对象b调用常成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5-4</span><br><span class="line">20+52</span><br></pre></td></tr></table></figure>
<h3 id="const成员和非const成员之间的调用关系">const成员和非const成员之间的调用关系</h3>
<table>
<thead>
<tr class="header">
<th>数据成员</th>
<th>非const成员函数</th>
<th>const成员函数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>非const数据成员</td>
<td>可以引用，也可以改变值</td>
<td>可以引用，但不可以改变值</td>
</tr>
<tr class="even">
<td>const数据成员</td>
<td>可以引用，但不可以改变值</td>
<td>可以引用，但不可以改变值</td>
</tr>
<tr class="odd">
<td>const对象的数据成员</td>
<td>不允许引用和改变值</td>
<td>可以引用，但不可以改变值</td>
</tr>
</tbody>
</table>
<h3 id="const与指针">const与指针</h3>
<p>指向对象的<strong>常指针</strong>：指针变量声明为const型并初始化，指针本身的值不能改变，即<strong>其指向不能改变</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类名 * const 指针变量名&#x3D;对象地址</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time t1(10,12,15),t2;</span><br><span class="line">Time *<span class="keyword">const</span> ptr1=&amp;t1;<span class="comment">//ptr1是指向t1对象的常指针</span></span><br><span class="line">ptr1=&amp;t2;   <span class="comment">//错误，ptr1不能改变指向</span></span><br></pre></td></tr></table></figure>
<p>常指针始终指向同一个对象，但是可以改变其所指对象中数据成员的值 。</p>
<p><strong>指向常对象的指针：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const  类型名 *指针变量名;</span><br></pre></td></tr></table></figure>
<p>如果存在一个常对象，<strong>只能</strong>用指向常对象的指针指向它，而不能用非const型的指针指向它。</p>
<p>指向常对象的指针还可以指向非const型的对象，此时不能通过指针改变该对象的值；但是指针本身的值可以改变。</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time t1(10,12,15),t2;</span><br><span class="line"><span class="keyword">const</span> Time *p=&amp;t1;<span class="comment">//p是指向常对象的指针，//并指向t1对象</span></span><br><span class="line">(*p).hour=<span class="number">18</span>;   <span class="comment">//错误，不能通过指针改变              //t1的值</span></span><br><span class="line">t1.hour=<span class="number">18</span>;<span class="comment">//正确，t1不是常对象</span></span><br><span class="line">p=&amp;t2;<span class="comment">//正确，p改为指向t2</span></span><br></pre></td></tr></table></figure></p>
<p>指向常对象的指针可以指向const和非const型的对象，而指向非const型对象的指针只能指向非const的对象。</p>
<h3 id="常引用">常引用</h3>
<p>如果在声明引用时用const修饰，被声明的引用就是常引用。</p>
<p>常引用所引用的对象不能被更新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const  &lt;数据类型&gt;　&amp;&lt;引用名&gt;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void fun(const Time &amp;t);</span><br></pre></td></tr></table></figure>
<p>在函数中不能改变t的值，也就是不能改变其对应的实参对象的值。</p>
<h2 id="对象数组">对象数组</h2>
<p>对象数组的元素是对象。声明一维对象数组的一般格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;类名&gt; &lt;数组名&gt;[&lt;下标表达式&gt;]</span><br></pre></td></tr></table></figure>
<p>在建立数组时，需要调用构造函数。数组中有多少个元素，就调用多少次构造函数。</p>
<p>在定义数组时可以提供实参以实现初始化。</p>
<p>如果构造函数只有一个参数，在定义数组时可以直接在等号后面的大括号内提供实参。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student stud[3]&#x3D;&#123;60,70,78&#125;;</span><br></pre></td></tr></table></figure>
<p>如果构造函数有多个参数，在定义对象数组时在大括号中分别写出构造函数并指定实参。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Ex(<span class="keyword">int</span> x=<span class="number">0</span>, <span class="keyword">char</span> c=‘c’);  <span class="comment">//声明构造函数</span></span><br><span class="line">Ex z[<span class="number">2</span>]=&#123;Ex(<span class="number">10</span>,<span class="string">'a'</span>),Ex(<span class="number">1</span>,<span class="string">'d'</span>)&#125;; <span class="comment">//对象数组的初始化</span></span><br></pre></td></tr></table></figure>
<p>每个数组元素都是对象，通过该对象，便可以访问到它的公有成员。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;数组名&gt;[&lt;下标&gt;].&lt;成员名&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">z[<span class="number">0</span>].outdata();</span><br></pre></td></tr></table></figure>
<p>【例】示例对象数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Box(<span class="keyword">int</span> h = <span class="number">10</span>, <span class="keyword">int</span> w = <span class="number">12</span>, <span class="keyword">int</span> len = <span class="number">15</span>) ：height(h), width(w), length(len) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">volume</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Box::volume</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> height * width * length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Box a[<span class="number">2</span>] = &#123;Box(<span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>), Box(<span class="number">15</span>, <span class="number">18</span>, <span class="number">20</span>)&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"volume of a[0] is："</span> &lt;&lt; a[<span class="number">0</span>].volume() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"volume of a[1] is："</span> &lt;&lt; a[<span class="number">1</span>].volume() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【例】示例动态对象数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPoint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CPoint(<span class="keyword">int</span> x0, <span class="keyword">int</span> y0 = <span class="number">0</span>) <span class="comment">//带默认参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = x0;</span><br><span class="line">        y = y0;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"constructor1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CPoint() <span class="comment">//无参数构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"constructor2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">(<span class="keyword">int</span> x0 = <span class="number">0</span>, <span class="keyword">int</span> y0 = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = x0;</span><br><span class="line">        y = y0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">"  "</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>; &#125; <span class="comment">//输出私有数据成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CPoint *ptr = <span class="keyword">new</span> CPoint[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">//为对象数组动态申请内存单元</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">if</span> (!ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"allocation failure"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//申请失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"input  data："</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; k++, ptr++) <span class="comment">//为对象数组各元素赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        ptr-&gt;input(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"output:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; k++)</span><br><span class="line">        (--ptr)-&gt;print();</span><br><span class="line">    <span class="keyword">delete</span>[] ptr;</span><br><span class="line">    <span class="comment">//释放为对象数组动态申请的内存单元</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象成员">对象成员</h2>
<p>用类对象作为另一个类的成员，这个成员称为对象成员或者子对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">&#125;;</span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    A a; &#x2F;&#x2F;对象成员</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="对象成员的初始化">对象成员的初始化</h3>
<p>对象成员的初始化有两种情况，一种是在构造函数成员初始化表中被初始化，一种是在函数体内被初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">const</span> A &amp;a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A m_a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象成员在初始化列表中被初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">B::B(<span class="keyword">const</span> A &amp;a) : m_a(a)</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象成员在函数体内被初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">B::B(<span class="keyword">const</span> A &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    m_a = a;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【例】示例对象成员。</p>
<p>用Point类来描述点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> xx = <span class="number">0</span>, <span class="keyword">int</span> yy = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        X = xx;</span><br><span class="line">        Y = yy;</span><br><span class="line">    &#125;</span><br><span class="line">    Point(<span class="keyword">const</span> Point &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        X = p.X;</span><br><span class="line">        Y = p.Y;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"In Point copy constructor."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> X; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> X, Y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义线段距离Distance类来计算两个点之间的距离，在构造函数中实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Distance</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Distance(Point xp1, Point xp2);</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetD</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> dist; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Point p1, p2; <span class="comment">//对象成员p1，p2</span></span><br><span class="line">    <span class="keyword">double</span> dist;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数中通过调用复制构造函数初始化对象成员p1、p2</span></span><br><span class="line">Distance::Distance(Point xp1, Point xp2) : p1(xp1), p2(xp2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"in Distance constructor."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="keyword">double</span>(p1.GetX() - p2.GetX());</span><br><span class="line">    <span class="keyword">double</span> y = <span class="keyword">double</span>(p1.GetY() - p2.GetY());</span><br><span class="line">    dist = <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">//主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point myp1(2, 2), myp2(5, 6); //定义Point类的对象myp1，myp2</span><br><span class="line">    <span class="function">Distance <span class="title">myd</span><span class="params">(myp1, myp2)</span></span>;     <span class="comment">//定义 Distance类的对象myd</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The distance is:"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myd.GetD() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In Point copy constructor.</span><br><span class="line">In Point copy constructor.</span><br><span class="line">In Point copy constructor.</span><br><span class="line">In Point copy constructor.</span><br><span class="line">in Distance constructor.</span><br><span class="line">The distance is:5</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<p>一般来说，在类中出现了对象成员时，创建本类对象既要对本类的数据成员进行初始化，又要对对象成员进行初始化。</p>
<p>先调用对象成员的构造函数，再调用本类的构造函数。析构函数的调用顺序刚好相反。</p>
<p>如果调用本类默认形式的构造函数，那么也只能调用对象成员的默认形式的构造函数。</p>
<h3 id="对象成员数组">对象成员数组</h3>
<p>一个对象可以作为另一个类的成员，那么对象成员数组同样也可以作为另一个类的成员。</p>
<p>【例】示例对象成员数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLesson</span> //定义选课类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CLesson();                                <span class="comment">//无参构造函数</span></span><br><span class="line">    CLesson(<span class="built_in">string</span> lesson);                   <span class="comment">//带参构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLesson</span><span class="params">(<span class="built_in">string</span> lesname)</span></span>;           <span class="comment">//设置选修课程</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetLesson</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> LessonName; &#125; <span class="comment">//获取选修课程名</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> LessonName; <span class="comment">//课程名</span></span><br><span class="line">&#125;;</span><br><span class="line">CLesson::CLesson(<span class="built_in">string</span> lesson)</span><br><span class="line">&#123;</span><br><span class="line">    LessonName = lesson;</span><br><span class="line">&#125;</span><br><span class="line">CLesson::CLesson()</span><br><span class="line">&#123;</span><br><span class="line">    LessonName = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CLesson::setLesson</span><span class="params">(<span class="built_in">string</span> lesname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LessonName = lesname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> //定义学生类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">int</span> value, <span class="built_in">string</span> str)</span><br><span class="line">    &#123;</span><br><span class="line">        ID = value;</span><br><span class="line">        name = str;</span><br><span class="line">        Number = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddLesson</span><span class="params">(<span class="built_in">string</span> lesson)</span></span>; <span class="comment">//增加选修课程</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetLesson</span><span class="params">(<span class="keyword">int</span> index)</span>    <span class="comment">//获取选修课程名</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LessonName[index].GetLesson();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">GetStudentName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125; <span class="comment">//获取学生姓名</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNum</span><span class="params">()</span>                             <span class="comment">//获取选修课程门数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> ID;                <span class="comment">//学号</span></span><br><span class="line">    <span class="built_in">string</span> name;           <span class="comment">//姓名</span></span><br><span class="line">    CLesson LessonName[<span class="number">5</span>]; <span class="comment">//对象成员数组</span></span><br><span class="line">    <span class="keyword">int</span> Number;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::AddLesson</span><span class="params">(<span class="built_in">string</span> lesson)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Number &lt; <span class="number">4</span>) <span class="comment">//设置最多选课数         LessonName[Number++].setLesson(lesson);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">student1</span><span class="params">(<span class="number">1</span>, <span class="string">"Wang Li"</span>)</span></span>; <span class="comment">//定义学生</span></span><br><span class="line">    student1.AddLesson(<span class="string">"Computer"</span>); <span class="comment">//增加一门选修课</span></span><br><span class="line">    student1.AddLesson(<span class="string">"English"</span>);  <span class="comment">//增加一门选修课</span></span><br><span class="line">    <span class="keyword">int</span> number = student1.GetNum(); <span class="comment">//统计选修课数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; student1.GetStudentName() &lt;&lt; <span class="string">" course is:"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; student1.GetLesson(i) &lt;&lt; <span class="string">" "</span>; <span class="comment">//输出所选课程名</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类模板">类模板</h2>
<p>同函数模板一样，使用类模板可以为类定义一种模式，使得类中的某些数据成员、某些成员函数的参数、某些成员函数的返回值能取任意类型。</p>
<p><strong>类模板是对一批仅有成员数据类型不同的类的抽象。</strong></p>
<p>类模板的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class 类型参数&gt;  </span><br><span class="line">class &lt;类模板名&gt;</span><br><span class="line">&#123; </span><br><span class="line">    &lt;类成员的声明&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，<类型参数>可以有一个或多个。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; //声明一个模板，类型参数名为<span class="title">T</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Compare</span> //类模板名为<span class="title">Compare</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Compare()</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Compare(T a, T b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">max</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="类模板的使用">类模板的使用</h3>
<p>由于类模板包含类型参数，因此又称为<strong>参数化的类</strong>。如果说类是对象的抽象，对象是类的实例，则<strong>类模板是类的抽象，类是类模板的实例</strong>。</p>
<p>由类模板经实例化而生成的具体类称之为<strong>模板类</strong>。</p>
<p>利用类模板定义的只是对类的描述，它本身还不是一个实实在在的类。</p>
<p>要定义类模板的对象（即实例），需要用下列格式的语句：</p>
<ul>
<li><p>类模板名 <实际的类型> <对象名></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Compare&lt;<span class="keyword">int</span>&gt; cmp;</span><br></pre></td></tr></table></figure></li>
<li><p>类模板名 <实际的类型> <对象名>[(实际参数表)];</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Compare&lt;<span class="keyword">int</span>&gt; <span class="title">cmp</span><span class="params">(<span class="number">3</span>,<span class="number">7</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Compare</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Compare(T a, T b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">max</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Compare&lt;<span class="keyword">int</span>&gt; <span class="title">cmp1</span><span class="params">(<span class="number">3</span>, <span class="number">7</span>)</span></span>;</span><br><span class="line">    <span class="comment">// int Compare类，cmp1为该类的一个对象</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cmp1.max() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Compare&lt;<span class="keyword">double</span>&gt; <span class="title">cmp2</span><span class="params">(<span class="number">4.3</span>, <span class="number">9.6</span>)</span></span>;</span><br><span class="line">    <span class="comment">// double Compare类，cmp2为该类的一个对象</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cmp2.max() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Compare&lt;<span class="keyword">char</span>&gt; <span class="title">cmp3</span><span class="params">(<span class="string">'a'</span>, <span class="string">'A'</span>)</span></span>;</span><br><span class="line">    <span class="comment">// char Compare类，cmp3为该类的一个对象</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cmp3.max() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">9.6</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<h3 id="类模板的实例化">类模板的实例化</h3>
<p>类模板实例化以及类实例化的逻辑关系:</p>
<p><img src="image-20201207212818189.png" alt="image-20201207212818189" style="zoom:50%;" /></p>
<h3 id="类模板中的成员函数的定义">类模板中的成员函数的定义</h3>
<p>可以放在类模板的定义体中（此时与类中的成员函数的定义方法一致）</p>
<p>也可以放在类模板的外部，此时成员函数的定义格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class 类型参数&gt; </span><br><span class="line">&lt;返回值类型&gt; &lt;类模板名&gt;&lt;类型参数&gt;::&lt;函数名&gt;（&lt;参数表&gt;）</span><br><span class="line">&#123;</span><br><span class="line">    &lt;函数体&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意！</strong></p>
<p>在类模板外定义成员函数时，每一个函数前均加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class 类型参数&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">Compare</span>&lt;T&gt;:</span>:max()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<p>类模板的类型参数可以有一个或多个，每个类型前面都必须加class</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span>&#123;</span>…&#125;;</span><br></pre></td></tr></table></figure>
<p>在定义对象时分别代入实际的类型名</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A&lt;<span class="keyword">int</span>,<span class="keyword">double</span>&gt; obj;</span><br></pre></td></tr></table></figure>
<p>使用类模板时要注意其作用域，只能在其有效作用域内用它定义对象。如果类模板是在文件开头定义的，则该文件范围内为有效作用域，可以在其中的任何地方使用类模板。</p>
<h3 id="使用默认参数的类模板">使用默认参数的类模板</h3>
<p>类模板可以包含与通用类型相关的<strong>默认参数</strong>。当类模板被实例化时，如果没有指定其它的数据类型，则使用默认类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;class T&#x3D;int&gt;</span><br><span class="line">class Array&#123;…&#125;; &#x2F;&#x2F;使用默认参数的类模板</span><br><span class="line"></span><br><span class="line">Array&lt;double&gt; doubleob;</span><br><span class="line">Array&lt;&gt; defaultob;</span><br></pre></td></tr></table></figure>
<h2 id="测试-2">测试</h2>
<p>写出下面程序的运行结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cstring"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPicture</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> m_bSatiate;</span><br><span class="line">    <span class="keyword">char</span> m_szName[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CPicture(<span class="keyword">char</span> *szName = <span class="literal">NULL</span>);</span><br><span class="line">    CPicture(CPicture &amp;CopyPicture);</span><br><span class="line">    ~CPicture()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"展览结束了，"</span> &lt;&lt; m_szName &lt;&lt; <span class="string">"也该撤去了"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">GetName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_szName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; m_bSatiate = <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Finish</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_bSatiate)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"这么美的画一定有很多人喜欢!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"都什么时候了还不开展!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">CPicture::CPicture(<span class="keyword">char</span> *szName)</span><br><span class="line">&#123;</span><br><span class="line">    m_bSatiate = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (szName == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"画家还没有为我命名"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        m_szName[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(m_szName, szName);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"我是"</span> &lt;&lt; m_szName &lt;&lt; <span class="string">"，是一幅美丽的油画 "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">CPicture::CPicture(CPicture &amp;CopyPicture)</span><br><span class="line">&#123;</span><br><span class="line">    m_bSatiate = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(m_szName, CopyPicture.GetName());</span><br><span class="line">    <span class="built_in">strcat</span>(m_szName, <span class="string">"的复制品"</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"我是"</span> &lt;&lt; m_szName &lt;&lt; <span class="string">",也是一幅油画"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Begin</span><span class="params">(CPicture Picture)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Picture.Show();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CPicture <span class="title">Picture</span><span class="params">(<span class="string">"日出"</span>)</span></span>;</span><br><span class="line">    Begin(Picture);</span><br><span class="line">    Picture.Finish();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是日出，是一幅美丽的油画</span><br><span class="line">我是日出的复制品,也是一幅油画</span><br><span class="line">展览结束了，日出的复制品也该撤去了</span><br><span class="line">都什么时候了还不开展!</span><br><span class="line">展览结束了，日出也该撤去了</span><br></pre></td></tr></table></figure>
<h1 id="运算符重载">运算符重载</h1>
<h2 id="运算符重载的定义">运算符重载的定义</h2>
<h3 id="提出问题">提出问题</h3>
<p>复数的加减运算问题：</p>
<ul>
<li>对于非基本数据类型，如复数、分数，如何在程序中进行运算？</li>
<li>能否直接用运算符（+、-、*、/）进行运算？</li>
</ul>
<p>自定义一个复数类Complex完成复数的加减运算</p>
<p>设计复数类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>				//复数类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	    Complex(<span class="keyword">double</span> r=<span class="number">0.0</span>,<span class="keyword">double</span> i=<span class="number">0.0</span>) <span class="comment">//构造函数</span></span><br><span class="line">        &#123; real=r; imag=i; &#125; 	    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">　　<span class="keyword">double</span> real, imag;         	<span class="comment">//定义实部、虚部</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="思考">思考</h3>
<p>是否能通过下面的代码完成复数的加减运算?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义复数对象</span></span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.3</span>, <span class="number">2.5</span>)</span></span>; </span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">2.1</span>, <span class="number">1.4</span>)</span></span>;</span><br><span class="line">    Complex c3, c4;</span><br><span class="line">    </span><br><span class="line">    c3 =  c1 + c2;</span><br><span class="line">    c4 =  c1 - c2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++预定义的“+”、“-”运算只支持基本数据类型，并不支持用户自定义类型。</p>
<h3 id="重新设计复数类complex">重新设计复数类Complex</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span> 							 </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> r=<span class="number">0.0</span>,<span class="keyword">double</span> i=<span class="number">0.0</span>) <span class="comment">//构造函数</span></span><br><span class="line">    &#123; real=r; imag=i; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Real</span><span class="params">( )</span></span>&#123;<span class="keyword">return</span> real;&#125; <span class="comment">//返回复数的实部</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Imag</span><span class="params">( )</span></span>&#123;<span class="keyword">return</span> imag;&#125;<span class="comment">//返回复数的虚部</span></span><br><span class="line">    <span class="function">Complex <span class="title">add</span><span class="params">(Complex &amp;c)</span></span>;    <span class="comment">//函数重载，实现复数加复数</span></span><br><span class="line">    <span class="function">Complex <span class="title">add</span><span class="params">(<span class="keyword">double</span> d)</span></span>;      <span class="comment">//函数重载，实现复数加实数</span></span><br><span class="line">    <span class="function">Complex <span class="title">sub</span><span class="params">(Complex &amp;c)</span></span>;    <span class="comment">//函数重载，实现复数减复数</span></span><br><span class="line">    <span class="function">Complex <span class="title">sub</span><span class="params">(<span class="keyword">double</span> d)</span></span>;     <span class="comment">//函数重载，实现复数减实数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real, imag; 	<span class="comment">//定义实部、虚部</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="成员函数定义">成员函数定义</h3>
<p>完成复数与复数相加</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">Complex::add</span><span class="params">(Complex &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      Complex temp;</span><br><span class="line">	  temp.real = real + c.real;</span><br><span class="line">	  temp.imag = imag + c.imag;</span><br><span class="line">	  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成复数与实数相加</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">Complex::add</span><span class="params">(<span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       Complex temp;</span><br><span class="line">	   temp.real = real + d;</span><br><span class="line">	   temp.imag = imag;</span><br><span class="line">	   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.3</span>, <span class="number">2.5</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">2.1</span>, <span class="number">1.4</span>)</span></span>;</span><br><span class="line">    Complex c3, c4;</span><br><span class="line">    c3 = c1.add(c2);</span><br><span class="line">    c4 = c1.sub(c2);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c3= "</span> &lt;&lt; c3.Real() &lt;&lt; <span class="string">" +i "</span> &lt;&lt; c3.Imag() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c4= "</span> &lt;&lt; c4.Real() &lt;&lt; <span class="string">" +i "</span> &lt;&lt; c4.Imag() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不如c3=c1+c2直观!</p>
<h2 id="运算符重载的两种形式">运算符重载的两种形式</h2>
<h3 id="运算符重载-1">运算符重载</h3>
<p>C++提供了<strong>运算符重载机制</strong>，使得系统预定义的运算符能够完成用户自定义数据类型的运算。</p>
<p>运算符重载就是为用户自定义类型<strong>重新定义运算符</strong>，使同一个运算符既可以作用于预定义的数据类型，也可以作用于用户自定义的数据类型。</p>
<p>运算符重载本质上是一种特殊的<strong>函数重载</strong>。</p>
<p>为了重载运算符，必须定义一个运算符重载函数，<strong>由这个函数来完成该运算符应该完成的操作</strong>。<strong>运算符的操作数通常是类的对象</strong>。</p>
<p>可以将运算符重载函数作为<strong>类的成员函数或者是友元函数</strong>。</p>
<h3 id="重载为类的成员函数">重载为类的成员函数</h3>
<p>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;函数类型&gt; operator &lt;运算符&gt;(&lt;参数表&gt;) &#x2F;&#x2F;operator是关键字</span><br><span class="line">&#123;	函数体	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A  <span class="keyword">operator</span>+(A &amp;);<span class="comment">//重载了A类的“+”运算符</span></span><br></pre></td></tr></table></figure>
<h3 id="在复数类中重载运算符">在复数类中重载运算符</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>		//复数类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	   Complex(<span class="keyword">double</span> r=<span class="number">0.0</span>,<span class="keyword">double</span> i=<span class="number">0.0</span>)&#123;real=r;imag=i;&#125; </span><br><span class="line">	   <span class="function"><span class="keyword">const</span> <span class="keyword">double</span> <span class="title">Real</span><span class="params">( )</span></span>&#123;<span class="keyword">return</span> real;&#125;</span><br><span class="line">	   <span class="function"><span class="keyword">const</span> <span class="keyword">double</span> <span class="title">Imag</span><span class="params">( )</span></span>&#123;<span class="keyword">return</span> imag;&#125; </span><br><span class="line">        Complex <span class="keyword">operator</span>+( Complex &amp;c); <span class="comment">//重载运算符“+”</span></span><br><span class="line">        Complex <span class="keyword">operator</span>+( <span class="keyword">double</span> d); <span class="comment">//重载运算符“+”</span></span><br><span class="line">        Complex <span class="keyword">operator</span>-( Complex &amp;c); <span class="comment">//重载运算符“-”</span></span><br><span class="line">        Complex <span class="keyword">operator</span>-( <span class="keyword">double</span> d);  <span class="comment">//重载运算符"-"</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">double</span> real,imag; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="运算符重载函数定义">运算符重载函数定义</h3>
<p>完成复数与复数相加</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Complex Complex::<span class="keyword">operator</span> +(Complex &amp;c)</span><br><span class="line">&#123;</span><br><span class="line">      Complex temp;</span><br><span class="line">	  temp.real = real + c.real;</span><br><span class="line">	  temp.imag = imag + c.imag;</span><br><span class="line">	  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成复数与实数相加</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Complex Complex::<span class="keyword">operator</span> +(<span class="keyword">double</span> d)</span><br><span class="line">&#123;</span><br><span class="line">     Complex temp;</span><br><span class="line">	   temp.real = real + d;</span><br><span class="line">	   temp.imag = imag;</span><br><span class="line">	   <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.3</span>, <span class="number">2.5</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">2.1</span>, <span class="number">1.4</span>)</span></span>;</span><br><span class="line">    Complex c3, c4;</span><br><span class="line">    c3 = c1 + c2; <span class="comment">//相当于c3=c1.operator +(c2);</span></span><br><span class="line">    c4 = c1 - c2; <span class="comment">//相当于c4=c1.operator -(c2);</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c3= "</span> &lt;&lt; c3.Real() &lt;&lt; <span class="string">" +i "</span> &lt;&lt; c3.Imag() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c4= "</span> &lt;&lt; c4.Real() &lt;&lt; <span class="string">" +i "</span> &lt;&lt; c4.Imag() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="说明">说明</h3>
<p>在C++中不允许重载有三个操作数的运算符。</p>
<p>运算符重载为成员函数时<strong>最多有一个形参</strong>。</p>
<p>运算符重载的<strong>实质就是函数重载</strong>，只不过函数名换成了关键字operator和具体要重载的运算符。</p>
<p>运算符重载的函数参数<strong>就是该运算符涉及的操作数</strong>，因此运算符重载在参数个数上是有限制的，这是它不同于函数重载之处。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a = <span class="number">0</span>) &#123; i = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddA</span><span class="params">(A &amp;a, A &amp;b)</span> <span class="comment">//利用函数进行类之间的运算</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        i = a.i + b.i;</span><br><span class="line">    &#125;</span><br><span class="line">    A <span class="keyword">operator</span>+(A &amp;a) <span class="comment">//重载运算符+</span></span><br><span class="line">    &#123;</span><br><span class="line">        A t;</span><br><span class="line">        t.i = i + a.i;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1(10), a2(20), a3;</span><br><span class="line">    a1.Show();</span><br><span class="line">    a2.Show();</span><br><span class="line">    a3 = a1 + a2;    <span class="comment">//重新解释了加法，可以直接进行类的运算</span></span><br><span class="line">    a3.AddA(a1, a2); <span class="comment">//调用专门的功能函数</span></span><br><span class="line">    a3.Show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运算符重载为成员函数时，左操作数必须是对象本身，由左操作数调用右操作数。最后将函数返回值赋给运算结果的对象。</p>
<h3 id="运算符重载的规则">运算符重载的规则</h3>
<p>重载的功能应当与原有功能类似，不能改变原运算符的操作数个数，同时至少要有一个操作数的类型是自定义类型。</p>
<p>重载之后运算符的优先级和结合性都不会改变，并且要保持原运算符的语法结构。参数和函数值类型都可以重新说明。</p>
<p>当用<strong>成员函数实现运算符的重载时</strong>，运算符重载函数的参数只能有两种情况：<strong>没有参数或带有一个参数</strong>。</p>
<p>在重载<strong>双目</strong>运算符时，只能带有<strong>一个参数</strong>。参数可以是对象，对象的引用，或其它类型的参数。</p>
<h3 id="不能重载的运算符">不能重载的运算符</h3>
<table>
<thead>
<tr class="header">
<th>不能重载的运算符</th>
<th style="text-align: left;">说　明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>::</td>
<td style="text-align: left;">作用域运算符</td>
</tr>
<tr class="even">
<td>.</td>
<td style="text-align: left;">成员访问运算符</td>
</tr>
<tr class="odd">
<td>*</td>
<td style="text-align: left;">成员指针访问运算符</td>
</tr>
<tr class="even">
<td>?:</td>
<td style="text-align: left;">条件运算符</td>
</tr>
<tr class="odd">
<td>sizeof</td>
<td style="text-align: left;">长度运算符：求表达式或数据类型所占存储空间字节数</td>
</tr>
</tbody>
</table>
<h3 id="单目运算符的重载">单目运算符的重载</h3>
<p>只具有一个操作数的运算符为单目运算符，最常用的为++及--。</p>
<p>先自加或后自加的<strong>重载运算符函数的返回值不一致</strong>，<strong>必须在重载时予以区分</strong>。</p>
<p>++为前置运算符时，它的运算符重载函数的一般格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;type&gt; operator ++()</span><br></pre></td></tr></table></figure>
<p>++为后置运算符时，它的运算符重载函数的一般格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;type&gt;  operator ++(int)</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">float</span> a = <span class="number">0</span>, <span class="keyword">float</span> b = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    A <span class="keyword">operator</span>++()</span><br><span class="line">    &#123;</span><br><span class="line">        A t;</span><br><span class="line">        t.x = ++x;</span><br><span class="line">        t.y = ++y;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    A <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        A t;</span><br><span class="line">        t.x = x++;</span><br><span class="line">        t.y = y++;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a(2, 3), b;</span><br><span class="line">    b = ++a;</span><br><span class="line">    b = a++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运算符重载为成员函数后，它可以自由地访问类的所有成员。实际使用时，总是通过该类的某个对象来访问重载的运算符。</p>
<p>运算符重载为类的成员函数时，函数的参数个数比原来操作数少一个（后置“++”和后置“--”除外）。</p>
<p>用成员函数实现运算符的重载时，<strong>运算符的左操作数为当前对象</strong>，并且要用到隐含的this指针。</p>
<p><strong>运算符重载函数不能定义为静态的成员函数，因为静态的成员函数中没有this指针。</strong></p>
<h3 id="说明-1">说明</h3>
<p>如果是双目运算符，左操作数一定是对象本身，由this指针给出，另一个操作数需要由运算符重载的参数表来传递。</p>
<p>如果是单目运算符，操作数由对象的this指针给出，就不再需要任何参数。但重载“++”和“--”运算符时，C++约定，如果在参数表中放一个整型参数，则表示重载的运算符为后置运算符。</p>
<h2 id="友元的作用和定义">友元的作用和定义</h2>
<p>根据类的封装性，一般将数据成员声明为私有成员，外部不能直接访问，只能通过类的公有成员函数对私有成员进行访问。</p>
<p>C++<strong>从高效的角度出发</strong>，提供友元机制，使被声明为友元的函数或者其他类可以直接访问当前类中的私有成员，又不改变其私有成员的访问权限。</p>
<p>友元可以是一个<strong>全局函数</strong>、另一个类的<strong>成员函数</strong>或者是一个<strong>类</strong>。分别称为友元函数和友元类。友元类的所有成员函数都是友元函数，可以访问被访问类的任何成员。</p>
<p><strong>友元声明以关键字friend开始，只能出现在被访问类的定义中。</strong>具体格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">friend  &lt;函数值类型&gt;  &lt;函数名&gt;(&lt;参数表&gt;);</span><br><span class="line">friend  class &lt;类名&gt;;</span><br></pre></td></tr></table></figure>
<p><strong>友元函数不是该类的成员函数，它破坏了类的封装性和隐蔽性，使得非成员函数可以访问类的私有成员。</strong></p>
<p>一个类的友元可以自由地用该类中的所有成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">Sum</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;                <span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">float</span> <span class="title">Sum</span><span class="params">(A &amp;a)</span> </span>&#123; <span class="keyword">return</span> a.x + a.y; &#125; <span class="comment">//友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A t1(4, 5), t2(10, 20);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t1.Sum() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//成员函数的调用，利用对象名调用</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Sum(t2) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//友元函数的调用，直接调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>友元函数只能用对象名引用类中的数据。</p>
<h3 id="友元函数与普通函数">友元函数与普通函数</h3>
<p>友元函数近似于<strong>普通函数</strong>，它不带有this指针，<strong>因此必须将对象名或对象的引用作为友元函数的参数</strong>，这样才能访问到对象的成员。</p>
<p><strong>友元函数必须在类的定义中声明</strong>，其函数体可在类内定义，也可在类外定义。</p>
<p><strong>友元函数可以访问该类中的所有成员（公有的、私有的和保护的）</strong>，而普通函数只能访问类中的公有成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">Getx</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">Gety</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">Sum</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x + y; &#125; <span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">float</span> <span class="title">Sum</span><span class="params">(A &amp;)</span></span>;        <span class="comment">//友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Sum</span><span class="params">(A &amp;a)</span> </span>&#123; <span class="keyword">return</span> a.x + a.y; &#125;             <span class="comment">//友元函数,可以直接调用类中私有成员</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">Sumxy</span><span class="params">(A &amp;a)</span> </span>&#123; <span class="keyword">return</span> a.Getx() + a.Gety(); &#125; <span class="comment">//普通函数，必须通过公有函数访问私有成员</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A t1(1, 2), t2(10, 20), t3(100, 200);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t1.Sum() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//对象调用成员函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Sum(t2) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//调用友元函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Sumxy(t3) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//调用普通函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>友元函数不受类中访问权限关键字的限制，可以把它放在类的私有、公有或保护部分，其作用都是一样的。换言之，<strong>在类中对友元函数指定访问权限不起作用</strong>。</p>
<p>友元函数的作用域与普通函数的作用域相同。</p>
<p>谨慎使用友元函数</p>
<ul>
<li>通常使用友元函数来<strong>取</strong>对象中的数据成员值，而<strong>不修改</strong>对象中的成员值，保证数据安全。</li>
</ul>
<p>大多数情况下友元函数是某个类的成员函数，<strong>即A类中的某个成员函数是B类中的友元函数，这个成员函数可以直接访问B类中的私有数据</strong>。这就实现了类与类之间的沟通。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">( B &amp;)</span></span>;<span class="comment">//既是类A的成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">A::fun</span><span class="params">( B &amp;)</span></span>;<span class="comment">//又是类B的友元函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>A类中的成员函数fun()是B类的友元函数。即在fun()中可以直接引用B类的私有成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">B</span>  ;</span>	<span class="comment">//先定义A类，则首先对B类作引用性说明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">A</span>&#123;</span></span><br><span class="line">   ......		<span class="comment">//类A的成员定义</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">void</span>  <span class="title">fun</span><span class="params">( B &amp; )</span></span>;<span class="comment">//函数的原型说明</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">B</span>&#123;</span>	......</span><br><span class="line">    <span class="function"><span class="keyword">friend</span>  <span class="keyword">void</span>  <span class="title">A::fun</span><span class="params">( B &amp; )</span></span>;<span class="comment">//定义友元函数</span></span><br><span class="line">&#125;；</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">A::fun</span> <span class="params">( B  &amp;b)</span>	   <span class="comment">//函数的完整定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     ......		<span class="comment">//函数体的定义</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>A类中有一个函数可以直接引用B类的私有成员</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span> <span class="comment">//必须在此进行引用性说明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Sum</span><span class="params">(B &amp;)</span></span>; <span class="comment">//说明友元函数的函数原型，是A类的成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> m, n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        m = a;</span><br><span class="line">        n = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">A::Sum</span><span class="params">(B &amp;)</span></span>; <span class="comment">//说明A类的成员函数是B类的友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A::Sum</span><span class="params">(B &amp;b)</span>       <span class="comment">//定义该友元函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = b.m + b.n;</span><br><span class="line">    y = b.m - b.n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">B <span class="title">b1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    a1.Sum(b1); <span class="comment">//调用该函数，因是A类的成员函数，故用A类的对象调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="友元类">友元类</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span> <span class="comment">//B类是A类的友元</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    ..... <span class="comment">//B类可以自由使用A类中的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于B类而言，A类是透明的</p>
<p>B类必须通过<strong>A类的对象</strong>使用A类的成员</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> r;</span><br><span class="line">    <span class="keyword">float</span> h;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">float</span> a, <span class="keyword">float</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        r = a;</span><br><span class="line">        h = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">Getr</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">Geth</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> h; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span> <span class="comment">//定义B类为A类的友元</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> n = <span class="number">1</span>) &#123; number = n; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(A &amp;a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; PI * a.r * a.r * a.h * number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="comment">//求A类的某个对象*n的体积</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1(25, 40), a2(10, 40);</span><br><span class="line">    <span class="function">B <span class="title">b1</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    b1.Show(a1) ； b1.Show(a2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="友元小结">友元小结</h3>
<p>友元的出现主要是为了解决一些实际问题，友元本身不是面向对象的内容。</p>
<p>通过友元机制，一个类或函数可以直接访问另一类中的非公有成员。</p>
<p>可以将全局函数、类、类的成员函数声明为友元。</p>
<p>友元关系是不能传递的。B类是A类的友元，C类是B类的友元，C类和A类之间，如果没有声明，就没有任何友元关系，不能进行数据共享。</p>
<p>友元关系是单向的，如果声明B类是A类的友元，B类的成员函数就可以访问A类的私有成员和保护成员。但A类的成员不能访问B类的私有成员和保护成员，除非声明A类是B类的友元。</p>
<h3 id="运算符重载的使用">运算符重载的使用</h3>
<p>运算符重载有两种方式：运算符重载为<strong>类的成员函数</strong>，运算符重载为<strong>类的友元函数</strong>。</p>
<p>当运算符重载为类的成员函数时，对于单目运算符，操作数一定是对象本身，对于双目运算符，左操作数一定是对象。</p>
<p>当运算符重载为友元函数时，参数中同样必须有一个是用户自定义类型的对象，但不限定其必须是左操作数。</p>
<p>运算符重载为<strong>成员函数</strong>时，是由一个操作数调用另一个操作数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A  a ,b ,  c;</span><br><span class="line">c=a+b;	<span class="comment">//实际上是c=a.operator+(b);</span></span><br><span class="line">c=++a;	<span class="comment">//实际上是c=a.operator++(  );</span></span><br><span class="line">c+=a;	<span class="comment">//实际上是c.operator+=( a );</span></span><br><span class="line"><span class="comment">//即函数的实参只有一个或没有。</span></span><br></pre></td></tr></table></figure>
<p>将运算符的重载函数定义为友元函数，<strong>参与运算的对象全部成为函数参数</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A  a ,b ,  c;</span><br><span class="line">c=a+b;	<span class="comment">//实际上是 c=operator+(a, b);</span></span><br><span class="line">c=++a;	<span class="comment">//实际上是 c=operator++(a);</span></span><br><span class="line">c+=a;	<span class="comment">//实际上是 operator+=(c, a);</span></span><br></pre></td></tr></table></figure>
<h3 id="重载为类的友元函数">重载为类的友元函数</h3>
<p>语法形式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> &lt;函数值类型&gt; <span class="keyword">operator</span> &lt;运算符&gt;(&lt;参数表&gt;)</span><br><span class="line">&#123;</span><br><span class="line">        &lt;函数体&gt;；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运算符重载为类的友元函数<strong>最多只能有两个参数</strong></p>
<p>如果重载双目运算符，则<strong>第一个参数代表左操作数，第二个参数代表右操作数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a = <span class="number">0</span>) &#123; i = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="keyword">friend</span> A <span class="keyword">operator</span>+(A &amp;, A &amp;); <span class="comment">//友元函数，两个参数，为引用</span></span><br><span class="line">&#125;;</span><br><span class="line">A <span class="keyword">operator</span>+(A &amp;a, A &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    A t;</span><br><span class="line">    t.i = a.i + b.i;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1(10), a2(20), a3;</span><br><span class="line">    a1.Show();</span><br><span class="line">    a2.Show();</span><br><span class="line">    a3 = a1 + a2; <span class="comment">//重新解释了加法，可以直接进行类的运算</span></span><br><span class="line">    a3.Show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单目运算符重载">单目运算符重载</h3>
<p><strong>++为前置运算符时</strong>，它的运算符重载函数的一般格式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A <span class="keyword">operator</span> ++(A &amp;a)</span><br></pre></td></tr></table></figure>
<p><strong>++为后置运算符时</strong>，它的运算符重载函数的一般格式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A <span class="keyword">operator</span> ++(A &amp;a, <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a = <span class="number">0</span>) &#123; i = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="keyword">friend</span> A <span class="keyword">operator</span>++(A &amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        a.i++;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> A <span class="keyword">operator</span>++(A &amp;a, <span class="keyword">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        A t;</span><br><span class="line">        t.i = a.i;</span><br><span class="line">        a.i++;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1(10), a2, a3;</span><br><span class="line">    a2 = ++a1;</span><br><span class="line">    a3 = a1++;</span><br><span class="line">    a2.Show();</span><br><span class="line">    a3.Show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i&#x3D;11</span><br><span class="line">i&#x3D;11</span><br></pre></td></tr></table></figure>
<p>【例】示例运算符重载为类的友元函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cmath"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span>;</span></span><br><span class="line"><span class="keyword">double</span> <span class="keyword">operator</span>+(Triangle &amp;t1, Triangle &amp;t2);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Triangle(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> s;</span><br><span class="line">        x = i;</span><br><span class="line">        y = j;</span><br><span class="line">        z = k;</span><br><span class="line">        s = (x + y + z) / <span class="number">2.0</span>;</span><br><span class="line">        area = <span class="built_in">sqrt</span>(s * (s - x) * (s - y) * (s - z));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disparea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Area="</span> &lt;&lt; area &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">double</span> <span class="keyword">operator</span>+(Triangle &amp;t1, Triangle &amp;t2) <span class="comment">//运算符重载为友元</span></span><br><span class="line">                                                        <span class="comment">//函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> t1.area + t2.area;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">    <span class="keyword">double</span> area;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Triangle t1(3, 4, 5), t2(4, 5, 6);</span><br><span class="line">    <span class="keyword">double</span> s;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"t1:"</span>;</span><br><span class="line">    t1.disparea();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"t2:"</span>;</span><br><span class="line">    t2.disparea();</span><br><span class="line">    s = t1 + t2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"总面积="</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t1:Area&#x3D;6</span><br><span class="line">t2:Area&#x3D;9.92157</span><br><span class="line">总面积&#x3D;15.9216</span><br></pre></td></tr></table></figure>
<p>【例】定义一个字符串类Str，重载运算符&gt;，用于两个字符串的大于的比较运算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cstring"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Str</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Str() &#123; p = <span class="literal">NULL</span>; &#125;</span><br><span class="line">    Str(<span class="keyword">char</span> *str) &#123; p = str; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; p; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(Str &amp;string1, Str &amp;string2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(string1.p, string2.p) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Str string1("Hello"), string2("Book");</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (string1 &gt; string2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<p>【例】将上例扩展到对==，<和>三个运算符进行重载。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cstring"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Str</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Str() &#123; p = <span class="literal">NULL</span>; &#125;</span><br><span class="line">    Str(<span class="keyword">char</span> *str) &#123; p = str; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(Str &amp;string1, Str &amp;string2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(string1.p, string2.p) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(Str &amp;string1, Str &amp;string2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(string1.p, string2.p) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(Str &amp;string1, Str &amp;string2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(string1.p, string2.p) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compare</span><span class="params">(Str &amp;string1, Str &amp;string2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">operator</span>&gt;(string1, string2) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        string1.display();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"&gt;"</span>;</span><br><span class="line">        string2.display();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">operator</span>&lt;(string1, string2) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        string1.display();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;"</span>;</span><br><span class="line">        string2.display();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">operator</span>==(string1, string2) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        string1.display();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"="</span>;</span><br><span class="line">        string2.display();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Str string1("Hello"), string2("Book"),</span><br><span class="line">        string3(<span class="string">"Computer"</span>), string4(<span class="string">"Hello"</span>);</span><br><span class="line">    compare(string1, string2);</span><br><span class="line">    compare(string2, string3);</span><br><span class="line">    compare(string1, string4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello&gt;Book</span><br><span class="line">Book&lt;Computer</span><br><span class="line">Hello&#x3D;Hello</span><br></pre></td></tr></table></figure>
<h3 id="重载输入运算符和输出运算符">重载输入运算符和输出运算符</h3>
<p>对象不能直接输入输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;iostream&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    float x, y;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    A(float a &#x3D; 0, float b &#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        x &#x3D; a;</span><br><span class="line">        y &#x3D; b;</span><br><span class="line">    &#125;</span><br><span class="line">    void Set(float a, float b)</span><br><span class="line">    &#123;</span><br><span class="line">        x &#x3D; a;</span><br><span class="line">        y &#x3D; b;</span><br><span class="line">    &#125;</span><br><span class="line">    void Show() &#123; cout &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    A a(2, 3);</span><br><span class="line">    a.Set(20, 30); &#x2F;&#x2F;输入对象数据</span><br><span class="line">    a.Show();      &#x2F;&#x2F;输出对象数据</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20,30</span><br></pre></td></tr></table></figure>
<p>在C++中允许用户重载运算符“&lt;&lt;”和“&gt;&gt;”，<strong>实现对象的输入和输出</strong>。重载这两个运算符时，在对象所在的类中，<strong>将重载这两个运算符的函数说明为该类的友元函数</strong>。</p>
<p>重载输入运算符的一般格式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span>  istream &amp;  operater&gt;&gt;(istream &amp;, ClassName &amp;);</span><br><span class="line"><span class="comment">//友元   返回值类型   函数名      左操作数    右操作数</span></span><br></pre></td></tr></table></figure>
<p>cin&gt;&gt;a; ==&gt; operator&gt;&gt;(cin, a);</p>
<p>返回值类型：类istream的引用，cin中可以连续使用运算符“&gt;&gt;”。<code>cin&gt;&gt;a&gt;&gt;b;</code></p>
<p>第一个参数：是&gt;&gt;的左操作数cin类型,类istream的引用</p>
<p>第二个参数：是&gt;&gt;的右操作数,即欲输入的对象的引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">	<span class="keyword">float</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	.....</span><br><span class="line">	<span class="keyword">friend</span>  istream&amp; operater&gt;&gt;(istream &amp;, A &amp;);<span class="comment">//在类中原型说明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//在类外定义函数</span></span><br><span class="line">istream &amp;  operater &gt;&gt;(istream &amp;is, A &amp;a)</span><br><span class="line">&#123;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;“ Input a:”&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    is&gt;&gt;a.x&gt;&gt;a.y;<span class="comment">// 重新定义输入流</span></span><br><span class="line">    <span class="keyword">return</span>  is;<span class="comment">// 返回输入流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">incount</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> c1, c2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    incount(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c1 = a;</span><br><span class="line">        c2 = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"c1="</span> &lt;&lt; c1 &lt;&lt; <span class="string">","</span></span><br><span class="line">                           &lt;&lt; <span class="string">"c2="</span> &lt;&lt; c2 &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;, incount &amp;);</span><br><span class="line">&#125;;</span><br><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, incount &amp;cc)</span><br><span class="line">&#123;</span><br><span class="line">    is &gt;&gt; cc.c1 &gt;&gt; cc.c2;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    incount x1, x2;</span><br><span class="line">    x1.show();</span><br><span class="line">    x2.show();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x1;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x2;</span><br><span class="line">    x1.show();</span><br><span class="line">    x2.show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重载输出运算符的一般格式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span>  ostream &amp;  operater&lt;&lt;(ostream &amp;, ClassName &amp;);</span><br><span class="line"><span class="comment">//友元   返回值类型   函数名      左操作数    右操作数</span></span><br></pre></td></tr></table></figure>
<p>cout&lt;&lt;a; ==&gt; operator&lt;&lt;(cout, a);</p>
<p>与输入（提取）运算符比较：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span>  istream &amp;  operater &gt;&gt;(istream &amp;, ClassName &amp;);</span><br></pre></td></tr></table></figure>
<p>将输入流改为输出流。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;operater &lt;&lt; (ostream &amp;, A &amp;);</span><br><span class="line">    <span class="comment">//在类中原型说明</span></span><br><span class="line">&#125;;</span><br><span class="line">ostream &amp;operater &lt;&lt; (ostream &amp; os, A &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The object is :"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    os &lt;&lt; a.x &lt;&lt; <span class="string">","</span> &lt;&lt; a.y &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//重新定义输出流</span></span><br><span class="line">    <span class="keyword">return</span> os;                       <span class="comment">//返回输出流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">incount</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> c1, c2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    incount(<span class="keyword">int</span> a = <span class="number">0</span>, <span class="keyword">int</span> b = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c1 = a;</span><br><span class="line">        c2 = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"c1="</span> &lt;&lt; c1 &lt;&lt; <span class="string">","</span></span><br><span class="line">                           &lt;&lt; <span class="string">"c2="</span> &lt;&lt; c2 &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;, incount &amp;);</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;, incount &amp;);</span><br><span class="line">&#125;;</span><br><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, incount &amp;cc)</span><br><span class="line">&#123;</span><br><span class="line">    is &gt;&gt; cc.c1 &gt;&gt; cc.c2;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, incount &amp;cc) <span class="comment">//重载cout&lt;&lt;</span></span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; <span class="string">"c1="</span> &lt;&lt; cc.c1 &lt;&lt; <span class="string">","</span></span><br><span class="line">       &lt;&lt; <span class="string">"c2="</span> &lt;&lt; cc.c2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    incount x1, x2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x1 &lt;&lt; x2; <span class="comment">//调用输出函数</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x1;        <span class="comment">//调用输入函数</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; x1 &lt;&lt; x2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两种运算符重载形式的比较">两种运算符重载形式的比较</h3>
<p>用友元或成员函数重载运算符在功能上没有什么区别。有时<strong>将双目运算符重载为友元函数比重载为成员函数使用起来更灵活。</strong></p>
<p>对于双目运算符，重载为成员函数时，仅一个参数，另一个被隐含；重载为友元函数时，有两个参数，没有隐含参数。</p>
<p>对于前置单目运算符，重载为成员函数时，没有参数；重载为友元函数时，有一个参数。 后置单目运算符重载时比前置单目运算符多一个整型参数。</p>
<h2 id="类型转换运算符重载">类型转换运算符重载</h2>
<h3 id="基本类型到类类型的转换">基本类型到类类型的转换</h3>
<p>同类型的对象可以相互赋值，相当于类中的数据成员相互赋值。</p>
<p>如果<strong>直接将数据赋给对象</strong>，所赋入的数据需要强制类型转换，<strong>这种转换需要调用构造函数</strong>。也就是利用<strong>构造函数</strong>能完成从基本类型到类类型的转换。</p>
<p>使用构造函数进行类型转换必须有一个前提，那就是在这个类中定义一个只有一个参数的构造函数——<strong>转换构造函数</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Complex(<span class="keyword">double</span> r)&#123;real=r;imag=<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>其作用是将double型的参数r转换成Comlex类的对象，将r作为复数的实部，虚部为0。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.5</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>建立Complex类对象c1，实部值为3.5，虚部值为0。它的作用就是将double型值转换成一个名为c1的Complex类对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~B() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"调用析构函数\n"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    b1.Print();</span><br><span class="line">    b1 = <span class="number">10</span>; <span class="comment">//b1=B(10) 产生一个临时对象</span></span><br><span class="line">    b1.Print();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"退出主函数\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">调用构造函数</span><br><span class="line">1</span><br><span class="line">调用构造函数 &#x2F;&#x2F;创建临时对象</span><br><span class="line">调用析构函数 &#x2F;&#x2F;这里是临时对象析构了</span><br><span class="line">10</span><br><span class="line">退出主函数</span><br><span class="line">调用析构函数</span><br></pre></td></tr></table></figure>
<p>注意：当构造函数只有一个参数时，可以用=强制赋值。</p>
<h3 id="类类型到基本类型的转换">类类型到基本类型的转换</h3>
<p>利用类型转换运算符重载将A类的对象a转换成某种基本数据类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//错误！类的对象不能直接输出</span></span><br><span class="line">    return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换构造函数能够把基本类型数据转换成指定类对象，但不能把类对象转换为基本类型数据。</p>
<p>C++引入一种特殊的成员函数——<strong>类型转换</strong>函数。类型转换函数实际上就是一个类型转换运算符<strong>重载函数</strong>。</p>
<p>类型转换函数专门用来将类类型转换为基本数据类型，它只能被重载为成员函数。</p>
<p>重载类型转换运算符函数格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">operator〈返回基本类型名〉（）</span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    return 〈基本类型值〉</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数前不需要加函数值类型。</p>
<p>转换函数的调用是隐含的，没有参数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> a = <span class="number">0</span>) &#123; i = a; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"i="</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1(10), a2(20);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> Real, Imag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> real, <span class="keyword">double</span> imag)</span><br><span class="line">    &#123;</span><br><span class="line">        Real = real;</span><br><span class="line">        Imag = imag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span>; <span class="comment">//成员函数，定义类转换 Complex－&gt;double</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Complex::<span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Real * Real + Imag * Imag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.7</span>, <span class="number">4.5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    d = <span class="number">2.5</span> + c1; <span class="comment">//隐式调用类型转换函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">36.44</span><br></pre></td></tr></table></figure>
<h2 id="本章小结">本章小结</h2>
<p>运算符重载不是每个程序必须具有的功能，它的出现只是为了增加程序的易读性。</p>
<p>运算符重载不是新的机制，其实质是函数重载。与函数重载不同的是，运算符重载在参数上有限制。</p>
<p>运算符重载有两种形式：重载为类的成员函数、重载为类的友元函数。当运算符重载为成员函数时，左操作数一定是当前对象本身，而重载为友元函数时，该运算符所涉及的所有操作数都必须出现在函数的参数列表当中。操作数出现的顺序按照参数从左到右出现的顺序决定。</p>
<p>类的友元可以访问类的所有成员。友元可以是普通函数，其他类的成员函数，也可以是其他类。友元关系既不能传递、也不可逆。</p>
<p>友元不是纯面向对象的产物，它在类之间、类与普通函数之间共享了内部封装的数据，破坏了类的封装性，设计它的目的是为了实用。因此，在实际编程过程中，应尽量避免使用友元。</p>
<p>类类型转换函数只能是成员函数，不能是友元函数。<strong>转换函数的操作数是对象</strong>。</p>
<h2 id="测试-3">测试</h2>
<p>1.改正下面代码中的错误。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span>  <span class="keyword">public</span>:</span><br><span class="line">        Animal()&#123;itsWeight=<span class="number">0</span>;itsAge=<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">int</span> itsWeight;</span><br><span class="line">        <span class="keyword">int</span> itsAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetValue</span><span class="params">(Animal &amp; ta, <span class="keyword">int</span> tw, <span class="keyword">int</span> tn)</span></span></span><br><span class="line"><span class="function"></span>&#123;  ta.itsWeight=tw;</span><br><span class="line">    ta.itsAge=tn;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  Animal peppy;</span><br><span class="line">    SetValue(peppy,<span class="number">7</span>,<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.要求重载运算符“+”，使之能用于矩阵相加(分别重载为类的成员函数和友元函数),实现两个2行3列矩阵的相加。</p>
<h1 id="继承与派生">继承与派生</h1>
<h2 id="继承的引出">继承的引出</h2>
<h3 id="共性与差别的表示">共性与差别的表示</h3>
<ul>
<li>孤立的类只能描述实体集合的特征同一性，而客观世界中实体集合的划分通常还要考虑实体特征方面有关联的相似性。</li>
<li>“相似”——既有共同点，又有差别
<ul>
<li>内涵的相似性：在客观世界中具有一般— 特殊的关系。（例如：雇员和经理。）</li>
<li>结构的相似性：具有相似的表示。（例如：飞机仪表盘的仪表）</li>
</ul></li>
<li>如果将相似的事物用不同的类型来表示，能够表示其差别，但体现不了它们之间存在共性的事实，且共性的表示也可能不一致。当扩充维护过程中需要对其共性部分进行修改时，就面临着保持一致性的问题。</li>
<li>如果将相似的事物用相同的类型来表示，则体现其差别就十分困难，且失去了类型化的支持。一旦需扩充和修改也将影响用此种类型表示的所有其他事物。</li>
</ul>
<h3 id="继承性inheritance">继承性（inheritance）</h3>
<p>定义：在类之间既能体现其共性和差别，又能给出其间存在共性和差别关系的信息，还能将这样的关系按照需要进行传递的类型化机制。</p>
<p>继承是OOP中最关键的一方面</p>
<ul>
<li>程序设计
<ul>
<li>减少冗余代码</li>
<li>不加修改地重用已经过测试的代码</li>
</ul></li>
<li>设计
<ul>
<li>分类法是人们用于组织信息的自然方法</li>
<li>应该按照同样的方法（继承）来组织软件</li>
</ul></li>
<li>软件工程
<ul>
<li>灵活性－派生类可以覆盖基类方法、添加新的属性和行为</li>
<li>扩展性－派生类可以适应新创建的元素</li>
</ul></li>
</ul>
<h2 id="派生类的定义">派生类的定义</h2>
<p>派生是指由基类创建新类的过程，派生类的定义格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class &lt;派生类名&gt;：&lt;继承方式&gt; &lt;基类名&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &lt;派生类新定义成员&gt;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;  <span class="comment">//基类成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A <span class="comment">//A派生了B，B继承了A，</span></span><br><span class="line">            <span class="comment">//B自动拥有A的成员</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> j;  <span class="comment">//定义派生类的新成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="派生后的访问权限控制">派生后的访问权限控制</h2>
<p>派生类继承了基类的数据成员和成员函数，它们在派生类中的访问属性由继承方式控制。</p>
<p>类的继承方式有public(公有继承)、protected(保护继承)和private(私有继承)三种。<strong>默认情况下为私有继承</strong>。</p>
<p>三种继承方式下派生类中基类成员的访问控制权限</p>
<table>
<thead>
<tr class="header">
<th></th>
<th><strong>公有继承</strong></th>
<th><strong>私有继承</strong></th>
<th><strong>保护继承</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>公有成员</strong></td>
<td><strong>公有</strong></td>
<td><strong>私有</strong></td>
<td><strong>保护</strong></td>
</tr>
<tr class="even">
<td><strong>私有成员</strong></td>
<td><strong>派生类成员不可访问</strong></td>
<td><strong>派生类成员不可访问</strong></td>
<td><strong>派生类成员不可访问</strong></td>
</tr>
<tr class="odd">
<td><strong>保护成员</strong></td>
<td><strong>保护</strong></td>
<td><strong>私有</strong></td>
<td><strong>保护</strong></td>
</tr>
</tbody>
</table>
<h3 id="公有继承">公有继承</h3>
<p>在派生类中，<strong>基类的公有成员和保护成员被继承后分别成为派生类的公有成员和保护成员</strong>。</p>
<p>派生类的新成员可以直接访问它们，而派生类的新成员<strong>不能</strong>直接<strong>访问</strong>基类的<strong>私有成员</strong>。在类外，<strong>派生类的对象可以访问</strong>继承下来的基类公有成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> //基类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//公有成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InitP</span><span class="params">(<span class="keyword">float</span> xx = <span class="number">0</span>, <span class="keyword">float</span> yy = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        X = xx;</span><br><span class="line">        Y = yy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">float</span> xOff, <span class="keyword">float</span> yOff)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        X += xOff;</span><br><span class="line">        Y += yOff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> X; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">//私有数据成员</span></span><br><span class="line">    <span class="keyword">float</span> X, Y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Point <span class="comment">//派生类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//新增公有成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InitR</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> w, <span class="keyword">float</span> h)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        InitP(x, y);</span><br><span class="line">        W = w;</span><br><span class="line">        H = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用基类公有成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetH</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> H; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetW</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> W; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">//新增私有数据成员</span></span><br><span class="line">    <span class="keyword">float</span> W, H;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rectangle rect;</span><br><span class="line">    <span class="comment">//声明Rectangle类的对象</span></span><br><span class="line">    rect.InitR(<span class="number">2</span>, <span class="number">3</span>, <span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">//设置矩形的数据</span></span><br><span class="line">    rect.Move(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">//移动矩形位置</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The date of rect(X,Y,W,H):"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; rect.GetX() &lt;&lt; <span class="string">","</span> &lt;&lt; rect.GetY() &lt;&lt; <span class="string">","</span> &lt;&lt; rect.GetW()</span><br><span class="line">         &lt;&lt; <span class="string">","</span> &lt;&lt; rect.GetH() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The date of rect(X,Y,W,H):</span><br><span class="line">5,5,20,10</span><br></pre></td></tr></table></figure>
<h3 id="保护继承">保护继承</h3>
<p>在派生类中，<strong>基类的公有成员和保护成员全部成为派生类的保护成员</strong>。</p>
<p>派生类的新成员可以直接访问它们，而派生类的新成员<strong>不能</strong>直接访问基类的私有成员。在类外，<strong>派生类的对象不能访问基类的所有成员</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> //基类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//公有成员</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InitP</span><span class="params">(<span class="keyword">float</span> xx = <span class="number">0</span>, <span class="keyword">float</span> yy = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        X = xx;</span><br><span class="line">        Y = yy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">float</span> xOff, <span class="keyword">float</span> yOff)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        X += xOff;</span><br><span class="line">        Y += yOff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> X; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">//保护成员</span></span><br><span class="line">    <span class="keyword">float</span> X, Y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">protected</span> Point</span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//新增外部接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InitR</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> w, <span class="keyword">float</span> h)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        InitP(x, y); <span class="comment">//派生类访问基类成员</span></span><br><span class="line">        W = w;</span><br><span class="line">        H = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">float</span> xOff, <span class="keyword">float</span> yOff)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Point::Move(xOff, yOff);</span><br><span class="line">        <span class="comment">//显式访问基类成员</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Point::GetX(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Point::GetY(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetH</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> H; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetW</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> W; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">//新增私有数据</span></span><br><span class="line">    <span class="keyword">float</span> W, H;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rectangle rect;           <span class="comment">//声明Rectangle类的对象</span></span><br><span class="line">    rect.InitR(<span class="number">2</span>, <span class="number">3</span>, <span class="number">20</span>, <span class="number">10</span>); <span class="comment">//设置矩形的数据</span></span><br><span class="line">    rect.Move(<span class="number">3</span>, <span class="number">2</span>);          <span class="comment">//移动矩形位置</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The data of rect(X,Y,W,H):"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; rect.GetX() &lt;&lt; <span class="string">","</span> &lt;&lt; rect.GetY() &lt;&lt; <span class="string">","</span> &lt;&lt; rect.GetW() &lt;&lt; <span class="string">","</span> &lt;&lt; rect.GetH() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The data of rect(X,Y,W,H):</span><br><span class="line">5,5,20,10</span><br></pre></td></tr></table></figure>
<p>保护成员具有两面性，对外界（如主函数或非派生类的成员函数）而言是不可见的，但对于它的派生类则是可见的。</p>
<h3 id="私有继承">私有继承</h3>
<p>在派生类中，<strong>基类的公有成员和保护成员全部成为派生类的私有成员</strong>。</p>
<p>派生类的新成员可以直接访问它们，而派生类的新成员<strong>不能</strong>直接访问基类的私有成员。在类外，<strong>派生类的对象不能访问基类的所有成员</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> //基类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//公有成员</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InitP</span><span class="params">(<span class="keyword">float</span> xx = <span class="number">0</span>, <span class="keyword">float</span> yy = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        X = xx;</span><br><span class="line">        Y = yy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">float</span> xOff, <span class="keyword">float</span> yOff)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        X += xOff;</span><br><span class="line">        Y += yOff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> X; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">//保护成员</span></span><br><span class="line">    <span class="keyword">float</span> X, Y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">private</span> Point</span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//新增外部接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InitR</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> w, <span class="keyword">float</span> h)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        InitP(x, y); <span class="comment">//派生类访问基类成员</span></span><br><span class="line">        W = w;</span><br><span class="line">        H = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">float</span> xOff, <span class="keyword">float</span> yOff)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Point::Move(xOff, yOff);</span><br><span class="line">        <span class="comment">//显式访问基类成员</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Point::GetX(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Point::GetY(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetH</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> H; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetW</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> W; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">//新增私有数据</span></span><br><span class="line">    <span class="keyword">float</span> W, H;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rectangle rect;           <span class="comment">//声明Rectangle类的对象</span></span><br><span class="line">    rect.InitR(<span class="number">2</span>, <span class="number">3</span>, <span class="number">20</span>, <span class="number">10</span>); <span class="comment">//设置矩形的数据</span></span><br><span class="line">    rect.Move(<span class="number">3</span>, <span class="number">2</span>);          <span class="comment">//移动矩形位置</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The data of rect(X,Y,W,H):"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; rect.GetX() &lt;&lt; <span class="string">","</span> &lt;&lt; rect.GetY() &lt;&lt; <span class="string">","</span> &lt;&lt; rect.GetW() &lt;&lt; <span class="string">","</span> &lt;&lt; rect.GetH() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The data of rect(X,Y,W,H):</span><br><span class="line">5,5,20,10</span><br></pre></td></tr></table></figure>
<p>不能在派生类构造函数体中显式调用基类构造函数来初始化基类成员！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> //基类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">float</span> xx = <span class="number">0</span>, <span class="keyword">float</span> yy = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        X = xx;</span><br><span class="line">        Y = yy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span><span class="params">(<span class="keyword">float</span> xOff, <span class="keyword">float</span> yOff)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        X += xOff;</span><br><span class="line">        Y += yOff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> X; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> X, Y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Point</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rectangle(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> w, <span class="keyword">float</span> h) <span class="comment">//派生类构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        Point(x, y); <span class="comment">//调用基类构造函数</span></span><br><span class="line">        W = w;</span><br><span class="line">        H = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetH</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> H; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">GetW</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> W; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> W, H;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Rectangle <span class="title">rect</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">20</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//声明Rectangle类的对象</span></span><br><span class="line">    rect.Move(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">//移动矩形位置</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The date of rect(X,Y,W,H):"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; rect.GetX() &lt;&lt; <span class="string">","</span> &lt;&lt; rect.GetY() &lt;&lt; <span class="string">","</span> &lt;&lt; rect.GetW() &lt;&lt; <span class="string">","</span> &lt;&lt; rect.GetH() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The data of rect(X,Y,W,H):</span><br><span class="line">3,2,20,10</span><br></pre></td></tr></table></figure>
<h2 id="派生类的构造函数和析构函数">派生类的构造函数和析构函数</h2>
<h3 id="派生类的构造函数和析构函数-1">派生类的构造函数和析构函数</h3>
<p>解决的办法是通过成员初始化表来完成，在成员初始化表中可以显式调用基类构造函数对基类成员初始化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;派生类名&gt;(&lt;总参数表&gt;)：&lt;基类名&gt;(&lt;参数表1&gt;)，&lt;对象成员名&gt;(&lt;参数表2&gt;)</span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类数据成员的初始化&gt;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Rectangle(<span class="keyword">float</span> x,<span class="keyword">float</span> y,<span class="keyword">float</span> w,<span class="keyword">float</span> h):Point(x,y)</span><br><span class="line">&#123;W=w;H=h;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Rectangle(<span class="keyword">float</span> x,<span class="keyword">float</span> y,<span class="keyword">float</span> w,<span class="keyword">float</span> h):Point(x,y),W(w),H(h)&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数和析构函数的调用顺序-1">构造函数和析构函数的调用顺序</h3>
<p>构造函数调用顺序为：基类的构造函数→对象成员构造函数→派生类的构造函数。</p>
<p>析构函数调用顺序刚好相反。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A Constructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A Destructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B Constructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~B() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B Destructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A Constructor</span><br><span class="line">B Constructor</span><br><span class="line">B Destructor</span><br><span class="line">A Destructor</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A Constructor1"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    A(<span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        x1 = i;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A Constructor2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispa</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"x1="</span> &lt;&lt; x1 &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B Constructor1"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    B(<span class="keyword">int</span> i) : A(i + <span class="number">10</span>) <span class="comment">//成员初始化表</span></span><br><span class="line">    &#123;</span><br><span class="line">        x2 = i;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B Constructor2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispb</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dispa(); <span class="comment">//调用基类成员函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"x2="</span> &lt;&lt; x2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    b.dispb();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A Constructor2</span><br><span class="line">B Constructor2</span><br><span class="line">x1&#x3D;12</span><br><span class="line">x2&#x3D;2</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>当基类中没有显式定义构造函数，或定义了无参构造函数时，派生类构造函数的初始化表可以省略对基类构造函数的调用，而采用<strong>隐含调用</strong>。</p>
<p>当基类的构造函数使用一个或多个参数时，<strong>派生类需要定义构造函数</strong>，提供将参数传递给基类构造函数的途径。这时，<strong>派生类构造函数的函数体可能为空</strong>，仅起到参数传递作用。</p>
<p>如果在基类中既定义了无参构造函数，又定义了带参构造函数，则在定义派生类构造函数时，既可以包含基类构造函数和参数，也可以不包含基类构造函数。</p>
<p>无论是哪种继承方式，基类的私有成员在派生类中都是不可被访问的。只能通过基类的成员函数访问基类的私有数据成员</p>
<p><strong>如果在一个派生类中要访问基类中的私有成员，可以将这个派生类声明为基类的友元。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">    friend class  Derive;</span><br><span class="line">     .....</span><br><span class="line">&#125;</span><br><span class="line">class Derive:public Base &#123;</span><br><span class="line">     ..... &#x2F;&#x2F; 直接使用Base中的私有成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>友元关系是不能继承的。B类是A类的友元，C类是B类的派生类，则C类和A类之间没有任何友元关系，除非C类声明A类是友元。</p>
<h2 id="多继承与虚基类">多继承与虚基类</h2>
<p>一个类可以从一个或者多个基类派生而来。根据派生类继承基类的个数，将继承分为<strong>单</strong>继承和<strong>多</strong>继承。</p>
<p>当派生类有多个基类时称为多继承。单继承可以看作是多继承的一个特例，多继承可以看作是多个单继承的组合，它们有很多相同特性。</p>
<h3 id="多继承派生类的定义">多继承派生类的定义</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class &lt;派生类名&gt;：&lt;继承方式&gt; &lt;基类名1&gt;，…，&lt;继承方式&gt; &lt;基类名n&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &lt;派生类新定义成员&gt;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<h3 id="多继承派生类的构造函数">多继承派生类的构造函数</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;派生类名&gt;(&lt;总参数表&gt;):&lt;基类名1&gt;(&lt;参数表1&gt;)，…，&lt; 基类名n&gt; (&lt;参数表n&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    &lt;派生类数据成员的初始化&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><总参数表>包含完成所有基类初始化所需的参数</p>
<p>构造函数调用顺序是：先调用所有基类的构造函数，再调用对象成员类构造函数，最后调用派生类的构造函数。</p>
<p>处于同一层次的各基类构造函数的调用顺序取决于<strong>定义派生类时所指定的基类顺序</strong>，与派生类构造函数中所定义的成员初始化列表顺序无关。</p>
<p>如果有多个成员类对象，则构造函数的调用顺序是<strong>对象在类中被声明的顺序</strong>，而不是它们出现在成员初始化表中的顺序。</p>
<p>析构函数的调用顺序与构造函数的调用顺序相反。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        a = i;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A Constructor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"a="</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~A()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A Destructor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> j)</span><br><span class="line">    &#123;</span><br><span class="line">        b = j;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B Constructor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"b="</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~B()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B Destructor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C(<span class="keyword">int</span> k) : A(k + <span class="number">2</span>), B(k - <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = k;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"C Constructor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        A::disp();</span><br><span class="line">        B::disp();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"c="</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~C()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"C Destructor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    obj.disp();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B Constructor</span><br><span class="line">A Constructor</span><br><span class="line">C Constructor</span><br><span class="line">a&#x3D;12</span><br><span class="line">b&#x3D;8</span><br><span class="line">c&#x3D;10</span><br><span class="line">C Destructor</span><br><span class="line">A Destructor</span><br><span class="line">B Destructor</span><br></pre></td></tr></table></figure>
<h3 id="多继承引起的二义性问题">多继承引起的二义性问题</h3>
<h4 id="两个基类有同名成员">两个基类有同名成员</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="keyword">public</span> :</span><br><span class="line">      <span class="keyword">int</span> a ;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="keyword">public</span> :</span><br><span class="line">      <span class="keyword">int</span> a ;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A, <span class="keyword">public</span> B</span><br><span class="line">&#123;<span class="keyword">public</span> :</span><br><span class="line">      <span class="keyword">int</span> b ;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译错误</span></span><br><span class="line">C c1;</span><br><span class="line">c1.a=<span class="number">3</span>;</span><br><span class="line">c1.display();</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正确写法</span></span><br><span class="line">C c1;</span><br><span class="line">c1.A::a=<span class="number">3</span>;</span><br><span class="line">c1.A::display();</span><br></pre></td></tr></table></figure>
<h4 id="两个基类和派生类三者都有同名成员">两个基类和派生类三者都有同名成员</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="keyword">public</span> :</span><br><span class="line">      <span class="keyword">int</span> a ;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span><span class="keyword">public</span> :</span><br><span class="line">      <span class="keyword">int</span> a ;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A, <span class="keyword">public</span> B</span><br><span class="line">&#123;<span class="keyword">public</span> :</span><br><span class="line">      <span class="keyword">int</span> a ;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;访问的是派生类C中的成员</span><br><span class="line">C c1;</span><br><span class="line">c1.a&#x3D;3;</span><br><span class="line">c1.display();</span><br></pre></td></tr></table></figure>
<p>基类的同名成员在派生类中被屏蔽，或者说，派生类新增加的同名成员隐藏了基类中的同名成员</p>
<h4 id="如果类a和类b是从同一个基类派生的">如果类A和类B是从同一个基类派生的</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">N</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A::a ="</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> N</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="keyword">int</span> a1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> N</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="keyword">int</span> a2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A, <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="keyword">int</span> a3;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"a3 ="</span>&lt;&lt; a3 &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="虚基类">虚基类</h3>
<p>为避免对基类成员访问的二义性问题，可以将<strong>直接基类（如A、B）的共同基类（如N）</strong>设置为<strong>虚基类</strong>，这样共同基类（N）在内存中只有一个副本存在。</p>
<p>虚基类的定义格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class &lt;派生类名&gt;:virtual &lt;继承方式&gt;&lt;共同基类名&gt;;</span><br></pre></td></tr></table></figure>
<p>【说明】引进虚基类后，派生类对象中只存在一个虚基类成员的副本。</p>
<p>为了保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类，否则仍然会出现对基类的多次继承。</p>
<p>【例】示例虚基类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; a = <span class="number">10</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A1() &#123; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A2() &#123; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> A1, A2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h4 id="构造函数的调用顺序">构造函数的调用顺序</h4>
<p>虚基类的初始化与一般多继承的初始化在语法上相同，但构造函数的调用顺序有所不同，规则如下：</p>
<ul>
<li>先调用虚基类的构造函数，再调用非虚基类的构造函数。</li>
<li>若同一层次中包含多个虚基类，其调用顺序为定义时的顺序。</li>
<li>若虚基类由非虚基类派生而来，则仍按先调用基类构造函数，再调用派生类构造函数的顺序。</li>
</ul>
<p>【例】示例多继承中有虚基类的情况，分析构造函数的调用顺序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base1()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"class Base1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base2()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"class Base2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Level1</span> :</span> <span class="keyword">public</span> Base2, <span class="keyword">virtual</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Level1()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"class Level1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Level2</span> :</span> <span class="keyword">public</span> Base2, <span class="keyword">virtual</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Level2()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"class Level2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopLevel</span> :</span> <span class="keyword">public</span> Level1, <span class="keyword">virtual</span> <span class="keyword">public</span> Level2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TopLevel()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"class TopLevel"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TopLevel obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Base1</span><br><span class="line">class Base2</span><br><span class="line">class Level2</span><br><span class="line">class Base2</span><br><span class="line">class Level1</span><br><span class="line">class TopLevel</span><br></pre></td></tr></table></figure>
<h4 id="虚基类的初始化">虚基类的初始化</h4>
<p>如果在虚基类中只定义了带参数的构造函数，则要在其<strong>所有</strong>派生类（包括直接派生类或间接派生类）中，通过构造函数的初始化表对虚基类进行初始化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123; A(int i)&#123;&#125; … &#125;;</span><br><span class="line">class B:virtual public A</span><br><span class="line">&#123; B(int n):A(n)&#123;&#125;… &#125;;</span><br><span class="line">class C:virtual public A</span><br><span class="line">&#123; C(int n):A(n)&#123;&#125;… &#125;; </span><br><span class="line">class D:public B, public C</span><br><span class="line">&#123; D(int n):A(n),B(n),C(n)&#123;&#125;… &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>如果多继承不牵涉到对同一基类的派生，就没有必要定义虚基类。</p>
<p>使用多继承时要十分小心，经常会出现二义性问题。</p>
<p>能用单一继承解决的问题就不要使用多继承。</p>
<h2 id="测试-4">测试</h2>
<p>1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><br><span class="line">    &#123;</span><br><span class="line">        a = i;</span><br><span class="line">        b = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a += x;</span><br><span class="line">        b += y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; a &lt;&lt; <span class="string">","</span> &lt;&lt; b &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k, <span class="keyword">int</span> l) : A(i, j), x(k), y(l) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">","</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; move(<span class="number">3</span>, <span class="number">5</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; A::show(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">aa</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    aa.show();</span><br><span class="line">    <span class="function">B <span class="title">bb</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    bb.fun();</span><br><span class="line">    bb.A::show();</span><br><span class="line">    bb.B::show();</span><br><span class="line">    bb.f1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> i, <span class="keyword">int</span> j) : a(i), b(j) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a += x;</span><br><span class="line">        b += y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span> &lt;&lt; a &lt;&lt; <span class="string">","</span> &lt;&lt; b &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">private</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k, <span class="keyword">int</span> l) : A(i, j), x(k), y(l) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">","</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; move(<span class="number">3</span>, <span class="number">5</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; A::show(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">aa</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    aa.show();</span><br><span class="line">    <span class="function">B <span class="title">bb</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    bb.fun();</span><br><span class="line">    bb.show();</span><br><span class="line">    bb.f1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    base(<span class="keyword">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"constructing base  class "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        n = a;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"n="</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~base()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"destructing base class "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    base1(<span class="keyword">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"constructing base1 class "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        m = a;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"m="</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~base1()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"destructing base1 class "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">subs</span> :</span> <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line">    base bobj;</span><br><span class="line">    base1 bobj1;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    subs(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span><br><span class="line">        : base(a), bobj1(b), bobj(c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"constructing sub class "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        x = d;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"x="</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~subs()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"destructing sub class "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">subs <span class="title">s</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多态性与虚函数">多态性与虚函数</h1>
<h2 id="类型兼容规则">类型兼容规则</h2>
<p><strong>类型兼容规则</strong>是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。</p>
<p>通过公有继承，派生类得到了基类中除构造函数、析构函数之外的所有成员。这样，<strong>公有派生类实际就具备了基类的所有功能</strong>，凡是基类能解决的问题，公有派生类都可以解决。</p>
<p>类型兼容规则中所指的替代包括以下情况： * 派生类的对象可以赋值给基类的对象。 * 派生类的对象可以初始化基类的引用。 * 派生类的对象的地址可以赋值给基类的指针变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>…&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;…&#125;;</span><br><span class="line">A a, *pa;</span><br><span class="line">B b;</span><br></pre></td></tr></table></figure>
<p>a=b; 派生类的对象可以赋值给基类的对象。即用派生类对象中从基类继承来的成员，逐个赋值给基类对象的成员。 * 只能用派生类对象对其基类对象赋值，而不能用基类对象对其派生类对象赋值。 * 同一基类的不同派生类对象之间也不能赋值。</p>
<p>A &amp;a1=b; 派生类的对象可以初始化基类的引用 。</p>
<p>pa=&amp;b; 派生类的对象的地址可以赋值给基类的指针变量 。</p>
<p>在替代之后，派生类对象就可以作为基类的对象使用，但<strong>只能访问从基类继承的成员</strong>。</p>
<p>对象只能调用转换后类型中定义的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BaseClass baseObject;</span><br><span class="line">DerivedClass derivedObject;</span><br><span class="line">baseObject&#x3D;derivedObject;</span><br><span class="line"></span><br><span class="line">derivedObject.derivedFun(); 	√</span><br><span class="line">derivedObject.baseFun(); 		√</span><br><span class="line"></span><br><span class="line">baseObject.baseFun(); 			√</span><br><span class="line">baseObject.derivedFun(); 		×</span><br></pre></td></tr></table></figure>
<p>【例】示例类型兼容规则的应用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>        　　　　　</span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;   <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base class"</span>&lt;&lt;<span class="built_in">endl</span>;   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive1</span>:</span><span class="keyword">public</span> Base    </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;   <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derivel class"</span>&lt;&lt;<span class="built_in">endl</span>;   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derive2</span>:</span><span class="keyword">public</span> Base   </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;   <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derive2 class"</span>&lt;&lt;<span class="built_in">endl</span>;   &#125;</span><br><span class="line">&#125;;	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Base obj1,*p;   </span><br><span class="line"><span class="comment">//定义基类对象obj1和基类对象指针p</span></span><br><span class="line">    Derive1 obj2;   </span><br><span class="line">    Derive2 obj3;   </span><br><span class="line">    p=&amp;obj1;        <span class="comment">//p指向obj1</span></span><br><span class="line">    p-&gt;who();       </span><br><span class="line"><span class="comment">//通过指针p调用obj1的公有成员函数//who()</span></span><br><span class="line">    p=&amp;obj2;        <span class="comment">//p指向obj2</span></span><br><span class="line">    p-&gt;who();       </span><br><span class="line"><span class="comment">//p只能访问从基类继承下来的who()</span></span><br><span class="line">    p=&amp;obj3;   　　 <span class="comment">//p指向obj2</span></span><br><span class="line">    p-&gt;who();       </span><br><span class="line"><span class="comment">//p只能访问从基类继承下来的who()</span></span><br><span class="line">    obj2.who();</span><br><span class="line">    obj3.who();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Base class</span><br><span class="line">Base class</span><br><span class="line">Base class</span><br><span class="line">Derive1 class</span><br><span class="line">Derive2 class</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>        　　　　　</span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">Student(<span class="keyword">int</span> n)    &#123;  num=n;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">"num:"</span>&lt;&lt;num&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graduate</span>:</span><span class="keyword">public</span> Student    </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">Graduate(<span class="keyword">int</span> n,<span class="built_in">string</span> name):Student(n),name(nam)</span><br><span class="line">&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; Student::display();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;“name:<span class="string">"&lt;&lt;name&lt;&lt;endl;&#125;</span></span><br><span class="line"><span class="string">private:</span></span><br><span class="line"><span class="string">string name;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">int main()</span></span><br><span class="line"><span class="string">&#123; </span></span><br><span class="line"><span class="string">    Student stud1(1001);   </span></span><br><span class="line"><span class="string">    Graduate grad1(2001,”Wang”);   </span></span><br><span class="line"><span class="string"> Student *pt=&amp;stud1;;   </span></span><br><span class="line"><span class="string"> pt-&gt;display();       </span></span><br><span class="line"><span class="string"> pt=&amp;grad1;       </span></span><br><span class="line"><span class="string"> pt-&gt;display();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">   &#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num:1001</span><br><span class="line">num:2001</span><br></pre></td></tr></table></figure>
<p>如果基类指针要访问派生类的成员函数，怎么办？</p>
<p>C++提供了多态机制来解决这个问题。</p>
<p>类型兼容规则是C++多态的重要基础。</p>
<h2 id="多态">多态</h2>
<p>多态（Polymorphism）是指具有相似功能的不同函数使用同一个名称来实现，从而可以使用相同的调用方式来调用这些具有不同功能的同名函数的特性。</p>
<p>调用同一个函数名，可以根据需要实现不同的功能。</p>
<p>从系统实现的角度，多态性分为两类：</p>
<p><strong>静态多态性</strong>：在程序编译时系统就能决定调用的是哪个函数。又称为编译时的多态性。静态多态性是通过函数的重载实现的（包括运算符重载）。</p>
<p><strong>动态多态性</strong>：在程序运行过程中才动态地确定操作所针对的对象。又称为运行时的多态性。动态多态性是通过虚函数实现的。</p>
<h2 id="联编">联编</h2>
<p>C++采用联编技术来支持多态。</p>
<p>联编是指把一个标识符名和一个存储地址联系在一起的过程。在多态的实现过程中，确定调用哪个同名函数的过程就是联编，又称绑定。</p>
<h3 id="联编的分类">联编的分类</h3>
<ul>
<li>按照联编进行的阶段来划分</li>
<li>静态联编：在<strong>编译阶段</strong>完成的联编，即在编译时确定调用哪个函数代码，通常在重载时使用。静态联编支持编译时多态。</li>
<li>动态联编：动态联编是指在程序执行之前，根据函数名和参数无法确定应该调用哪一个函数，必须在程序的执行过程中，<strong>根据具体的执行情况来动态地确定</strong>。在<strong>运行阶段</strong>完成的联编，通过继承和虚函数来实现。动态联编支持运行时多态。</li>
</ul>
<p><img src="image-20201201141728018.png" alt="image-20201201141728018" style="zoom:50%;" /></p>
<p>【例】静态联编示例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A student"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GStudent</span> :</span> <span class="keyword">public</span> Student</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A graduate student"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student s1, *ps;</span><br><span class="line">    GStudent s2;</span><br><span class="line">    s1.print();</span><br><span class="line">    s2.print();</span><br><span class="line">    s2.Student::print();</span><br><span class="line">    ps = &amp;s1;</span><br><span class="line">    ps-&gt;print(); <span class="comment">//基类指针和基类成员函数发生关联</span></span><br><span class="line">    ps = &amp;s2;</span><br><span class="line">    ps-&gt;print();</span><br><span class="line">    <span class="comment">//希望调用对象s2的输出函数，但调用的却是对象s1的输出函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A student</span><br><span class="line">A graduate student</span><br><span class="line">A student</span><br><span class="line">A student</span><br><span class="line">A student</span><br></pre></td></tr></table></figure>
<h2 id="虚函数">虚函数</h2>
<p>由虚函数实现的动态多态：同一类族中不同类的对象，对同一函数调用做出不同的响应。</p>
<p>虚函数的使用：</p>
<ul>
<li>类之间应满足类型兼容规则。</li>
<li>同名声明虚函数。</li>
<li>通过指针、引用来访问虚函数。</li>
</ul>
<p>虚函数就是在基类中被关键字virtual说明、并在一个或多个派生类中被重新定义的成员函数。</p>
<p>声明虚函数的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtual &lt;函数值类型&gt; &lt;函数名&gt;(&lt;参数表&gt;);</span><br></pre></td></tr></table></figure>
<p>若要访问派生类中相同名字的函数，必须将基类中的<strong>同名函数定义为虚函数</strong>，这样，将不同的派生类对象的地址赋给基类的指针变量后，就可以<strong>动态地根据这种赋值语句调用不同类中的函数</strong>。</p>
<p>在程序运行时，不同类的对象调用各自的虚函数，这就是动态多态。</p>
<p>实现动态的多态性时，必须使用<strong>基类类型的指针变量</strong>或<strong>对象引用</strong>，并使其<strong>指向不同的派生类对象</strong>，并通过调用指针或引用所指向的虚函数才能实现动态的多态性。</p>
<p>【例】动态联编示例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="comment">//定义虚函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A student"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GStudent</span> :</span> <span class="keyword">public</span> Student</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A graduate student"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student s1, *ps;</span><br><span class="line">    GStudent s2;</span><br><span class="line">    s1.print();</span><br><span class="line">    s2.print();</span><br><span class="line">    s2.Student::print();</span><br><span class="line">    ps = &amp;s1;</span><br><span class="line">    ps-&gt;print();</span><br><span class="line">    ps = &amp;s2;</span><br><span class="line">    ps-&gt;print();</span><br><span class="line">    <span class="comment">//对象指针调用虚函数，采用动态联编方式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A student</span><br><span class="line">A graduate student</span><br><span class="line">A student</span><br><span class="line">A student</span><br><span class="line">A graduate student</span><br></pre></td></tr></table></figure>
<p>一个函数一旦被声明为虚函数，则无论声明它的类被继承了多少层，在每一层派生类中该函数都保持虚函数特性。因此，在派生类中重新定义该函数时，可以省略关键字virtual。</p>
<p>如果将上例中的Student类改为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">如果将上例中的Student类改为：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>; 　<span class="comment">//虚函数的声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Student::print</span><span class="params">()</span> <span class="comment">//虚函数的实现  X</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	  <span class="built_in">cout</span>&lt;&lt;<span class="string">"A student"</span>&lt;&lt;<span class="built_in">endl</span>;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当虚函数声明与实现分开时，virtual关键字只用在虚函数的声明中，不能用在虚函数的实现中。</p>
<p>只有通过<strong>对象指针或对象引用</strong>来调用虚函数，才能实现动态联编。如果采用对象来调用虚函数，则采用的是静态联编方式。</p>
<p>在派生类中重新定义虚函数时，其函数原型包括返回类型、函数名、参数个数、类型和顺序，都<strong>必须</strong>与基类中的原型<strong>相同</strong>。</p>
<p>【例】采用对象引用调用虚函数，进而实现动态联编。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="comment">//定义虚函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A student"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GStudent</span> :</span> <span class="keyword">public</span> Student</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A graduate student"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Student &amp;s)</span> <span class="comment">//对象引用作参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.print(); <span class="comment">//采用对象引用调用虚函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student s1;</span><br><span class="line">    GStudent s2;</span><br><span class="line">    fun(s1);</span><br><span class="line">    fun(s2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A student</span><br><span class="line">A graduate student</span><br></pre></td></tr></table></figure>
<p>示例使用不恰当的虚函数的效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Base</span><br><span class="line">&#123;     public: virtual int func(int x)</span><br><span class="line">	&#123;   cout &lt;&lt;&quot;This is Base class &quot;;</span><br><span class="line">                 return x;  &#125;  &#125;;</span><br><span class="line">class Subclass :public Base</span><br><span class="line">&#123;     public:  virtual   float  func(int x)  &#x2F;&#x2F;编译错误</span><br><span class="line">	      &#123;   cout &lt;&lt;&quot;This is Sub class &quot;</span><br><span class="line">                         float y&#x3D;float(x);	          	           </span><br><span class="line">                         return y;   &#125; &#125;;	</span><br><span class="line">void test (Base&amp; x)</span><br><span class="line">&#123;	cout&lt;&lt;x.func(5)&lt;&lt;endl; &#125;</span><br><span class="line">int main ( )</span><br><span class="line">&#123; Base bc;</span><br><span class="line">   Subclass sc;</span><br><span class="line">   test (bc);</span><br><span class="line">   test (sc);   return 0;&#125;</span><br></pre></td></tr></table></figure>
<p>只要定义一个基类的对象指针或对象引用，就可以调用期望的虚函数。</p>
<p>在实际应用中，不必过多地考虑类的层次关系，无须显式地写出虚函数的路径，只须将对象指针指向相应的派生类或引用相应的对象，通过动态联编就可以对消息做出正确的反应。</p>
<p><strong>虚函数小结</strong></p>
<p>如果期望在派生类中重新定义一个成员函数，那么就应该在基类中把该函数设为virtual。</p>
<p>以单一指令调用不同函数，这种性质就是“多态”。</p>
<p>虚函数是C++语言的多态性质和动态绑定的关键。</p>
<p>虚函数派生下去仍是虚函数，而且可以省略virtual关键词。</p>
<p><strong>声明虚函数时要注意</strong></p>
<p>一般来说，可将类簇中具有共性的成员函数声明为虚函数，而具有个性的函数没有必要声明为虚函数。但是下面的情况例外：</p>
<ul>
<li><strong>静态成员函数和友元函数不能声明为虚函数</strong>。因为静态成员函数和友元函数不属于某一个对象，没有多态性的特征。</li>
<li><strong>内联成员函数不能声明为虚函数</strong>。因为内联函数的执行代码是明确的，在编译时已被替换，没有多态性的特征。如果将那些在类声明时就定义内容的成员函数声明为虚函数，此时函数不是内联函数，而以多态性出现。</li>
<li><strong>构造函数不能是虚函数</strong>。构造函数是在定义对象时被调用，完成对象的初始化，此时对象还没有完全建立。虚函数作为运行时的多态性的基础，主要是针对对象的，而构造函数是在对象产生之前运行的。所以，将构造函数声明为虚函数是没有意义的。</li>
<li><strong>析构函数可以是虚函数</strong>。比如释放内存时，由于实施多态性时是通过将基类的指针指向派生类的对象来完成的，如果删除该指针，就会调用该指针指向的派生类的析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象才被完全释放。</li>
</ul>
<h3 id="虚析构函数">虚析构函数</h3>
<p>虚析构函数的声明格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">虚析构函数的声明格式如下：</span><br></pre></td></tr></table></figure>
<p>如果一个类的析构函数是虚函数，那么，由它派生的所有子类的析构函数也是虚函数。</p>
<p>【例】虚析构函数示例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base() &#123;&#125;</span><br><span class="line">    ~Base() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">" Base destructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived() &#123;&#125;</span><br><span class="line">    ~Derived() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived destructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *b = <span class="keyword">new</span> Derived;</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Base destructor</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base destructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Derived() &#123;&#125;</span><br><span class="line">    ~Derived() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived destructor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *b = <span class="keyword">new</span> Derived;</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Derived destructor</span><br><span class="line">Base destructor</span><br></pre></td></tr></table></figure>
<p>利用虚函数可以使所设计的软件系统变得灵活，提高了代码的可重用性。</p>
<p>虚函数为一个类簇中所有派生类的同一行为提供了统一的接口，使得程序员在使用一个类簇时只须记住一个接口即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> X, Y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> X = <span class="number">0</span>, <span class="keyword">int</span> Y = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;X = X, <span class="keyword">this</span>-&gt;Y = Y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> <span class="comment">//求面积</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14159</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Point</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> radius; <span class="comment">//半径</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Circle(<span class="keyword">int</span> X, <span class="keyword">int</span> Y, <span class="keyword">double</span> R) : Point(X, Y)</span><br><span class="line">    &#123;</span><br><span class="line">        radius = R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">area</span><span class="params">()</span> <span class="comment">//求面积</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">P1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"P1.area()="</span> &lt;&lt; P1.area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">Circle <span class="title">C1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"C1.area()="</span> &lt;&lt; C1.area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Point *Pp;</span><br><span class="line">    Pp = &amp;C1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Pp-&gt;area()="</span> &lt;&lt; Pp-&gt;area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Point &amp;Rp = C1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Rp.area()="</span> &lt;&lt; Rp.area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P1.area()&#x3D;0</span><br><span class="line">C1.area()&#x3D;1256.64</span><br><span class="line">Pp-&gt;area()&#x3D;1256.64</span><br><span class="line">Rp.area()&#x3D;1256.64</span><br></pre></td></tr></table></figure>
<p>当在派生类中定义了虚函数的重载函数，但并没有重新定义虚函数时，与虚函数同名的重载函数<strong>覆盖</strong>了派生类中的虚函数。此时试图通过派生类对象、指针、引用调用派生类的虚函数就会产生错误。</p>
<p>将上例中Circle类的double area( )改为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double area(int i)      &#123;    return PI*radius*radius; &#125;</span><br></pre></td></tr></table></figure>
<p>那么virtual double area( ) 被double area(int i)覆盖，下面调用形式是<strong>错误</strong>的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Circle C1；</span><br><span class="line">cout&lt;&lt;&quot;C1.area( )&#x3D;&quot;&lt;&lt;C1.area( )&lt;&lt;endl;  </span><br><span class="line">Circle *Pp1&#x3D;&amp;C1;</span><br><span class="line">cout&lt;&lt;&quot;Pp1-&gt;area( )&#x3D;&quot;&lt;&lt;Pp1-&gt;area( )&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>不改变Circle类中原来的虚函数，并加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double area(int i)   &#123;	return PI*radius*radius; &#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果与原来例子结果相同。</p>
<p>如果在派生类中没有重新定义虚函数，则不实现动态联编，派生类的对象将使用基类的虚函数代码。</p>
<p>在Circle类不定义任何area函数, 程序运行的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P1.area( )&#x3D;0</span><br><span class="line">C1.area( )&#x3D;0        &#x2F;&#x2F; 调用了基类的virtual double area( )</span><br><span class="line">Pp-&gt;area( )&#x3D;0       &#x2F;&#x2F; 调用了基类的virtual double area( )</span><br><span class="line">Rp.area( )&#x3D;0        &#x2F;&#x2F; 调用了基类的virtual double area( )</span><br></pre></td></tr></table></figure>
<h2 id="继承虚属性">继承虚属性</h2>
<p>基类中说明的虚函数具有<strong>自动向下</strong>传给它的派生类的性质。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"This is Base class "</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subclass1</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"This is Sub1 class "</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subclass2</span> :</span> <span class="keyword">public</span> Subclass1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"This is Sub2 class "</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Subclass2 sc2;</span><br><span class="line">    Base &amp;bc = sc2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; bc.func(<span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Subclass1 &amp;sc1 = sc2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sc1.func(<span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is Base class 5</span><br><span class="line">This is Sub2 class 5</span><br></pre></td></tr></table></figure>
<p>一个类中的虚函数说明只对派生类中重定义的函数有影响，<strong>对</strong>它的<strong>基类中的函数并没有影响</strong>。</p>
<h2 id="纯虚函数">纯虚函数</h2>
<p>纯虚函数用<strong>virtual</strong>声明，<strong>没有任何实现</strong>、必须由派生类重新定义该函数提供实现</p>
<p>纯虚函数的声明格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virtual &lt;函数值类型&gt; &lt;函数名&gt;(&lt;参数表&gt;)&#x3D;0;</span><br></pre></td></tr></table></figure>
<p>纯虚函数不需要定义实现方法，它的存在只是为了在派生类中被重新定义，只是为了提供一个多态的接口。</p>
<h2 id="抽象类">抽象类</h2>
<p>包含一个或多个纯虚函数的类称为抽象类。</p>
<p>如果派生类没有实现基类中的所有纯虚函数，派生类也是抽象类。</p>
<p>抽象类无法实例化，即不能创建抽象类的对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Base base1; ×</span><br></pre></td></tr></table></figure>
<p>抽象类不能用作<strong>参数类型、函数值类型或显式转换的类型</strong>，但可以声明指向抽象类的指针或引用，通过指针或引用来指向并访问派生类对象，从而实现动态多态。</p>
<h2 id="纯虚函数与函数体为空的虚函数">纯虚函数与函数体为空的虚函数</h2>
<p>区别：</p>
<ul>
<li>前者没有函数体,而后者有函数体；</li>
<li>前者所在的类是抽象类,不能直接进行实例化,而后者所在的类是可以实例化的。</li>
</ul>
<p>共同点：</p>
<ul>
<li>可以派生出新的类，然后在新类中给出虚函数新的实现，而且这种新的实现可以具有多态特征。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span> <span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123; x = <span class="number">1000</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//定义纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123; <span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123; y = <span class="number">2000</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"y="</span> &lt;&lt; y &lt;&lt; <span class="string">'\n'</span>; &#125; <span class="comment">//重新定义纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123; <span class="comment">//派生类</span></span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C() &#123; z = <span class="number">3000</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"z="</span> &lt;&lt; z &lt;&lt; <span class="string">'\n'</span>; &#125; <span class="comment">//重新定义纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *pa;</span><br><span class="line">    B b;</span><br><span class="line">    C c;</span><br><span class="line">    pa = &amp;b;</span><br><span class="line">    pa-&gt;print();</span><br><span class="line">    pa = &amp;c;</span><br><span class="line">    pa-&gt;print();</span><br><span class="line">    <span class="comment">// A  a;     pa=&amp;a;       pa-&gt;print(); 不能定义抽象类的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y&#x3D;2000</span><br><span class="line">z&#x3D;3000</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<ul>
<li><p>在定义纯虚函数时，不能定义虚函数的实现部分。</p></li>
<li><p>纯虚函数只有函数的名字而不具备函数的功能，<strong>在没有重新定义这种纯虚函数之前，不能调用这种函数</strong>。</p></li>
<li><p>抽象类只能作为派生类的基类，不能用来说明这种类的对象。</p></li>
<li><p>在以抽象类作为基类的派生类中必须有纯虚函数的实现部分，即必须有重定义纯虚函数的函数体。否则，这样的派生类也是抽象类，不能产生对象。</p></li>
</ul>
<p>【例】示例纯虚函数及抽象类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.14159</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shapes</span> //抽象类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setvalue</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> w = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = d;</span><br><span class="line">        y = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//纯虚函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> :</span> <span class="keyword">public</span> Shapes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">area</span><span class="params">()</span> <span class="comment">//计算矩形面积</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"area of rectangle:"</span> &lt;&lt; x * y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> :</span> <span class="keyword">public</span> Shapes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">area</span><span class="params">()</span> <span class="comment">//计算圆面积</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"area of circle:"</span> &lt;&lt; PI * x * x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shapes *ptr[<span class="number">2</span>]; <span class="comment">//声明抽象类指针</span></span><br><span class="line">    Square s1;      <span class="comment">//声明派生类对象</span></span><br><span class="line">    Circle c1;      <span class="comment">//声明派生类对象</span></span><br><span class="line">    ptr[<span class="number">0</span>] = &amp;s1;</span><br><span class="line">    <span class="comment">//抽象类指针指向派生类对象</span></span><br><span class="line">    ptr[<span class="number">0</span>]-&gt;setvalue(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">    ptr[<span class="number">0</span>]-&gt;area();</span><br><span class="line">    <span class="comment">//抽象类指针调用派生类成员函数,实现多态</span></span><br><span class="line">    ptr[<span class="number">1</span>] = &amp;c1;</span><br><span class="line">    <span class="comment">//抽象类指针指向派生类对象</span></span><br><span class="line">    ptr[<span class="number">1</span>]-&gt;setvalue(<span class="number">10</span>);</span><br><span class="line">    ptr[<span class="number">1</span>]-&gt;area();</span><br><span class="line">    <span class="comment">//抽象类指针调用派生类成员函数,实现多态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">area of rectangle:50</span><br><span class="line">area of circle:314.159</span><br></pre></td></tr></table></figure>
<p>【例】示例抽象类。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B0</span> //抽象类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//外部接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> :</span> <span class="keyword">public</span> B0 <span class="comment">//公有派生</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B1::display()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> B1 <span class="comment">//公有派生</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"D1::display()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(B0 *ptr)</span> <span class="comment">//普通函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ptr-&gt;display();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B0 *p; <span class="comment">//声明抽象基类指针</span></span><br><span class="line">    B1 b1; <span class="comment">//声明派生类对象</span></span><br><span class="line">    D1 d1; <span class="comment">//声明派生类对象</span></span><br><span class="line">    p = &amp;b1;</span><br><span class="line">    <span class="comment">//抽象类指针指向派生类对象</span></span><br><span class="line">    f1(p);</span><br><span class="line">    <span class="comment">//调用派生类B1的成员函数display()</span></span><br><span class="line">    p = &amp;d1;</span><br><span class="line">    <span class="comment">//抽象类指针指向派生类对象</span></span><br><span class="line">    f1(p);</span><br><span class="line">    <span class="comment">//调用派生类D1的成员函数display()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B1::display()</span><br><span class="line">D1::display()</span><br></pre></td></tr></table></figure>
<h2 id="测试-5">测试</h2>
<p>1.指出下面程序中的错误。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B class"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"D1 class"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"D2 class"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B obj1, *p;</span><br><span class="line">    D1 obj2;</span><br><span class="line">    D2 obj3;</span><br><span class="line">    obj1 = obj2;     <span class="comment">//（A）</span></span><br><span class="line">    obj2.B::print(); <span class="comment">//（B）</span></span><br><span class="line">    p = &amp;obj2;       <span class="comment">//（C）</span></span><br><span class="line">    p-&gt;print();</span><br><span class="line">    p = &amp;obj3; <span class="comment">//（D）</span></span><br><span class="line">    p-&gt;print();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(D)'B' is an inaccessible base of 'D2'</p>
<p>2.写出下面程序的运行结果。如果将Point类的area()函数定义为虚函数，其运行结果是什么？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1)</span><br><span class="line">    &#123;</span><br><span class="line">        x = x1;</span><br><span class="line">        y = y1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span> :</span> <span class="keyword">public</span> Point</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Rect(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> u1, <span class="keyword">int</span> w1) : Point(x1, y1)</span><br><span class="line">    &#123;</span><br><span class="line">        u = u1;</span><br><span class="line">        w = w1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> u * w; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> u, w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Point &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Rect <span class="title">rec</span><span class="params">(<span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    fun(rec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为0</p>
<p>若定义为虚函数，输出为60</p>
<h1 id="输入输出流">输入输出流</h1>
<h2 id="流">流</h2>
<h3 id="分析问题">分析问题</h3>
<p>C++没有定义任何用于执行输入或输出的语句，但可以使用C语言中的标准I/O函数printf()和scanf()来解决此问题。</p>
<p>printf()与scanf()存在两个缺点： * 非类型安全 * 不可扩充性</p>
<p>C++使用类型安全的I/O流操作。不同类型的I/O流操作都是重载的，没有定义过I/O功能的类型不具备I/O操作的能力。</p>
<p>通过修改和扩充，C++既可作为标准数据类型数据的I/O，也能用于自定义类型的对象的I/O，这种扩展性是C++最有价值的特点之一。</p>
<p>C++用输入输出流来解决这个问题。</p>
<h3 id="流-1">流</h3>
<p>所谓流（stream）是指数据从一个位置流向另一个位置。流是字节的序列。</p>
<p>输入／输出是一种数据传递操作，可以看作字符序列在计算机内存与外设之间的流动，C++将数据从一个对象到另一个对象的流动抽象为“流”。流动的方向不同，构成输入/输出流，即I/O流。</p>
<h3 id="io流">I/O流</h3>
<p>在C++程序中，数据可以从键盘流入到程序，也可以从程序流向屏幕或磁盘文件。从流中获取数据的操作称为<strong>提取操作</strong>，向流中添加数据的操作称为<strong>插入操作</strong>。</p>
<p>数据的输入/输出就是通过I/O流来实现的。</p>
<p>编译系统已经以<strong>运算符或函数</strong>的形式做好了对标准外设（<strong>键盘、屏幕、文件</strong>）的接口，使用时只需按照要求的格式调用即可。</p>
<h3 id="io流类库的层次结构">I/O流类库的层次结构</h3>
<p><img src="image-20201201143609221.png" alt="image-20201201143609221" style="zoom:50%;" /></p>
<h3 id="io流类库的头文件">I/O流类库的头文件</h3>
<p><strong>iostream</strong>:I/O流类库的最主要的头文件，包含了对输入输出流进行操作所需的基本信息，还包括cin、cout、cerr和clog共4个流对象。</p>
<p><strong>fstream</strong>:用于用户管理的文件的I/O操作。</p>
<p><strong>strstream</strong>:用于字符串流I/O。</p>
<p><strong>stdiostream</strong>:用于混合使用C和C++的I/O操作。</p>
<p><strong>iomanip</strong>:使用格式化I/O时应包含此头文件。</p>
<h2 id="无格式输入输出">无格式输入/输出</h2>
<p>无格式输入/输出就是按系统预定义的格式进行的输入/输出。</p>
<p>按默认约定，每个C++程序都能使用标准I/O流，如标准输入、标准输出。</p>
<ul>
<li><p><strong>cin</strong>用来处理标准输入，即键盘输入；cout用来处理标准输出，即屏幕输出。它们被定义在<strong>iostream</strong>头文件中。</p></li>
<li><p>在使用cout和cin前，要用编译预处理命令将所使用的头文件包含到源程序中，其格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="无格式输出">无格式输出</h3>
<p>“&lt;&lt;”是预定义的插入运算符，作用在流类对象cout上，实现默认格式的屏幕输出。使用cout输出表达式值到屏幕上的格式如下： <strong>cout&lt;&lt;E1&lt;&lt;E2&lt;&lt;…&lt;&lt;Em;</strong><br />
其中，E1、E2、…、Em为均为表达式。</p>
<p>用“cout&lt;&lt;”输出基本类型的数据时，可以不必考虑数据是什么类型，系统会判断数据的类型，并调用与之匹配的运算符重载函数。</p>
<p>cout是ostream流类的对象，它在iostream头文件中作为全局对象定义，其格式如下： ostream cout(stdout); 其中，stdout表示标准输出设备名（屏幕）。</p>
<h3 id="无格式输入">无格式输入</h3>
<p>“&gt;&gt;”是预定义的提取运算符，作用在流类对象cin上，实现默认格式的键盘输入。使用cin将数据输入到变量的格式如下： <strong>cin&gt;&gt;V1&gt;&gt;V2&gt;&gt;…&gt;&gt;Vn;</strong><br />
其中，V1、V2、…、Vn都是变量。功能是暂停执行程序，等待用户从键盘输入数据，各数据间用空格或Tab键分隔，输入数据类型要与接受变量类型一致，输完后，按回车键结束。</p>
<p>cin是istream流类的对象，它在iostream头文件中作为全局对象定义，其格式如下： istream cin(stdin); 其中，stdin表示标准输入设备名（键盘）。</p>
<h3 id="输入输出的格式控制">输入输出的格式控制</h3>
<p>C++提供了两种格式化输入/输出方式： * 一种是用流对象的有关成员函数进行格式化输入输出。 * 另一种是用专门的控制符进行格式化输入输出。</p>
<h3 id="用流对象的成员函数格式化">用流对象的成员函数格式化</h3>
<p>流成员函数主要是通过对状态标志、输出宽度、填充字符以及输出精度的操作来完成输入/输出格式化。</p>
<p>输入/输出的格式由各种状态标志来确定，在ios类中定义为枚举量。</p>
<p>枚举量定义在ios类中，因此引用时必须包含<strong>ios</strong>::前缀。使用时应该全部用符号名，绝不要用数值。</p>
<h3 id="用流对象的成员函数对状态标志进行操作">用流对象的成员函数对状态标志进行操作</h3>
<p>ios类有3个成员函数可以对状态标志进行操作，并且定义了一个long型数据成员记录当前状态标志。这些状态标志可用位或运算符“|”进行组合。</p>
<p>这三个函数必须用流类对象（cin或cout）来调用。</p>
<p>用setf函数设置状态标志， 其一般格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ios::setf</span><span class="params">(<span class="keyword">long</span> flags)</span></span></span><br></pre></td></tr></table></figure>
<p>用unsetf函数清除状态标志，其一般格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ios::unsetf</span><span class="params">(<span class="keyword">long</span> flags)</span></span></span><br></pre></td></tr></table></figure>
<p>用函数flags取状态标志有两种形式，其格式分别如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ios::flags</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>返回与流相关的当前状态标志值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ios::flags</span><span class="params">(<span class="keyword">long</span> flag)</span></span></span><br></pre></td></tr></table></figure>
<p>将流的状态标志值设置为flag，并返回设置前的状态标志值。</p>
<p>以上三组函数必须用流类对象（cin或cout）来调用，其格式如下： <流对象名>.<函数名>(ios::<状态标志>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>.setf(ios::showpos);</span><br><span class="line"><span class="built_in">cout</span>.setf(ios::scientific);</span><br><span class="line"><span class="built_in">cout</span>.setf(ios::showpos| ios::scientific);</span><br></pre></td></tr></table></figure>
<p>【例】　示例对状态标志的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showflags</span><span class="params">(<span class="keyword">long</span> f)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="keyword">long</span> f;</span><br><span class="line">    f=<span class="built_in">cout</span>.flags();                <span class="comment">//取当前状态标志</span></span><br><span class="line">    showflags(f);                  <span class="comment">//显示状态值</span></span><br><span class="line">    <span class="built_in">cout</span>.setf(ios::showpos|ios::scientific|ios::fixed); <span class="comment">//追加状态标志</span></span><br><span class="line">    f=<span class="built_in">cout</span>.flags();                <span class="comment">//取当前状态标志</span></span><br><span class="line">    showflags(f);                  <span class="comment">//显示状态值</span></span><br><span class="line">    <span class="built_in">cout</span>.unsetf(ios::scientific);  <span class="comment">//从状态标志中去掉 scientific</span></span><br><span class="line">    f=<span class="built_in">cout</span>.flags();                <span class="comment">//取当前状态标志</span></span><br><span class="line">    showflags(f);                  <span class="comment">//显示状态值</span></span><br><span class="line">    f=<span class="built_in">cout</span>.flags(ios::hex);        <span class="comment">//重新设置状态标志</span></span><br><span class="line">    showflags(f);</span><br><span class="line">    f=<span class="built_in">cout</span>.flags();                <span class="comment">//取当前状态标志</span></span><br><span class="line">    showflags(f);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showflags</span><span class="params">(<span class="keyword">long</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="keyword">long</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0x8000</span>;i;i=i&gt;&gt;<span class="number">1</span>) <span class="comment">//用右移方式使i中的值为"1"的位不断右移</span></span><br><span class="line">    <span class="keyword">if</span>(i&amp;f)<span class="built_in">cout</span>&lt;&lt;<span class="string">"1"</span>; <span class="comment">//判断f中的某一位是否为"1" </span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000001000000001</span><br><span class="line">0011001000100001</span><br><span class="line">0010001000100001</span><br><span class="line">0010001000100001</span><br><span class="line">0000100000000000</span><br></pre></td></tr></table></figure>
<h3 id="用流对象的成员函数设置输出宽度">用流对象的成员函数设置输出宽度</h3>
<p>设置输出宽度函数有两种形式，其格式分别如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ios::width</span><span class="params">(<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ios::width</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>第一种形式是设置输出宽度，并返回原来的输出宽度；第二种形式是返回当前输出宽度，默认输出宽度为0。</p>
<p>只对其后的第一个输出项有效。</p>
<h3 id="设置填充字符">设置填充字符</h3>
<p>填充字符的作用是当输出值不满输出宽度时用填充字符来填充，默认填充字符为空格。它与width()函数配合使用，否则没有意义。</p>
<p>设置填充字符函数有两种形式，其格式分别如下： char ios::fill(char ch) char ios::fill()</p>
<p>第一种形式是重新设置填充字符，并返回设置前的填充字符；第二种形式是返回当前的填充字符。</p>
<h3 id="设置输出精度">设置输出精度</h3>
<p>设置浮点数输出精度有两种形式，其格式分别如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ios::precision</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ios::precision</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>第一种形式是重新设置输出精度，并返回设置前的输出精度；第二种形式是返回当前的输出精度。默认输出精度为6 。</p>
<h3 id="用流成员函数put输出字符">用流成员函数put输出字符</h3>
<p>ostream类除了提供用于格式控制的成员函数外，还提供了专用于输出单个字符的成员函数put。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span>.put(‘a’);  </span><br><span class="line"><span class="built_in">cout</span>.put(<span class="number">97</span>);</span><br><span class="line"><span class="built_in">cout</span>.put(<span class="number">71</span>).put(<span class="number">79</span>);</span><br></pre></td></tr></table></figure>
<p>【例】 示例设置输出宽度、填充字符、输出精度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">i=<span class="built_in">cout</span>.width();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"width:"</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>.width(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">cout</span>.width()&lt;&lt;<span class="string">"(new width)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line">c=<span class="built_in">cout</span>.fill();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"filling word is:"</span>&lt;&lt;c&lt;&lt;<span class="string">"(ASCII code"</span>&lt;&lt;(<span class="keyword">int</span>)c&lt;&lt;<span class="string">")"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>.fill(<span class="string">'*'</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">cout</span>.fill()&lt;&lt;<span class="string">"("</span>&lt;&lt;(<span class="keyword">int</span>)<span class="built_in">cout</span>.fill()&lt;&lt;<span class="string">")(new filling word)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line">j=<span class="built_in">cout</span>.precision();</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"precision:"</span>&lt;&lt;j&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>.precision(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">123.456789</span>&lt;&lt;<span class="string">"(example)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">cout</span>.precision()&lt;&lt;<span class="string">"(new precision)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">width:0</span><br><span class="line">8(new width)</span><br><span class="line">filling word is: (ASCII code32)</span><br><span class="line">*(42)(new filling word)</span><br><span class="line">precision:6</span><br><span class="line">123.45679(example)</span><br><span class="line">8(new precision)</span><br></pre></td></tr></table></figure>
<h3 id="用于字符输入的流成员函数">用于字符输入的流成员函数</h3>
<h4 id="用get函数读入一个字符">用get函数读入一个字符</h4>
<p>(1)不带参数的get函数</p>
<ul>
<li>cin.get()用来从指定的输入流中提取一个字符（包括空白字符），函数的返回值就是读入的字符。</li>
</ul>
<p>若遇到输入流中的文件结束符，则函数返回文件结束标志EOF。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">int</span> c;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;“enter a sentence:”&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">while</span>((c=<span class="built_in">cin</span>.get())!=EOF)</span><br><span class="line">        <span class="built_in">cout</span>.put(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)有一个参数的get函数</p>
<ul>
<li>cin.get(ch)用来从输入流中读取一个字符，赋给字符变量ch。</li>
</ul>
<p>读取成功返回非0值（真），如失败（遇文件结束符）则函数返回0值（假）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">char</span> c;</span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;“enter a sentence:”&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">while</span>(<span class="built_in">cin</span>.get(c))<span class="comment">//读取一个字符赋给c，如果读取成功，返回真</span></span><br><span class="line">        <span class="built_in">cout</span>.put(c);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;“end”&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)有三个参数的get函数</p>
<ul>
<li>cin.get(字符数组/字符指针，字符个数n，终止字符)</li>
<li>从输入流中读取n-1个字符，赋给指定的字符数组（或字符指针指向的数组）。</li>
<li>如果在读取n-1个字符之前遇到指定的终止字符，则提前读取结束。</li>
<li>如果读取成功返回非0值（真），如失败（遇文件结束符）则函数返回0值（假）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch[<span class="number">20</span>];</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"enter a sentence:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span>.get(ch,<span class="number">10</span>,<span class="string">'/'</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ch&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span>.get(ch,<span class="number">20</span>,‘\n’);  <span class="comment">//指定换行符为终止字符</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ch&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enter a sentence:</span><br><span class="line">you!&#x2F;her.</span><br><span class="line">you!</span><br><span class="line">&#x2F;her.</span><br></pre></td></tr></table></figure>
<p>cin.get(ch,20,‘’); &lt;==&gt; cin.get(ch,20);</p>
<h4 id="用getline函数读入一行字符">用getline函数读入一行字符</h4>
<p>cin.getline(字符数组（或字符指针），字符个数n，终止字符)</p>
<p>从输入流中读取一行字符，其用法与带3个参数的get函数类似。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch[<span class="number">20</span>];</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"enter a sentence:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ch&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span>.getline(ch,<span class="number">20</span>,<span class="string">'/'</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ch&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span>.getline(ch,<span class="number">20</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ch&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">enter a sentence:</span><br><span class="line">I like C++./I study C++./I am happy.</span><br><span class="line">I</span><br><span class="line"> like C++.</span><br><span class="line">I study C++./I am h</span><br></pre></td></tr></table></figure>
<h3 id="istream类的其他成员函数">istream类的其他成员函数</h3>
<h4 id="eof函数">eof函数</h4>
<p>无参函数，表示文件结束。</p>
<p>从输入流读取数据，如果到达文件末尾（遇文件结束符），返回非零值（真），否则为0（假）。 while(!cin.eof())</p>
<h4 id="peek函数">peek函数</h4>
<p>无参函数，表示“观察”，观测下一个字符。</p>
<p>返回值是当前指针指向的当前字符，但只是观测，指针仍停留在当前位置，并不后移。</p>
<p>如果要访问的字符是文件结束符，则函数值是EOF。 c=cin.peek()；</p>
<h4 id="putback函数">putback函数</h4>
<p>将前面用get或getline函数从输入流中读取的字符ch返回到输入流，插入到当前指针位置，以供后面读取。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> c[<span class="number">20</span>];</span><br><span class="line">             <span class="keyword">int</span> ch;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"enter a sentence:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span>.getline(c,<span class="number">15</span>,<span class="string">'/'</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">             ch=<span class="built_in">cin</span>.peek();  <span class="comment">//观看当前字符</span></span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt;ch&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span>.putback(c[<span class="number">0</span>]);  <span class="comment">//将‘I’插入到指针所指处</span></span><br><span class="line">             <span class="built_in">cin</span>.getline(c,<span class="number">15</span>,<span class="string">'/'</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enter a sentence:</span><br><span class="line">I am a boy.&#x2F; am a student.&#x2F;</span><br><span class="line">I am a boy.</span><br><span class="line">32</span><br><span class="line">I am a student</span><br></pre></td></tr></table></figure>
<h4 id="ignore函数">ignore函数</h4>
<p>cin.ignore(n,终止字符)</p>
<p>跳过输入流中n个字符，或在遇到指定的终止字符时提前结束（此时跳过包括终止字符在内的若干字符）。</p>
<p>ignore（5，’A’）;//跳过5个字符，遇’A’后不再跳</p>
<p>ignore(); &lt;==&gt; ignore(1,EOF);</p>
<p>不用ignore函数的情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch[<span class="number">20</span>];</span><br><span class="line">	<span class="built_in">cin</span>.get(ch,<span class="number">20</span>,<span class="string">'/'</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;“The first part is:”&lt;&lt;ch&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cin</span>.get(ch,<span class="number">20</span>,<span class="string">'/'</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;“The second part is:”&lt;&lt;ch&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">I like C++./I study C++./I am happy.</span><br><span class="line">The first part is:I like C++.</span><br><span class="line">The second part is:</span><br></pre></td></tr></table></figure>
<p>使用ignore函数的情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch[<span class="number">20</span>];</span><br><span class="line">	<span class="built_in">cin</span>.get(ch,<span class="number">20</span>,<span class="string">'/'</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;“The first part is:”&lt;&lt;ch&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>.ignore();  <span class="comment">//跳过输入流中一个字符</span></span><br><span class="line">	<span class="built_in">cin</span>.get(ch,<span class="number">20</span>,<span class="string">'/'</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;“The second part is:”&lt;&lt;ch&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">I like C++./I study C++./I am happy.</span><br><span class="line">The first part is:I like C++.</span><br><span class="line">The second part is:I study C++.</span><br></pre></td></tr></table></figure>
<h3 id="用控制符格式化">用控制符格式化</h3>
<p>为了不直接以标志位的方式去处理流的状态， c++标准库提供了标准的控制符专门操控这些状态。</p>
<p>这组控制符不属于任何类成员，定义在iomanip头文件中。</p>
<p>将它们用在提取运算符“&gt;&gt;”或插入运算符“&lt;&lt;”后面来设定输入/输出格式，即在读写对象之间插入一个修改状态的操作。</p>
<p>设置输入/输出宽度setw(int) * 用整型参数来制定输入/输出域的宽度。使用时只对其后一项输入/输出有效。 * 当用于输出时，若实际宽度小于设置宽度时，数据向右对齐，反之则按数据的实际宽度输出。 * 当用于输入时，若输入的数据宽度超过设置宽度时，超出的数据部分被截断而被作为下一项输入内容。</p>
<p>【例】　用控制符示例设置输入/输出宽度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p=<span class="string">"12345"</span>,*q=<span class="string">"678"</span>;</span><br><span class="line">    <span class="keyword">char</span> f[<span class="number">4</span>],g[<span class="number">4</span>];                           </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p&lt;&lt;setw(<span class="number">6</span>)&lt;&lt;q&lt;&lt;setw(<span class="number">4</span>)&lt;&lt;p&lt;&lt;q&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//设置输出宽度</span></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;setw(<span class="number">4</span>)&gt;&gt;f&gt;&gt;g;                       <span class="comment">//设置输入宽度</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f&lt;&lt;<span class="built_in">endl</span>&lt;&lt;g&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">"i:"</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12345   67812345678</span><br><span class="line">12345</span><br><span class="line">123		&#x2F;&#x2F;设置宽度为N，那么会截取N-1位</span><br><span class="line">45</span><br><span class="line">i:10</span><br></pre></td></tr></table></figure>
<p>设置输出填充字符setfill(char) * 与ios::fill相同，常与setw(int)联合使用，从而向不满设置输出宽度的空间填入指定的字符，不设置则填空格。 * 设置后直至下一次设置前一直有效。 * 参数可以是字符常量或字符变量。</p>
<p>设置输出精度setprecision(int) * 指明输出实数的有效位数。 * 参数为0时，按默认有效位数6输出。 * 在以fixed形式和scientific形式输出时参数为小数位数。</p>
<p>setiosflags(ios::fixed)用定点方式表示实数。</p>
<p>setiosflags(ios::scientific)用科学记数法方式表示实数。 * 如果setprecision(n)与setiosflags(ios::fixed)合用，可以控制小数点右边的数字个数。 * 如果setprecision(n)与setiosflags(ios::scientific)合用，可以控制科学记数法中尾数的小数位数。</p>
<p>setiosflags(ios::left)输出数据左对齐</p>
<p>setiosflags(ios::right)输出数据右对齐</p>
<p>setiosflags(ios::uppercase)大写表示</p>
<p>setiosflags(ios::showpos)输出正数时给出“+”号</p>
<p>setiosflags(ios::skipws)忽略前导空格</p>
<p>resetiosflags()终止已设置的输出格式状态，在括号中应指定内容</p>
<p>【例】　设置对齐方式和输出宽度示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> values[]=&#123;<span class="number">1.23</span>,<span class="number">35.36</span>,<span class="number">653.7</span>,<span class="number">4358.24</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> *names[]=&#123;<span class="string">"Zoot"</span>,<span class="string">"Jimmy"</span>,<span class="string">"Al"</span>,<span class="string">"Stan"</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;setiosflags(ios::left)    <span class="comment">//设置左对齐</span></span><br><span class="line">        &lt;&lt;setw(<span class="number">6</span>)&lt;&lt;names[i]</span><br><span class="line">        &lt;&lt;resetiosflags(ios::left)  <span class="comment">//取消左对齐</span></span><br><span class="line">        &lt;&lt;setw(<span class="number">10</span>)&lt;&lt;values[i]</span><br><span class="line">        &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Zoot          1.23</span><br><span class="line">Jimmy      35.36</span><br><span class="line">Al            653.7</span><br><span class="line">Stan     4358.24</span><br></pre></td></tr></table></figure>
<p>【例】　分别用浮点、定点的方式表示一个实数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> f=<span class="number">22.0</span>/<span class="number">7</span>;</span><br><span class="line">    <span class="comment">//在用浮点形式表示的输出中，setprecision(n)表示实数的有效位数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;f&lt;&lt;<span class="built_in">endl</span>;                    <span class="comment">//默认有效位数为6</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;setprecision(<span class="number">3</span>)&lt;&lt;f&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//设置有效位数为3</span></span><br><span class="line"><span class="comment">//在用定点形式表示的输出中，setprecision(n)表示实数的小数位数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;setiosflags(ios::fixed); </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;setprecision(<span class="number">8</span>)&lt;&lt;f&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//小数位数为8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.14286   </span><br><span class="line">3.14      </span><br><span class="line">3.14285714</span><br></pre></td></tr></table></figure>
<p>设置输入/输出整型数数制dec、hex和oct。</p>
<p>控制换行的控制符endl</p>
<p>代表输出单字符‘\0’的控制符ends</p>
<h3 id="用户自定义控制符函数">用户自定义控制符函数</h3>
<p>建立输出控制符函数的格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">manip_name</span><span class="params">(ostream&amp; stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &lt;自定义语句序列&gt;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【例】 示例用户自定义输出控制符函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">setup</span><span class="params">(ostream&amp; stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stream.setf(ios::left);</span><br><span class="line">    stream&lt;&lt;setw(<span class="number">10</span>)&lt;&lt;setfill(<span class="string">'$'</span>);</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="number">10</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;setup&lt;&lt;<span class="number">10</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 10$$$$$$$$</span><br></pre></td></tr></table></figure>
<p>建立输入控制符函数的格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">manip_name</span><span class="params">(istream&amp; stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &lt;自定义语句序列&gt;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">istream&amp; <span class="title">prompt</span><span class="params">(istream&amp; stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;hex;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Enter number using hex format："</span>;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;prompt&gt;&gt;i;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enter number using hex format:ff</span><br><span class="line">255</span><br></pre></td></tr></table></figure>
<h2 id="文件的输入输出">文件的输入/输出</h2>
<p>C++把文件看作是一个字符（字节）的序列，即由一个个字符（字节）顺序组成。</p>
<p>根据数据的组织形式，可分为ASCII码文件和二进制文件。</p>
<ul>
<li>ASCII码文件又称为文本文件，它的每一个字节存放一个ASCII码，代表一个字符。</li>
<li>二进制文件是把内存中的数据按其在内存中的存储形式原样输出到磁盘文件存放。</li>
</ul>
<p>由于ASCII码形式与字符一一对应，因此便于对字符进行输出或逐个处理，但它要占用较多的存储空间，若存于二进制文件中，可以节省存储空间，但不能直接输出字符形式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">56：ASCII表示为 00110101 00110110，占两字节</span><br><span class="line">56：二进制表示为 111000，占六个二进制位</span><br></pre></td></tr></table></figure>
<p>###　文件流</p>
<p>C++在头文件fstream中定义了C++的文件流类体系 ,当程序中使用文件时，要包含头文件fstream,其中定义了各种文件操作运算符及函数。</p>
<p><img src="image-20201208141413317.png" alt="image-20201208141413317" style="zoom:50%;" /></p>
<p>程序对<strong>文本文件</strong>的操作与对键盘、显示器的操作比较：</p>
<p><img src="image-20201208141437933.png" alt="image-20201208141437933" style="zoom:50%;" /></p>
<p>在涉及<strong>文本文件</strong>的操作时，将输入文件看成键盘，将输出文件看成显示器，格式不变。<strong>只需在程序中增加打开与关闭文件的语句。</strong></p>
<p>###　C++中进行文件操作的一般步骤</p>
<p>为文件定义一个流类对象；</p>
<p>使用open()函数建立（或打开）文件。如果文件不存在，则建立该文件；如果磁盘上已存在该文件，则打开该文件；</p>
<p>进行读写操作。在建立（或打开）的文件上执行所要求的输入/输出操作。一般来说，在内存与文件的数据传输中，由内存到文件称为输出或写，反之则称为输入或读；</p>
<p>使用close()函数关闭文件。当完成操作后，应把打开的文件关闭，避免误操作。</p>
<p>在C++中，打开一个文件就是将这个文件与一个流建立关联；关闭一个文件就是取消这种关联。</p>
<p>open()函数的原型在fstream中定义。其原型为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void open(char *filename,int mod,int access);</span><br></pre></td></tr></table></figure>
<p>其中第一个参数是用来传递文件名；第二个参数的值决定文件的使用方式；第三个参数的值决定文件的访问方式。</p>
<p>对于ifstream流类，mod的值为ios::in;对于ofstream流类，mod的值为ios::out;。</p>
<h3 id="文件的打开与关闭">文件的打开与关闭</h3>
<p>打开文件</p>
<ul>
<li><p>先建立流对象，然后调用函数open连接外部文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">流类  对象名;</span><br><span class="line">对象名.open(文件名,方式);</span><br></pre></td></tr></table></figure></li>
<li><p>调用流类带参数的构造函数，建立流对象的同时连接外部文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">流类 对象名(文件名,方式);</span><br></pre></td></tr></table></figure>
<p>其中，“流类” 为ifstream、ofstream或fstream。</p></li>
</ul>
<p>关闭文件</p>
<ul>
<li><p>使用close()成员函数进行关闭：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">流对象名. close()</span><br></pre></td></tr></table></figure>
<p>其中，流对象名是待关闭的文件流的对象名。</p></li>
</ul>
<p>【例】 示例文件的输入/输出操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ofstream ostrm;         　　　 <span class="comment">//定义流类对象</span></span><br><span class="line">	ostrm.open(<span class="string">"f1.dat"</span>);          <span class="comment">//打开文件</span></span><br><span class="line">	ostrm&lt;&lt;<span class="number">120</span>&lt;&lt;<span class="built_in">endl</span>;              <span class="comment">//写操作</span></span><br><span class="line">	ostrm&lt;&lt;<span class="number">310.85</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	ostrm.close();                 <span class="comment">//关闭文件</span></span><br><span class="line">	<span class="function">ifstream <span class="title">istrm</span><span class="params">(<span class="string">"f1.dat"</span>)</span></span>;      <span class="comment">//定义流类对象</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">double</span> d;</span><br><span class="line">	istrm&gt;&gt;n&gt;&gt;d;                   <span class="comment">//读操作</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">","</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	istrm.close();                 <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">120,310.85</span><br></pre></td></tr></table></figure>
<h3 id="文件的读写">文件的读写</h3>
<h4 id="文本文件的读写文本文件用默认方式打开">文本文件的读写：文本文件用默认方式打开。</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s1[<span class="number">80</span>], s2[<span class="number">8</span>];</span><br><span class="line">    fstream outfile;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s1;</span><br><span class="line">    outfile.open(<span class="string">"exam.txt"</span>, ios::out);</span><br><span class="line">    <span class="keyword">if</span> (!outfile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"exam.txt can’t open"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    outfile &lt;&lt; s1;</span><br><span class="line">    outfile.close();</span><br><span class="line">    outfile.open(<span class="string">"exam.txt"</span>, ios::in);</span><br><span class="line">    outfile &gt;&gt; s2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    outfile.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二进制文件的读写">二进制文件的读写</h4>
<ul>
<li>若在文件的打开方式中没有特别说明，打开的文件均为ASCII码文件，若要打开二进制文件，则要特别说明并用特定的读写函数。</li>
<li>二进制文件用binary方式打开，读写方式完全由程序控制。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fstream infile, outfile;</span><br><span class="line">infile.open(“inf1.dat”, ios::in | ios::binary);</span><br><span class="line"><span class="comment">//           文件名     输入方式打开 二进制文件</span></span><br><span class="line">outfile.open(“outf1.dat”, ios::out | ios::binary);</span><br></pre></td></tr></table></figure>
<p>由于二进制文件中的数据不是ASCII码，故不能直接对其读写，必须要通过特定的函数予以转换。</p>
<p>输入函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">infile.read( <span class="keyword">char</span>  *,   <span class="keyword">int</span> )</span><br><span class="line"><span class="comment">//infile:输入文件对象名，char *:数据进入的内存地址，int:一次读入的字节数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  i;</span><br><span class="line">infile.read((<span class="keyword">char</span> *)&amp;i, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//从文件中输入一个整型数到i</span></span><br><span class="line"><span class="comment">//地址要强制转换成字符型</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int  a[10];</span><br><span class="line">infile.read((char *)a,  10*sizeof(int));&#x2F;&#x2F;从文件中输入十个整型数到a</span><br></pre></td></tr></table></figure>
<p>输出函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">outfile.write( <span class="keyword">char</span>  *,   <span class="keyword">int</span> )</span><br><span class="line"><span class="comment">//outfile:输出文件对象名，char *: 要输出的数据在内存中的地址，int: 一次输出的字节数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  i=<span class="number">4</span>;</span><br><span class="line">outfile.write((<span class="keyword">char</span> *)&amp;i, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//向文件输出一个整型数i</span></span><br><span class="line"><span class="comment">//地址要强制转换成字符型</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  a[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">outfile.write((<span class="keyword">char</span> *)a,  <span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//向文件输出一个整型数组a</span></span><br></pre></td></tr></table></figure>
<p>【例】 二进制文件的读写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">double</span> height;</span><br><span class="line">    <span class="keyword">unsigned</span> short age;</span><br><span class="line">&#125; people[<span class="number">3</span>] = &#123;<span class="string">"wang"</span>, <span class="number">1.65</span>, <span class="number">25</span>, <span class="string">"zhang"</span>, <span class="number">1.78</span>, <span class="number">24</span>, <span class="string">"li"</span>, <span class="number">1.85</span>, <span class="number">21</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fstream infile, outfile;</span><br><span class="line">    outfile.open(<span class="string">"exam.dat"</span>, ios::out | ios::binary);</span><br><span class="line">    <span class="keyword">if</span> (!outfile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"exam.dat can't open"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        outfile.write((<span class="keyword">char</span> *)&amp;people[i], <span class="keyword">sizeof</span>(people[i]));</span><br><span class="line"></span><br><span class="line">    outfile.close();</span><br><span class="line">    infile.open(<span class="string">"exam.dat"</span>, ios::in | ios::binary);</span><br><span class="line">    <span class="keyword">if</span> (!infile)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"exam.dat can't open"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        infile.read((<span class="keyword">char</span> *)&amp;people[j], <span class="keyword">sizeof</span>(people[j]));</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; people[j].name &lt;&lt; <span class="string">"\t"</span> &lt;&lt; people[j].height &lt;&lt; <span class="string">"\t"</span> &lt;&lt; people[j].age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    infile.close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>####　文件的随机读写</p>
<p>文件打开以后，系统自动生成两个隐含的流指针:读指针和写指针。在输入文件流类中，有关读指针的函数如下：</p>
<h5 id="移动读指针函数">移动读指针函数</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">istream::seekg</span><span class="params">(streampos pos)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数的功能是将输入文件的指针移动到pos指定的位置中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">istream::seekg</span><span class="params">(streamoff offset,seek_dir origin)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，origin的类型seek_dir是一个枚举类型，有以下三种取值：</p>
<p>ios::beg 表示指针的起始位置为文件头</p>
<p>ios::cur 表示指针的起始位置为当前位置</p>
<p>ios::end 表示指针的起始位置为文件尾</p>
<p>该函数的功能是从origin指定的开始位置起，将文件指针移动offset个字节数。</p>
<p>返回读指针当前指向的位置值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">streampos  <span class="title">istream::tellg</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数的功能是确定文件指针的当前位置。</p>
<p>相应地，ostream类提供有关写指针的函数如下：</p>
<h5 id="移动写指针函数">移动写指针函数</h5>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">ostream::seekp</span><span class="params">(streampos pos)</span></span>;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">ostream::seekp</span><span class="params">(streamoff offset,seek_dir origin)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回写指针当前指向的位置值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">streampos <span class="title">ostream::tellp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数参数的意义与读指针函数一样。</p>
<p>【例】 文件的随机读写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">fstream <span class="title">file</span><span class="params">(<span class="string">"exam.dat"</span>, ios::in | ios::out | ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!file)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"exam.dat can’t open"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++)</span><br><span class="line">        file.write((<span class="keyword">char</span> *)&amp;i, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    streampos pos = file.tellp();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"current byte number: "</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">15</span>; i &lt; <span class="number">45</span>; i++)</span><br><span class="line">        file.write((<span class="keyword">char</span> *)&amp;i, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    file.seekg(pos);</span><br><span class="line">    file.read((<span class="keyword">char</span> *)&amp;i, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The data stored is "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    file.seekp(<span class="number">0</span>, ios::beg);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">80</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        file.write((<span class="keyword">char</span> *)&amp;i, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    file.seekg(pos);</span><br><span class="line">    file.read((<span class="keyword">char</span> *)&amp;i, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The data stored is "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    file.seekp(<span class="number">20</span>, ios::cur);</span><br><span class="line">    file.read((<span class="keyword">char</span> *)&amp;i, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The data stored is"</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"current byte number: "</span> &lt;&lt; file.tellp() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">current byte number:60</span><br><span class="line">The data stored is 15</span><br><span class="line">The data stored is 95</span><br><span class="line">The data stored is 21</span><br><span class="line">current byte number:88</span><br></pre></td></tr></table></figure>
<h2 id="字符串流内存流">字符串流（内存流）</h2>
<p>以内存中用户定义的字符数组（字符串）作为输入输出的对象，也就是将数据输出到内存中的字符数组，或者从字符数组将数据读入。</p>
<p>字符串流具有相应的缓冲区。</p>
<p>在字符数组中可以存放字符，也可以存放整数、浮点数以及其他类型的数据。</p>
<p><img src="image-20201208145138149.png" alt="image-20201208145138149" style="zoom:50%;" /></p>
<h3 id="建立输出字符串流对象">建立输出字符串流对象</h3>
<p>ostrstream类提供的构造函数原型为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ostrstream::ostrstream(<span class="keyword">char</span> *buffer, <span class="keyword">int</span> n, <span class="keyword">int</span> mod=ios::out);</span><br></pre></td></tr></table></figure>
<p>buffer是指向字符数组首元素的地址，n为指定的流缓冲区的大小，第3个参数是可选的，默认为 ios::out方式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ostrstream <span class="title">strout</span><span class="params">(ch1,<span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="建立输入字符串流对象">建立输入字符串流对象</h3>
<p>istrstream类提供了两个带参的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">istrstream::istrstream(<span class="keyword">char</span> *buffer);</span><br><span class="line">istrstream::istrstream(<span class="keyword">char</span> *buffer, <span class="keyword">int</span> n);</span><br></pre></td></tr></table></figure>
<p>buffer是指向字符数组首元素的地址，用它来初始化流对象（使流对象与字符数组建立关联）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">istrstream <span class="title">strin</span><span class="params">(ch2)</span></span>;</span><br><span class="line"><span class="function">istrstream <span class="title">strin</span><span class="params">(ch2, <span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="建立输入输出字符串流对象">建立输入输出字符串流对象</h3>
<p>strstream类提供的构造函数原型为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">strstream::strstream(<span class="keyword">char</span> *buffer,<span class="keyword">int</span> n,<span class="keyword">int</span> mod);</span><br><span class="line"><span class="function">strstream <span class="title">strio</span><span class="params">(ch3, <span class="keyword">sizeof</span>(ch3),ios::in|ios::out)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    student stud[<span class="number">3</span>] = &#123;<span class="number">1001</span>, <span class="string">"Li"</span>, <span class="number">78</span>, <span class="number">1002</span>, <span class="string">"Wang"</span>, <span class="number">89.5</span>, <span class="number">1004</span>, <span class="string">"Fan"</span>, <span class="number">90</span>&#125;;</span><br><span class="line">    <span class="comment">// 数据会被转换成ASCII码后再放入字符数组，一共29个字符</span></span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">50</span>];                 <span class="comment">//用户定义的字符数组</span></span><br><span class="line">    <span class="function">ostrstream <span class="title">strout</span><span class="params">(c, <span class="number">30</span>)</span></span>;   <span class="comment">//建立输出字符串流，与数组c建立关联，缓冲区长30</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="comment">//向字符数组c写3个学生的数据</span></span><br><span class="line">        strout &lt;&lt; stud[i].num &lt;&lt; stud[i].name &lt;&lt; stud[i].score;</span><br><span class="line">    strout &lt;&lt; ends;                   <span class="comment">//ends是C++的I/O操作符，插入一个’\0’</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"array c :"</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//显示字符数组c中的字符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array c:1001Li781002Wang89.51004Fan90</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">50</span>] =“<span class="number">12</span> <span class="number">34</span> <span class="number">65</span> - <span class="number">23</span> - <span class="number">32</span> <span class="number">33</span> <span class="number">61</span> <span class="number">99</span> <span class="number">321</span> <span class="number">32</span>”;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>], i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;“<span class="built_in">array</span> c :” &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//显示字符数组中的字符串</span></span><br><span class="line">    <span class="function">istrstream <span class="title">strin</span><span class="params">(c, <span class="keyword">sizeof</span>(c))</span></span>;  <span class="comment">//建立输入串流对象strin并与字符数组c关联</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        strin &gt;&gt; a[i]; <span class="comment">//从字符数组c读入10个整数赋给整型数组a</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;“<span class="built_in">array</span> a :”;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt;“ ”;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="function">ostrstream <span class="title">strout</span><span class="params">(c, <span class="keyword">sizeof</span>(c))</span></span>; <span class="comment">//建立输出串流对象strout并与字符数组c关联</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        strout &lt;&lt; a[i] &lt;&lt;“ ”;       <span class="comment">//将10个整数存放在字符数组c</span></span><br><span class="line">    strout &lt;&lt; ends;                 <span class="comment">//加入’\0’</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;“<span class="built_in">array</span> c :“&lt;&lt; c &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//显示字符数组c</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">array</span> c: <span class="number">12</span> <span class="number">34</span> <span class="number">65</span> <span class="number">-23</span> <span class="number">-32</span> <span class="number">33</span> <span class="number">61</span> <span class="number">99</span> <span class="number">321</span> <span class="number">32</span></span><br><span class="line"><span class="built_in">array</span> a: <span class="number">12</span> <span class="number">34</span> <span class="number">65</span> <span class="number">-23</span> <span class="number">-32</span> <span class="number">33</span> <span class="number">61</span> <span class="number">99</span> <span class="number">321</span> <span class="number">32</span></span><br><span class="line"><span class="built_in">array</span> c: <span class="number">12</span> <span class="number">34</span> <span class="number">65</span> <span class="number">-23</span> <span class="number">-32</span> <span class="number">33</span> <span class="number">61</span> <span class="number">99</span> <span class="number">321</span> <span class="number">32</span></span><br></pre></td></tr></table></figure>
<h3 id="注意">注意</h3>
<p>字符串流对象关联的是内存中的一个字符数组，因此不需要打开和关闭文件。</p>
<p>通过字符串流从字符数组读数据就如同从键盘读数据一样，可以从字符数组读入字符数据，也可以读入整数、浮点数或其他类型数据。如果不用字符串流，只能从字符数组逐个访问字符，而不能按其他类型的数据形式读取数据。</p>
<p>字符串流关联的字符数组并不一定是专为字符串流而定义的数组，它与一般的字符数组无异，可以对该数组进行其他操作。</p>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
</search>
