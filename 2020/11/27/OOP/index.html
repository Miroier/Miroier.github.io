<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#6667ab"><meta name="generator" content="Hexo 6.3.0">

<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#6667ab">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CSource+Code+Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" integrity="sha256-AbA177XfpSnFEvgpYu1jMygiLabzPCJCRIBtR5jGc0k=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.13.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":true,"color":"#222222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="C++OOP">
<meta property="og:type" content="article">
<meta property="og:title" content="OOP">
<meta property="og:url" content="http://yoursite.com/2020/11/27/OOP/index.html">
<meta property="og:site_name" content="Seclusion">
<meta property="og:description" content="C++OOP">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/11/27/OOP/image-20201127104123081.png">
<meta property="og:image" content="http://yoursite.com/2020/11/27/OOP/image-20201127104250435.png">
<meta property="og:image" content="http://yoursite.com/2020/11/27/OOP/image-20201127104622801.png">
<meta property="og:image" content="http://yoursite.com/2020/11/27/OOP/image-20201127105530519.png">
<meta property="og:image" content="http://yoursite.com/2020/11/27/OOP/image-20201206215738802.png">
<meta property="og:image" content="http://yoursite.com/2020/11/27/OOP/image-20201207212818189.png">
<meta property="og:image" content="http://yoursite.com/2020/11/27/OOP/image-20201201141728018.png">
<meta property="og:image" content="http://yoursite.com/2020/11/27/OOP/image-20201201143609221.png">
<meta property="og:image" content="http://yoursite.com/2020/11/27/OOP/image-20201208141413317.png">
<meta property="og:image" content="http://yoursite.com/2020/11/27/OOP/image-20201208141437933.png">
<meta property="og:image" content="http://yoursite.com/2020/11/27/OOP/image-20201208145138149.png">
<meta property="article:published_time" content="2020-11-27T03:42:05.000Z">
<meta property="article:modified_time" content="2020-11-27T03:42:05.000Z">
<meta property="article:author" content="Miroier">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/11/27/OOP/image-20201127104123081.png">


<link rel="canonical" href="http://yoursite.com/2020/11/27/OOP/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://yoursite.com/2020/11/27/OOP/","path":"2020/11/27/OOP/","title":"OOP"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>OOP | Seclusion</title>
  






  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Seclusion</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">1</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">15</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#c%E7%9A%84%E5%88%9D%E6%AD%A5%E7%9F%A5%E8%AF%86"><span class="nav-text">C++的初步知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#c%E5%AF%B9c%E7%9A%84%E6%89%A9%E5%85%85"><span class="nav-text">C++对C的扩充</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4"><span class="nav-text">名字空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4-1"><span class="nav-text">名字空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E5%90%8D%E7%9A%84%E5%90%8D%E5%AD%97%E7%A9%BA%E9%97%B4"><span class="nav-text">无名的名字空间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-text">C++的输入&#x2F;输出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8cout%E8%BF%9B%E8%A1%8C%E8%BE%93%E5%87%BA"><span class="nav-text">用cout进行输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8cin%E8%BF%9B%E8%A1%8C%E8%BE%93%E5%85%A5"><span class="nav-text">用cin进行输入</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8const%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F"><span class="nav-text">用const定义常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="nav-text">函数原型声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-text">函数的重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-text">函数模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-text">有默认参数的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8reference"><span class="nav-text">引用(reference)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-text">引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="nav-text">引用与函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-text">作函数的参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%9C%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">作函数的返回值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-text">内联函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">作用域运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E9%87%8F"><span class="nav-text">字符串变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E6%92%A4%E9%94%80%E5%86%85%E5%AD%98newdelete"><span class="nav-text">动态分配&#x2F;撤销内存(new&#x2F;delete)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-text">测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-text">类和对象的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text">面向过程与面向对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB"><span class="nav-text">对象和类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">类的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%A6%E6%88%B7account%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="nav-text">账户Account结构体类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="nav-text">访问权限控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%B1%BB"><span class="nav-text">时间类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E6%9C%89%E6%88%90%E5%91%98public-member"><span class="nav-text">公有成员（public member）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98private-member"><span class="nav-text">私有成员（private member）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E6%88%90%E5%91%98protected-member"><span class="nav-text">保护成员（protected member）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%BB%86%E5%8C%96"><span class="nav-text">进一步细化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="nav-text">数据成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-text">成员函数的实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E7%B1%BB%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">在类中实现成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E7%B1%BB%E5%A4%96%E5%AE%9E%E7%8E%B0%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">在类外实现成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%B1%BB%E5%8D%95%E6%96%87%E4%BB%B6"><span class="nav-text">时间类（单文件）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%B1%BB%E5%A4%9A%E6%96%87%E4%BB%B6"><span class="nav-text">时间类（多文件）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-text">创建对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-text">类成员的访问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">类作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%B1%BB-1"><span class="nav-text">时间类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95-1"><span class="nav-text">测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-text">使用类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">构造函数和析构函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">无参构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E7%9A%84%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">默认的无参构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">带参数的构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">类的数据成员的初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">带默认参数的构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">构造函数的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">析构函数的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F"><span class="nav-text">构造函数和析构函数的调用顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">复制（拷贝）构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">复制构造函数与普通构造函数的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">复制构造函数的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB"><span class="nav-text">对象间的数据共享</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%9E%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="nav-text">类的非静态数据成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="nav-text">类的静态数据成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">静态成员的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="nav-text">静态数据成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">静态数据成员的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">静态数据成员的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">静态成员函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88"><span class="nav-text">对象指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">对象指针的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98"><span class="nav-text">通过指针访问对象成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1"><span class="nav-text">动态对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E6%8C%87%E9%92%88"><span class="nav-text">this指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%90%91%E9%9D%9E%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-text">指向非静态数据成员的指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%90%91%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-text">指向非静态成员函数的指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%90%91%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-text">指向类的静态成员的指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="nav-text">对象引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BF%9D%E6%8A%A4"><span class="nav-text">共享数据的保护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E5%AF%B9%E8%B1%A1"><span class="nav-text">常对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%B8%B8%E6%88%90%E5%91%98"><span class="nav-text">类的常成员</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="nav-text">常数据成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">常成员函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const%E6%88%90%E5%91%98%E5%92%8C%E9%9D%9Econst%E6%88%90%E5%91%98%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="nav-text">const成员和非const成员之间的调用关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const%E4%B8%8E%E6%8C%87%E9%92%88"><span class="nav-text">const与指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E5%BC%95%E7%94%A8"><span class="nav-text">常引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="nav-text">对象数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98"><span class="nav-text">对象成员</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">对象成员的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E6%95%B0%E7%BB%84"><span class="nav-text">对象成员数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-text">类模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">类模板的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-text">类模板的实例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">类模板中的成员函数的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-text">使用默认参数的类模板</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95-2"><span class="nav-text">测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-text">运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">运算符重载的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E5%87%BA%E9%97%AE%E9%A2%98"><span class="nav-text">提出问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%80%83"><span class="nav-text">思考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E8%AE%BE%E8%AE%A1%E5%A4%8D%E6%95%B0%E7%B1%BBcomplex"><span class="nav-text">重新设计复数类Complex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="nav-text">成员函数定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%BD%A2%E5%BC%8F"><span class="nav-text">运算符重载的两种形式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD-1"><span class="nav-text">运算符重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%BA%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">重载为类的成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E5%A4%8D%E6%95%B0%E7%B1%BB%E4%B8%AD%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">在复数类中重载运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="nav-text">运算符重载函数定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E"><span class="nav-text">说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E8%A7%84%E5%88%99"><span class="nav-text">运算符重载的规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E8%83%BD%E9%87%8D%E8%BD%BD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">不能重载的运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-text">单目运算符的重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E-1"><span class="nav-text">说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%AE%9A%E4%B9%89"><span class="nav-text">友元的作用和定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="nav-text">友元函数与普通函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="nav-text">友元类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%B0%8F%E7%BB%93"><span class="nav-text">友元小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">运算符重载的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%BA%E7%B1%BB%E7%9A%84%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-text">重载为类的友元函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-text">单目运算符重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E8%BE%93%E5%85%A5%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">重载输入运算符和输出运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%BD%A2%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-text">两种运算符重载形式的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-text">类型转换运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%88%B0%E7%B1%BB%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">基本类型到类类型的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B%E5%88%B0%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">类类型到基本类型的转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="nav-text">本章小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95-3"><span class="nav-text">测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F"><span class="nav-text">继承与派生</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%BC%95%E5%87%BA"><span class="nav-text">继承的引出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E6%80%A7%E4%B8%8E%E5%B7%AE%E5%88%AB%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-text">共性与差别的表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%80%A7inheritance"><span class="nav-text">继承性（inheritance）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">派生类的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E5%90%8E%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="nav-text">派生后的访问权限控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="nav-text">公有继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E7%BB%A7%E6%89%BF"><span class="nav-text">保护继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%81%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="nav-text">私有继承</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">派生类的构造函数和析构函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-1"><span class="nav-text">派生类的构造函数和析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F-1"><span class="nav-text">构造函数和析构函数的调用顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="nav-text">多继承与虚基类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">多继承派生类的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">多继承派生类的构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%BC%95%E8%B5%B7%E7%9A%84%E4%BA%8C%E4%B9%89%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-text">多继承引起的二义性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E5%9F%BA%E7%B1%BB%E6%9C%89%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98"><span class="nav-text">两个基类有同名成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%89%E8%80%85%E9%83%BD%E6%9C%89%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98"><span class="nav-text">两个基类和派生类三者都有同名成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E7%B1%BBa%E5%92%8C%E7%B1%BBb%E6%98%AF%E4%BB%8E%E5%90%8C%E4%B8%80%E4%B8%AA%E5%9F%BA%E7%B1%BB%E6%B4%BE%E7%94%9F%E7%9A%84"><span class="nav-text">如果类A和类B是从同一个基类派生的</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="nav-text">虚基类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F"><span class="nav-text">构造函数的调用顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">虚基类的初始化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95-4"><span class="nav-text">测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">多态性与虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E8%A7%84%E5%88%99"><span class="nav-text">类型兼容规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-text">多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%94%E7%BC%96"><span class="nav-text">联编</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E7%BC%96%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">联编的分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">虚析构函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E8%99%9A%E5%B1%9E%E6%80%A7"><span class="nav-text">继承虚属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">纯虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E4%BD%93%E4%B8%BA%E7%A9%BA%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">纯虚函数与函数体为空的虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95-5"><span class="nav-text">测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-text">输入输出流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81"><span class="nav-text">流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E9%97%AE%E9%A2%98"><span class="nav-text">分析问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81-1"><span class="nav-text">流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E6%B5%81"><span class="nav-text">I&#x2F;O流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E6%B5%81%E7%B1%BB%E5%BA%93%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-text">I&#x2F;O流类库的层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#io%E6%B5%81%E7%B1%BB%E5%BA%93%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-text">I&#x2F;O流类库的头文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-text">无格式输入&#x2F;输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA"><span class="nav-text">无格式输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%85%A5"><span class="nav-text">无格式输入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6"><span class="nav-text">输入输出的格式控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%B5%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="nav-text">用流对象的成员函数格式化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%B5%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%AF%B9%E7%8A%B6%E6%80%81%E6%A0%87%E5%BF%97%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="nav-text">用流对象的成员函数对状态标志进行操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%B5%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E8%BE%93%E5%87%BA%E5%AE%BD%E5%BA%A6"><span class="nav-text">用流对象的成员函数设置输出宽度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%A1%AB%E5%85%85%E5%AD%97%E7%AC%A6"><span class="nav-text">设置填充字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E8%BE%93%E5%87%BA%E7%B2%BE%E5%BA%A6"><span class="nav-text">设置输出精度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%B5%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0put%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6"><span class="nav-text">用流成员函数put输出字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E4%BA%8E%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E7%9A%84%E6%B5%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">用于字符输入的流成员函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8get%E5%87%BD%E6%95%B0%E8%AF%BB%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="nav-text">用get函数读入一个字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8getline%E5%87%BD%E6%95%B0%E8%AF%BB%E5%85%A5%E4%B8%80%E8%A1%8C%E5%AD%97%E7%AC%A6"><span class="nav-text">用getline函数读入一行字符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#istream%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">istream类的其他成员函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#eof%E5%87%BD%E6%95%B0"><span class="nav-text">eof函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#peek%E5%87%BD%E6%95%B0"><span class="nav-text">peek函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#putback%E5%87%BD%E6%95%B0"><span class="nav-text">putback函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ignore%E5%87%BD%E6%95%B0"><span class="nav-text">ignore函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%8E%A7%E5%88%B6%E7%AC%A6%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="nav-text">用控制符格式化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E5%88%B6%E7%AC%A6%E5%87%BD%E6%95%B0"><span class="nav-text">用户自定义控制符函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-text">文件的输入&#x2F;输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81"><span class="nav-text">文件流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4"><span class="nav-text">C++中进行文件操作的一般步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E4%B8%8E%E5%85%B3%E9%97%AD"><span class="nav-text">文件的打开与关闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99"><span class="nav-text">文件的读写</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E7%94%A8%E9%BB%98%E8%AE%A4%E6%96%B9%E5%BC%8F%E6%89%93%E5%BC%80"><span class="nav-text">文本文件的读写：文本文件用默认方式打开。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99"><span class="nav-text">二进制文件的读写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%86%99"><span class="nav-text">文件的随机读写</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%BB%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0"><span class="nav-text">移动读指针函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E5%86%99%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0"><span class="nav-text">移动写指针函数</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B5%81%E5%86%85%E5%AD%98%E6%B5%81"><span class="nav-text">字符串流（内存流）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="nav-text">建立输出字符串流对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="nav-text">建立输入字符串流对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="nav-text">建立输入输出字符串流对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-text">注意</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Miroier"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Miroier</p>
  <div class="site-description" itemprop="description">keep calm and carry on</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button site-overview-item animated">
    <button><i class="fa fa-comment"></i>
      Chat
    </button>
  </div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Miroier" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Miroier" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.ryuuyou.cn/" title="https:&#x2F;&#x2F;www.ryuuyou.cn&#x2F;" rel="noopener" target="_blank">RyuuYou</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.gislxz.top/" title="http:&#x2F;&#x2F;www.gislxz.top&#x2F;" rel="noopener" target="_blank">Yui</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://dimsmary.tech/" title="https:&#x2F;&#x2F;dimsmary.tech&#x2F;" rel="noopener" target="_blank">Dimsmary</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://sydddl.github.io/" title="https:&#x2F;&#x2F;sydddl.github.io&#x2F;" rel="noopener" target="_blank">DeathSprout</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://syvshc.github.io/" title="https:&#x2F;&#x2F;syvshc.github.io&#x2F;" rel="noopener" target="_blank">无锤乙醇</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://myqaq.cn/" title="https:&#x2F;&#x2F;myqaq.cn&#x2F;" rel="noopener" target="_blank">双语之城</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://peng-yq.github.io/" title="https:&#x2F;&#x2F;peng-yq.github.io&#x2F;" rel="noopener" target="_blank">PYQ</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://baozi.run/" title="https:&#x2F;&#x2F;baozi.run&#x2F;" rel="noopener" target="_blank">江盟</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.bj-yan.top/" title="https:&#x2F;&#x2F;blog.bj-yan.top&#x2F;" rel="noopener" target="_blank">北屿</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://windy810.github.io/" title="https:&#x2F;&#x2F;windy810.github.io&#x2F;" rel="noopener" target="_blank">Windy</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://qgrain.github.io/" title="https:&#x2F;&#x2F;qgrain.github.io&#x2F;" rel="noopener" target="_blank">Zhiyu</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/Miroier" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/27/OOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Miroier">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Seclusion">
      <meta itemprop="description" content="keep calm and carry on">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="OOP | Seclusion">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          OOP
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-27 11:42:05" itemprop="dateCreated datePublished" datetime="2020-11-27T11:42:05+08:00">2020-11-27</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>104k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:35</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>C++OOP</p>
<span id="more"></span>
<h1 id="c的初步知识">C++的初步知识</h1>
<h2 id="c对c的扩充">C++对C的扩充</h2>
<h3 id="名字空间">名字空间</h3>
<h4 id="名字空间-1">名字空间</h4>
<p>C++标准库中的类和函数是在名字空间std中声明的。</p>
<p>名字空间可以消除那些因重名而导致的命名冲突。</p>
<p>能在名字空间以外声明或定义的实体，同样也能在名字空间之内声明或定义。</p>
<p>一个名字空间由关键字namespace开始，通常后接一个标识符来标识名字空间。在名字空间开始和结束的地方分别用左右大括号标记。</p>
<p>假设两个名字空间都有变量inflag，那么定义的语法为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ns1&#123;</span><br><span class="line">    <span class="type">int</span> inflag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> ns2&#123;</span><br><span class="line">    <span class="type">int</span> inflag;</span><br><span class="line">&#125;</span><br><span class="line">==&gt;</span><br><span class="line">ns1::inflag=<span class="number">2</span>;</span><br><span class="line">ns2::inflag=<span class="number">-3</span>;</span><br><span class="line">==&gt;</span><br><span class="line"><span class="keyword">using</span> ns1::inflag;</span><br><span class="line">inflag=<span class="number">2</span>;</span><br><span class="line">ns2::inflag=<span class="number">-3</span>;</span><br></pre></td></tr></table></figure>
<h4 id="无名的名字空间">无名的名字空间</h4>
<p>C++允许使用没有名字的名字空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="type">int</span> inflag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于名字空间没有名字，因此无法在其它文件中引用。</p>
<p>无名名字空间内的成员的作用域为本文件从声明无名名字空间的位置开始到文件结束。</p>
<h3 id="c的输入输出">C++的输入/输出</h3>
<p>C++的输入／输出是由I/O流类库提供的。流类对象cin和cout分别代表标准的输入设备和输出设备。它们在文件iostream声明。</p>
<h4 id="用cout进行输出">用cout进行输出</h4>
<p>在C++中<strong>输出操作</strong>可理解为将数据插入到输出流对象中。<strong>屏幕</strong>输出是标准输出操作，用来将表达式的结果输出到显示器的屏幕上。其一般形式可表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;表达式1&lt;&lt;表达式2&lt;&lt;…&lt;&lt;表达式n；    </span><br></pre></td></tr></table></figure>
<p>其中，<strong>cout</strong>是预定义的标准<strong>输出流对象</strong>，<strong>&lt;&lt;</strong>是输出运算符。用它可以输出各种不同类型的数据。</p>
<h4 id="用cin进行输入">用cin进行输入</h4>
<p>在C++中<strong>输入操作</strong>可理解为从输入流对象中提取数据。<strong>键盘</strong>输入是标准输入，其一般形式可表示为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;变量1&gt;&gt;变量2&gt;&gt;…&gt;&gt;变量n； </span><br></pre></td></tr></table></figure>
<p>其中，<strong>cin</strong>是预定义的标准<strong>输入流对象</strong>，<strong>&gt;&gt;</strong>是输入运算符。</p>
<h3 id="用const定义常量">用const定义常量</h3>
<p>C语言中常用#define命令来定义符号常量</p>
<ul>
<li>在预编译时进行字符置换，又称宏替换</li>
</ul>
<p>C++通过给常量命名的方式定义常量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span>&lt;数据类型名&gt;&lt;常量名&gt;=&lt;表达式&gt;;</span><br><span class="line"><span class="type">const</span>  <span class="type">int</span> MaxLine =<span class="number">1000</span>;</span><br></pre></td></tr></table></figure>
<p>用const定义标识符常量时，<strong>一定要对其初始化。在说明时进行初始化是对这种常量置值的唯一方法</strong> ，不能用赋值运算符对这种常量进行赋值。如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaxLine =<span class="number">35</span>;</span><br></pre></td></tr></table></figure>
<p>const常量与宏常量相比的优点：</p>
<ul>
<li>const常量有数据类型，而宏常量没有数据类型。</li>
<li>有些集成化的调试工具可以对const常量进行调试，但不能对宏常量进行调试。</li>
</ul>
<h3 id="函数原型声明">函数原型声明</h3>
<p>在C语言中，如果函数调用的位置在函数定义之前，则应在函数调用之前对所调用的函数作声明。但如果所调用的函数是整型的，也可以不进行函数声明。</p>
<p>对于函数声明的形式，C语言<strong>建议</strong>采用函数原型声明。</p>
<p>在C++中，如果函数调用的位置在函数定义之前，则要求在函数调用之前<strong>必须</strong>对所调用的函数作函数原型声明。</p>
<p>函数声明的一般形式为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数类型 函数名（参数表）；</span><br></pre></td></tr></table></figure>
<h3 id="函数的重载">函数的重载</h3>
<p>定义 在同一作用域中用<strong>同一函数名定义多个函数</strong>，这些函数的参数个数和参数类型不同，这些同名的函数用来实现不同的功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span>,<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">add</span>(<span class="number">5</span>, <span class="number">10</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">add</span>(<span class="number">5.0</span>, <span class="number">10.5</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15</span><br><span class="line">15.5</span><br></pre></td></tr></table></figure>
<h3 id="函数模板">函数模板</h3>
<p>为什么引入函数模板？函数重载存在的问题。</p>
<p><em>定义</em> 实际上是一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来代表。</p>
<p>凡是函数体相同的函数都可以用这个模板来代替，不必定义多个函数，只需在模板中定义一次即可。</p>
<p>在调用函数时系统会根据实参的类型来取代模板中的虚拟类型，从而实现了不同函数的功能。</p>
<p>函数模板的定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> 或 <span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span>(a&gt;b)? a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>只适用于函数的参数个数相同而类型不同，且函数体相同的情况。</p>
</blockquote>
<p>函数模板是对一组函数的描述，它以任意类型T为参数及函数返回值。</p>
<p>函数模板不是一个实实在在的函数，编译系统并不产生任何执行代码。</p>
<p>当编译系统在程序中发现有与函数模板中相匹配的函数调用时，便生成一个重载函数，该重载函数的函数体与函数模板的函数体相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span>(a&gt;b)? a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该重载函数称为<strong>模板函数</strong>，它是函数模板的一个具体实例，只处理一种唯一的数据类型。</p>
</blockquote>
<p><em>定义</em> 函数模板时可以使用多个类型参数，每个类型参数前面只需加上关键字typename或class，用逗号分隔：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function">T1 <span class="title">max</span><span class="params">(T1 a,T2 b)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (a&gt;b) ? a : (T1)b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数模板比函数重载更方便，程序更简洁。</p>
</blockquote>
<h3 id="有默认参数的函数">有默认参数的函数</h3>
<p>一般情况下，在函数调用时形参从实参那里取得值，因此实参的个数应与形参相同。</p>
<p>C++可以给形参一个默认值，这样形参就不必一定要从实参取值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数声明：<span class="function"><span class="type">int</span> <span class="title">area</span><span class="params">(<span class="type">int</span> a=<span class="number">6</span>)</span></span>;</span><br><span class="line">(<span class="number">1</span>)  <span class="built_in">area</span>(<span class="number">7</span>); </span><br><span class="line">(<span class="number">2</span>)  <span class="built_in">area</span>(); &lt;==&gt; <span class="built_in">area</span>(<span class="number">6</span>); </span><br></pre></td></tr></table></figure>
<p>如果有多个形参，可以指定任意个默认值。</p>
<p>实参与形参的结合是从左至右进行的，因此指定默认值的参数必须放在形参列表中的<strong>最右端</strong>。</p>
<p>必须在函数调用之前将默认值的信息通知编译系统。</p>
<p>当重载函数与默认参数函数<strong>共同使用</strong>时，要注意出现<strong>二义性</strong>问题。</p>
<h3 id="引用reference">引用(reference)</h3>
<h4 id="引用">引用</h4>
<p><em>定义</em> 对变量起另外一个名字 (别名alias)，这个名字称为该变量的引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型&gt;   &amp;&lt;引用变量名&gt; = &lt;原变量名&gt;；</span><br></pre></td></tr></table></figure>
<p>其中<strong>原变量名</strong>必须是一个已定义过的变量。如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>   max ;</span><br><span class="line"><span class="type">int</span>  &amp;refmax=max;</span><br></pre></td></tr></table></figure>
<p>refmax并没有重新在内存中开辟存储单元，只是<strong>引用</strong>max的单元。max与refmax<strong>在内存中占用同一地址，即同一地址两个名字</strong>。</p>
<p>对引用类型的变量，说明以下几点：</p>
<ol type="1">
<li><p>引用在定义的时候要初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  &amp;refmax; <span class="comment">//错误，没有具体的引用对象</span></span><br><span class="line"><span class="type">int</span>  &amp;refmax=max; <span class="comment">//max是已定义过的变量</span></span><br></pre></td></tr></table></figure></li>
<li><p>对引用的操作就是对被引用的变量的操作</p></li>
<li><p>引用类型变量的初始化值不能是一个常数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  &amp;ref1 = <span class="number">5</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure></li>
<li><p>一旦引用被声明，它就不能再指向其它的变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  a1, a2;</span><br><span class="line"><span class="type">int</span>  &amp;b=a1; <span class="comment">//使b成为变量a1的引用</span></span><br><span class="line"><span class="type">int</span>  &amp;b=a2; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure></li>
<li><p>对引用的初始化，可以用一个变量名，也可以用另一个引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  a=<span class="number">3</span>;</span><br><span class="line"><span class="type">int</span>  &amp;b=a; <span class="comment">//使b成为变量a的引用</span></span><br><span class="line"><span class="type">int</span>  &amp;c=b; <span class="comment">//使c成为引用b的别名</span></span><br></pre></td></tr></table></figure></li>
<li><p>引用同变量一样有地址，可以对其地址进行操作，即将其地址赋给一指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  a, *p;</span><br><span class="line"><span class="type">int</span>  &amp;m=a; <span class="comment">//&amp;是变量的引用</span></span><br><span class="line">p=&amp;m; <span class="comment">//&amp;是变量的地址</span></span><br><span class="line">*p=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当&amp;m的前面有<strong>类型符</strong>时（如int &amp;m），它必然是对引用的声明；如果前面无类型符（如cout&lt;&lt;&amp;m）,则是取变量的地址。</p>
</blockquote></li>
<li><p>对const常量的引用使用如下方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;a=i; <span class="comment">//声明常引用，不允许改变a的值</span></span><br><span class="line">a =<span class="number">3</span>； <span class="comment">//错误</span></span><br><span class="line">i =<span class="number">3</span>； <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>以下的声明是非法的</p>
<ul>
<li>企图建立void类型的引用 void &amp;a</li>
<li>企图建立引用的数组 int &amp; a[6]</li>
<li>企图建立指向引用的指针 int &amp; *p</li>
</ul>
<p>指针与引用的区别： 1. 指针是通过地址<strong>间接</strong>访问某个变量，而引用是通过别名<strong>直接</strong>访问某个变量。 2. 引用必须初始化，而<strong>一旦被初始化后不得再作为其它变量的别名</strong>。指针若不进行初始化，编译器不会报错。</p>
<h4 id="引用与函数">引用与函数</h4>
<p>引用的用途主要是用来作<strong>函数的参数</strong>或<strong>函数的返回值</strong>。</p>
<h5 id="作函数的参数">作函数的参数</h5>
<p>C语言中函数的参数传递有两种情况：</p>
<ul>
<li><p>将变量名作为实参</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>, j = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">swapint</span>(i, j);</span><br><span class="line">    cout &lt;&lt; i &lt;&lt;“,”&lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>,<span class="number">5</span></span><br></pre></td></tr></table></figure></li>
<li><p>传递变量的指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapint</span><span class="params">(<span class="type">int</span> *p1, <span class="type">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>, j = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">swapint</span>(&amp;i, &amp;j);</span><br><span class="line">    cout &lt;&lt; i &lt;&lt;“,”&lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>C++把变量的引用作为函数形参，即传送变量的别名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapint</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span> <span class="comment">//a,b是实参i,j的别名</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">3</span>, j = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">swapint</span>(i, j); <span class="comment">//实参为变量</span></span><br><span class="line">    cout &lt;&lt; i &lt;&lt;“,”&lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5,3</span><br></pre></td></tr></table></figure>
<p>引用和指针变量作为形参的区别</p>
<p>引用作为形参，实参是<strong>变量</strong>;指针变量作形参,实参是<strong>地址</strong>。</p>
<p>指针变量要另外开辟内存单元，其内容是地址；引用不是一个独立的变量，不单独占内存单元。</p>
<p>必须用指针运算符*来表示指针变量所指向的变量；而引用就代表该变量。</p>
<p>引用比指针更直观、方便、容易理解。</p>
<h5 id="作函数的返回值">作函数的返回值</h5>
<p>一般情况下，<strong>函数不作为左值</strong>（即函数不能放在赋值号左边）。</p>
<p>如果将函数定义为返回引用类型，因为返回的是一个变量的别名，就可以将函数放在左边，即给这个变量赋值。</p>
<p>这一点类同于函数的返回值为指针类型 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = a + x;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">5</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(t) &lt;&lt; endl; <span class="comment">//输出9(a=9)</span></span><br><span class="line">    <span class="built_in">f</span>(t) = <span class="number">20</span>;            <span class="comment">//先调用，再赋值 a=20</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(t) &lt;&lt; endl; <span class="comment">//输出25(a=25)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个函数返回引用类型，<strong>必须返回某个类型的变量</strong>。</p>
<p>返回的变量的引用，<span style="color:red;">这个变量必须是全局变量或静态局部变量，即存储在静态区中的变量。</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">f</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> t = <span class="number">2</span>;</span><br><span class="line">    t = x++;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(a) &lt;&lt; endl; <span class="comment">//输出3   a=4   t=3</span></span><br><span class="line">    <span class="built_in">f</span>(a) = <span class="number">20</span>;            <span class="comment">//t=20   a=5</span></span><br><span class="line">    a = a + <span class="number">5</span>;            <span class="comment">//a=10</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(a) &lt;&lt; endl; <span class="comment">//输出10   a=11</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内联函数">内联函数</h3>
<p>调用函数需要一定的时间，如果有的函数需要频繁使用，则累计所用时间会很长，从而降低程序的执行效率。</p>
<p>C++提供一种提高效率的方法，即在编译时将所调用函数的代码嵌入到主函数中。这种嵌入到主函数中的函数称为<strong>内联函数</strong>(inline function，<strong>内置函数</strong>，<strong>内嵌函数</strong>)</p>
<p>内联函数是C++对C函数的扩充，是一种以<strong>空间效率换取时间效率</strong>的机制。</p>
<p>内联函数定义的一般格式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> &lt;函数值类型&gt;  &lt;函数名&gt;(&lt;参数表&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    &lt;函数体&gt;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用内联函数时，编译器首先检查调用是否正确（类型安全检查或者自动进行类型转换）。<strong>如果正确，则将内联函数的代码直接替换函数调用，并且用实参换形参</strong>，于是省去了函数调用的开销。因此，内联机制增加了空间开销而节约了时间开销。</p>
<p>内联函数与用#define命令实现的带参宏定义有些相似，但不完全相同</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Max(a,b) (a)&gt;(b) ? (a) : (b)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用内联函数可以达到用#define宏置换的目的，但不会出现带参宏定义的副作用。</p>
<p>慎用内联 * 使用内联函数可以节省运行时间，但却增加了目标程序的长度。 * 函数体内出现循环或递归等复杂的结构控制语句时，不适合定义为内联函数。 * 一个好的编译器将会根据函数的函数体，自动取消不值得的内联。</p>
<h3 id="作用域运算符">作用域运算符</h3>
<p>每一个变量都有其有效的作用域，只能在变量的作用域内使用该变量，不能直接使用其它作用域中的变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">float</span> a = <span class="number">13.5</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ::a &lt;&lt; endl; <span class="comment">//::a表示全局作用域中的变量a。注意：不能用::访问函数中的局部变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">13.5</span><br></pre></td></tr></table></figure>
<h3 id="字符串变量">字符串变量</h3>
<p>C++用一种更方便的字符串类型(string类型)定义字符串变量。string不是基本类型，是一个字符串类</p>
<p>定义字符串变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string string1;            string string2=“China”; </span><br></pre></td></tr></table></figure>
<p>对字符串变量的赋值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string1=“Canada”;      string1=string2;</span><br></pre></td></tr></table></figure>
<ul>
<li>在定义字符串变量时不需指定长度，它的长度随其中的字符串长度而改变</li>
<li>可以对字符串变量中某一字符进行操作 string2[2]=‘a’;</li>
<li>字符串常量以‘\0’作为结束符，但将字符串常量存放到字符串变量中时，只存放字符串本身而不包括‘\0’</li>
</ul>
<p>字符串变量的输入输出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;string1;          cout&lt;&lt;string2;</span><br></pre></td></tr></table></figure>
<p>字符串变量的运算</p>
<ul>
<li><p>用赋值运算符实现字符串复制</p></li>
<li><p>```cpp string1=string2; 与strcpy(string1,string2);相似<br />
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 用加法运算符实现字符串连接</span><br><span class="line"></span><br><span class="line">  ```cpp</span><br><span class="line">  string1=string1+string2;</span><br></pre></td></tr></table></figure></p></li>
<li><p>用关系运算符(==,&gt;,&lt;,!=,&gt;=,&lt;=)实现字符串比较</p></li>
</ul>
<p>字符串数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string name[<span class="number">3</span>]=&#123;“Zhang”,”Li”,”Wang”&#125;; </span><br></pre></td></tr></table></figure>
<ul>
<li>在一个字符串数组中包含若干个元素，每个元素相当于一个字符串变量<br />
</li>
<li>不要求每个字符串元素具有相同的长度，即使对同一个元素而言，它的长度也可以变化</li>
<li>每一个字符串元素中只包含字符串本身的字符而不包括‘\0’</li>
</ul>
<h3 id="动态分配撤销内存newdelete">动态分配/撤销内存(new/delete)</h3>
<p>C语言利用malloc和free分配和撤销内存空间。</p>
<p>使用malloc必须指定需要开辟的内存空间的大小，而且其返回值为 void *类型，必须进行强制类型转换才能使其返回的指针指向具体的数据。</p>
<p>new运算从堆中分配一块与<类型>相适应的存储空间，若分配成功，将这块存储空间的起始地址存入<指针变量名>。new的使用格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;指针变量名&gt;=new &lt;类型&gt;;</span><br><span class="line">&lt;指针变量名&gt;=new &lt;类型&gt;(&lt;初值&gt;);</span><br><span class="line">&lt;指针变量名&gt;=new &lt;类型&gt;[&lt;元素个数&gt;];</span><br></pre></td></tr></table></figure>
<p>delete运算符用来释放<指针变量名>指向的动态存储空间。使用格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete &lt;指针变量名&gt;  </span><br><span class="line">delete[] &lt;指针变量名&gt;</span><br></pre></td></tr></table></figure>
<p>其中，第2种格式用于释放指针指向的连续存储空间，即释放数组占用的空间。</p>
<p>动态整数存储空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">//分配存放整数的空间</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">(<span class="number">2</span>) <span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">3</span>); <span class="comment">//整数初值为3</span></span><br><span class="line">    <span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>
<p>连续存储空间（即数组空间）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">//该数组有5个元素</span></span><br><span class="line"><span class="keyword">delete</span>[] p;</span><br></pre></td></tr></table></figure>
<h2 id="测试">测试</h2>
<p>1.找出下面程序的错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="type">int</span> a,b;</span><br><span class="line">   c=<span class="built_in">add</span>(a,b)</span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;a+b=&quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br><span class="line">&#123;  z=x+y;</span><br><span class="line">   <span class="keyword">return</span>(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.写出下面程序的输出结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dd</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123; x=x+z;</span><br><span class="line">  y=y-x;</span><br><span class="line">  z=<span class="number">10</span>;</span><br><span class="line">  cout&lt;&lt;x&lt;&lt;<span class="string">&quot;, &quot;</span>&lt;&lt;y&lt;&lt;<span class="string">&quot;, &quot;</span>&lt;&lt;z&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="type">int</span>  a=<span class="number">3</span>,b=<span class="number">4</span>,c=<span class="number">5</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">    <span class="built_in">dd</span>(a,b,c);</span><br><span class="line">  cout&lt;&lt;a&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot;, &quot;</span>&lt;&lt;c&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类和对象的特性">类和对象的特性</h1>
<h2 id="面向过程与面向对象">面向过程与面向对象</h2>
<p>面向过程的软件开发方法 * 按照功能划分软件的结构 * 自顶向下的设计方法 * 以函数作为程序主体</p>
<p>面向对象的软件开发方法 * 将软件系统看作各种对象的集合 * 系统结构比较稳定 * 对象将数据及函数的具体实现方式进行封装 * 提高了软件的可重用性、可维护性和可扩展性</p>
<p>面向过程编程与面向对象编程的区别： * 面向过程编程先确定算法，再确定数据结构；面向对象编程先确定数据结构，再确定运算。 * 面向过程编程的程序员，习惯于建立数据结构存放数据，并定义函数来操作数据；面向对象编程的程序员则构造一个对象模型，将数据与函数组织在一起。</p>
<p>掌握面向对象的困难之处在于<strong>思路的转换</strong></p>
<ul>
<li>我们通常习惯于考虑解决问题的方法，而不是考虑将问题抽象成对象再去解决它。</li>
</ul>
<h2 id="对象和类">对象和类</h2>
<p>对象是什么？</p>
<ul>
<li><p>实际的对象</p>
<ul>
<li><p>可以被感官感知的实物</p></li>
<li><p>思想、感觉或行为所及的概念或物理上的东西</p></li>
</ul></li>
<li><p>软件对象</p>
<ul>
<li>将状态（数据）和行为（功能）捆绑在一起的软件结构/模块，这两个部分合起来表示实际（物理或概念）对象的抽象</li>
</ul></li>
<li><p>对象的状态/数据/属性</p>
<ul>
<li><p><strong>学生</strong>对象的状态/数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">姓名</span><br><span class="line">学号</span><br><span class="line">出生日期</span><br><span class="line">地址</span><br><span class="line">专业</span><br><span class="line">本学期选择的课程清单</span><br></pre></td></tr></table></figure></li>
<li><p><strong>课程</strong>对象的状态/数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">课程编号</span><br><span class="line">课程名称</span><br><span class="line">课程所需的学时</span><br><span class="line">讲授该课程的教师名单</span><br></pre></td></tr></table></figure></li>
<li><p>对象的行为/操作/函数</p>
<ul>
<li><p><strong>学生</strong>对象的行为/操作</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注册一门课程</span><br><span class="line">取消一门课程</span><br><span class="line">选定一个专业</span><br></pre></td></tr></table></figure></p></li>
<li><p>课程对象的行为/操作</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">允许学生注册</span><br><span class="line">确定某个学生是否注册了该课程</span><br><span class="line">告知该课程需要多少学时</span><br><span class="line">告知哪一位教师讲授这门课程</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul></li>
</ul>
<p>类是什么？</p>
<ul>
<li><p>类是描述一组相似对象共有特征的抽象</p>
<ul>
<li>每一个属于该类的对象的数据结构（也就是属性的名称和类型）</li>
<li>由这些对象执行的操作/函数 （如何命令对象执行这些操作，以及为了实际执行这些操作对象必须执行的后台动作 ）</li>
</ul></li>
<li><p>类定义的实例</p>
<p><img data-src="image-20201127104123081.png" alt="image-20201127104123081" style="zoom:50%;" /></p></li>
<li><p>实例化对象</p>
<ul>
<li><p>从类创建某个对象的过程</p>
<p><img data-src="image-20201127104250435.png" alt="image-20201127104250435" style="zoom:50%;" /></p></li>
</ul></li>
<li><p>对象和类的关系</p>
<ul>
<li>对象是类的一个具有特定属性值的具体实例</li>
<li>从一个类可以创建（实例化）多个对象</li>
<li>相同类的两个对象具有相同的属性和函数，但属性值不同</li>
</ul></li>
</ul>
<h2 id="类的定义">类的定义</h2>
<p>概念的抽象</p>
<p>类的UML表示法</p>
<p>类的定义方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名             </span><br><span class="line">&#123;  </span><br><span class="line">    &lt;类成员&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，类成员包括数据成员和成员函数。</p>
<h3 id="账户account结构体类型">账户Account结构体类型</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> id[<span class="number">16</span>];          <span class="comment">//账号</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];   <span class="comment">//户名</span></span><br><span class="line">    <span class="type">char</span> pwd[<span class="number">6</span>];       <span class="comment">//密码</span></span><br><span class="line">    <span class="type">double</span> balance;  <span class="comment">//余额</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Account</span> a;       <span class="comment">//C++中，可以省略struct</span></span><br><span class="line">    a.balance = <span class="number">10000</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;balance = &quot;</span>&lt;&lt;a.balance &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在C++中，一个结构体代表一个所有成员都是public的类，该类不能对外界隐藏自己的重要信息和私密信息。结构体表示一个没有封装的类。</p>
<p>需要对账户类进行封装！C++提供了类机制。</p>
<p><img data-src="image-20201127104622801.png" alt="image-20201127104622801" style="zoom:50%;" /></p>
<p>账户类的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> id[<span class="number">16</span>];          <span class="comment">//账号</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];   <span class="comment">//户名</span></span><br><span class="line">    <span class="type">char</span> pwd[<span class="number">6</span>];       <span class="comment">//密码</span></span><br><span class="line">    <span class="type">double</span> balance;  <span class="comment">//余额</span></span><br><span class="line">&#125;;                             <span class="comment">//以括号及分号结束</span></span><br></pre></td></tr></table></figure>
<p>同理，Account类对象可定义为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Account a;</span><br></pre></td></tr></table></figure>
<p>示例类的信息隐藏特性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> id[<span class="number">16</span>];          <span class="comment">//帐号</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];   <span class="comment">//户名</span></span><br><span class="line">    <span class="type">char</span> pwd[<span class="number">6</span>];       <span class="comment">//密码</span></span><br><span class="line">    <span class="type">double</span> balance;  <span class="comment">//余额</span></span><br><span class="line">&#125;;                             <span class="comment">//以括号及分号结束</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Account a;</span><br><span class="line">    a.balance = <span class="number">10000</span>;   </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步细化类定义的一般格式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;类名&gt;</span><br><span class="line">&#123;</span><br><span class="line">&lt;访问控制符&gt;:</span><br><span class="line">    &lt;成员函数&gt;</span><br><span class="line">&lt;访问控制符&gt;:</span><br><span class="line">    &lt;数据成员&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="访问权限控制">访问权限控制</h3>
<p>访问控制符包括public（公有）、private（私有）和protected（保护）。</p>
<p>三种访问权限的成员<strong>与</strong>出现的先后<strong>顺序无关</strong>，并且允许多次出现，但是一个成员只能具有一种访问属性。</p>
<p>一般来说，将类的public成员放在类体的前面，将protected、private成员放在类体的后面。</p>
<h4 id="时间类">时间类</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:	<span class="comment">//外部接口，公有成员函数</span></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">SetTime</span><span class="params">(<span class="type">int</span> NewH, <span class="type">int</span> NewM, <span class="type">int</span> NewS)</span></span>;</span><br><span class="line">	 <span class="function"><span class="type">void</span> <span class="title">ShowTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:	<span class="comment">//私有数据成员</span></span><br><span class="line">	 <span class="type">int</span> Hour,Minute,Second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="公有成员public-member">公有成员（public member）</h4>
<p>公有成员在程序的<strong>任何地方</strong>都可以被访问，是类的<strong>对外接口</strong>。而且在类外只能访问类的公有成员（继承除外）。</p>
<p>一般来说，成员函数的访问权限设为公有的，类外通过公有成员函数来操纵该类对象的属性。</p>
<h4 id="私有成员private-member">私有成员（private member）</h4>
<p>私有成员<strong>只能</strong>被本类中的<strong>成员函数和友元</strong>访问，而不能被类外调用。所谓类外指的是普通函数或其他类的成员函数。</p>
<p>一般来说，数据成员的访问权限设为私有的或保护的（如果有继承关系时）。</p>
<h4 id="保护成员protected-member">保护成员（protected member）</h4>
<p>保护成员具有<strong>双重性</strong>，对其派生类而言，保护成员如同公有成员；对其他程序则表现得像私有成员。</p>
<p>一般来说，程序中有类继承时，可以将部分类成员定义为保护成员，以便派生类访问，同时，对类簇外又实现了信息隐藏。</p>
<h4 id="进一步细化">进一步细化</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;类名&gt;</span><br><span class="line">&#123;</span><br><span class="line">&lt;访问控制符&gt;:</span><br><span class="line">    &lt;成员函数的声明&gt;</span><br><span class="line">&lt;访问控制符&gt;:</span><br><span class="line">    &lt;数据成员的声明&gt;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;成员函数的实现&gt;</span><br></pre></td></tr></table></figure>
<p>类定义一般分为说明部分和实现部分。说明部分是说明该类中的成员，实现部分是对成员函数的定义。格式如下：</p>
<p><img data-src="image-20201127105530519.png" alt="image-20201127105530519" style="zoom:50%;" /></p>
<h3 id="数据成员">数据成员</h3>
<p>数据成员的声明看起来很像变量声明。但是，数据成员不能在类体中被显式地初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> Hour=<span class="number">0</span>;     <span class="comment">// 错误</span></span><br><span class="line">    <span class="type">int</span> Minute=<span class="number">0</span>;   <span class="comment">// 错误</span></span><br><span class="line">    <span class="type">int</span> Second=<span class="number">0</span>;   <span class="comment">// 错误</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类的数据成员将通过<strong>构造函数</strong>进行初始化。</p>
<h3 id="成员函数">成员函数</h3>
<p>类的成员函数的声明与一般函数的声明一样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;函数值类型&gt;  &lt;函数名&gt;(&lt;参数表&gt;); </span><br></pre></td></tr></table></figure>
<p>参数表中可以只含参数类型而不含参数名</p>
<h3 id="成员函数的实现方式">成员函数的实现方式</h3>
<p>成员函数是类中描述行为的成员，同时也是对封装的数据进行操作的唯一途径。</p>
<p>成员函数的实现既可以在<strong>类中</strong>，也可以在<strong>类外</strong>。从类定义的格式可知，<strong>一般</strong>在类中声明成员函数，在类外具体实现成员函数。</p>
<p>如果成员函数已经在类中定义，则不需要在类外实现。需要注意的是，<strong>在类中定义的成员函数自动成为内联函数。</strong></p>
<h4 id="在类中实现成员函数">在类中实现成员函数</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>	</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>	<span class="comment">//时间类的定义</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:	       <span class="comment">//外部接口，公有成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetTime</span><span class="params">(<span class="type">int</span> NewH, <span class="type">int</span> NewM, <span class="type">int</span> NewS)</span></span></span><br><span class="line"><span class="function">   </span>&#123;   Hour=NewH;</span><br><span class="line">       Minute=NewM;</span><br><span class="line">       Second=NewS; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">ShowTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     cout&lt;&lt;Hour&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;Minute&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;Second&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">private</span>:	 <span class="comment">//私有数据成员</span></span><br><span class="line">   <span class="type">int</span> Hour,Minute,Second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="在类外实现成员函数">在类外实现成员函数</h4>
<p>若在类体外实现，则需要使用<strong>作用域运算符“::”</strong>，用它来<strong>标识</strong>某个成员函数是属于哪个类的，其定义格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;函数值类型&gt; &lt;类名&gt;::&lt;成员函数名&gt;(&lt;参数表&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    &lt;函数体&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然在类外定义成员函数，但它仍能访问类的任何成员。成员函数必须先在类内声明，而且类体必须在成员函数定义之前出现。</p>
<h4 id="时间类单文件">时间类（单文件）</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>   </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetTime</span><span class="params">(<span class="type">int</span> NewH,<span class="type">int</span> NewM,<span class="type">int</span> New S)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ShowTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> Hour,Minute,Second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间类成员函数的实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::SetTime</span><span class="params">(<span class="type">int</span> NewH,<span class="type">int</span> NewM,<span class="type">int</span> New S)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    Hour=NewH;       <span class="comment">//成员函数可直接访问私有成员</span></span><br><span class="line">    Minute=NewM;</span><br><span class="line">    Second=NewS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::ShowTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;Hour&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;Minute&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;Second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="时间类多文件">时间类（多文件）</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//time.h                //头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>	</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>	       <span class="comment">//时间类的声明</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:	              <span class="comment">//外部接口，公有成员函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetTime</span><span class="params">(<span class="type">int</span> NewH, <span class="type">int</span> NewM, <span class="type">int</span> NewS)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ShowTime</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:	       <span class="comment">//私有数据成员</span></span><br><span class="line">  <span class="type">int</span> Hour,Minute,Second;</span><br><span class="line">&#125;;		</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//time.cpp                //源程序文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;time.h&quot;</span>	<span class="comment">//包含类的声明所在的头文件</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::SetTime</span><span class="params">(<span class="type">int</span> NewH, <span class="type">int</span> NewM, <span class="type">int</span> NewS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Hour=NewH;       <span class="comment">//成员函数可直接访问私有成员</span></span><br><span class="line">   Minute=NewM;</span><br><span class="line">   Second=NewS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::ShowTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout&lt;&lt;Hour&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;Minute&lt;&lt;<span class="string">&quot;:&quot;</span>&lt;&lt;Second&lt;&lt;endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将类的声明和实现分别放在两个不同的文件中，这样做有以下几点好处： * 类的实现文件通常较大，分开便于阅读、管理和维护。 * 对软件开发商而言，他们可以向用户提供一些程序模块的接口，而不公开程序的源代码。分开管理就可以很好地解决此问题。 * 将类定义放在头文件中，以后使用不必再定义，只须一条包含命令即可，实现了代码重用。 * 便于团队对大型软件的分工合作开发。</p>
<h2 id="创建对象">创建对象</h2>
<p>对象的定义格式与普通变量相同。定义格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类名&gt; &lt;对象名表&gt;;</span><br></pre></td></tr></table></figure>
<p><对象名表>中可以有一个或多个<strong>对象名</strong>。当有多个对象名时，用逗号分隔。<对象名表>中还可以是指向对象的<strong>指针名</strong>或<strong>引用名</strong>，也可以是<strong>对象数组名</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Time time1,time2; <span class="comment">//声明对象time1,time2</span></span><br></pre></td></tr></table></figure>
<p>对象创建的另一种方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;类名&gt;&#123;…&#125; &lt;对象名&gt;;</span><br></pre></td></tr></table></figure>
<p>在声明类的同时创建对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>&#123;…&#125; time1,time2;</span><br></pre></td></tr></table></figure>
<p>对象的UML表示法</p>
<h2 id="类成员的访问">类成员的访问</h2>
<p>面向对象程序设计中，对类成员的访问往往通过<strong>接口</strong>（类的成员函数）实现。</p>
<p>在设计接口时，应注意为该类可以<strong>暴露</strong>给外界的信息提供接口，同时<strong>隐藏</strong>私密信息。</p>
<p>定义了类及其对象，就可以通过对象来使用其公有成员，从而达到对对象内部属性的访问和修改。</p>
<p><strong>在类中</strong>可<strong>直接</strong>使用成员名<strong>访问</strong>类成员，public、private和protected属性的成员都可以被访问。</p>
<p>类外访问对象中的成员可以有3种方法：</p>
<ul>
<li><p>通过对象名和成员运算符访问对象中的成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;对象名&gt;.&lt;公有成员&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>通过指向对象的指针变量访问对象中的成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;对象指针名&gt; -&gt; &lt;公有成员&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>通过对象的引用访问对象中的成员。</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Setxy</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; x &lt;&lt;“,”&lt;&lt; y &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1, a2; <span class="comment">//定义对象</span></span><br><span class="line">    a1.m = <span class="number">10</span>;</span><br><span class="line">    a1.n = <span class="number">20</span>;      <span class="comment">//为公有成员数据赋值</span></span><br><span class="line">    a1.<span class="built_in">Setxy</span>(<span class="number">2</span>, <span class="number">5</span>); <span class="comment">//为私有成员数据赋值</span></span><br><span class="line">    a1.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>,<span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>用成员运算符“.”只能访问对象的<strong>公有成员</strong>，而不能访问对象的私有成员或保护成员。</p>
<p>若要访问对象的私有的数据成员，<strong>只能通过对象的公有成员函数</strong>来获取。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Setxy</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">//必须通过类内公有函数访问私有数据成员</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; x &lt;&lt;“,”&lt;&lt; y &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1, a2;</span><br><span class="line">    a1.m = <span class="number">10</span>;</span><br><span class="line">    a1.n = <span class="number">20</span>;          <span class="comment">//为公有成员数据赋值</span></span><br><span class="line">    a1.x = <span class="number">2</span>, a1.y = <span class="number">5</span>; <span class="comment">//非法，私有成员不能在类外访问</span></span><br><span class="line">    a1.<span class="built_in">Setxy</span>(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    a1.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类作用域">类作用域</h3>
<p>类体的区域称为<strong>类作用域</strong>。类的成员函数与数据成员，其作用域都是属于类的作用域，仅在该类的范围内有效，<strong>故不能在主函数中直接通过函数名和成员名来调用</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> m, n;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Setxy</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; cout &lt;&lt; x &lt;&lt;“,”&lt;&lt; y &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1, a2;</span><br><span class="line">    m = <span class="number">20</span>;</span><br><span class="line">    n = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">Setxy</span>(<span class="number">2.0</span>, <span class="number">5.0</span>); <span class="comment">//不能直接调用</span></span><br><span class="line">    <span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间类-1">时间类</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Time time1;            <span class="comment">//声明对象time1</span></span><br><span class="line">    time1.<span class="built_in">SetTime</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);  <span class="comment">//通过对象time1访问公有成员函数</span></span><br><span class="line">    time1.<span class="built_in">ShowTime</span>();      <span class="comment">//通过对象time1访问公有成员函数</span></span><br><span class="line">    Time time2;            <span class="comment">//声明对象time2</span></span><br><span class="line">    time2.<span class="built_in">SetTime</span>(<span class="number">8</span>,<span class="number">30</span>,<span class="number">5</span>); <span class="comment">//通过对象time2访问公有成员函数</span></span><br><span class="line">    time2.<span class="built_in">ShowTime</span>();      <span class="comment">//通过对象time2访问公有成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0:0:0</span><br><span class="line">8:30:5</span><br></pre></td></tr></table></figure>
<p>在主函数的末尾加上一句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;<span class="built_in">sizeof</span>(time1)&lt;&lt;endl&lt;&lt;<span class="built_in">sizeof</span>(time2);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:0:0</span><br><span class="line">8:30:5</span><br><span class="line">12</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<p>由此说明，各对象空间中<strong>只有数据成员</strong>，<strong>而无成员函数</strong>的空间。成员函数只存储一份，由对象共享。</p>
<h2 id="测试-1">测试</h2>
<p>找出程序中的错误，并改正。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_time</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show_time</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="type">int</span> hour;</span><br><span class="line">    <span class="type">int</span> minute;</span><br><span class="line">    <span class="type">int</span> sec;  		                     </span><br><span class="line">&#125;;</span><br><span class="line">Time t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set_time</span>();</span><br><span class="line">    <span class="built_in">show_time</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_time</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;   cin&gt;&gt;t.hour;</span><br><span class="line">    cin&gt;&gt;t.minute;</span><br><span class="line">    cin&gt;&gt;t.sec;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_time</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout&lt;&lt;t.hour&lt;&lt;“:”&lt;&lt;t.minute&lt;&lt;“:”&lt;&lt;t.sec&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用类和对象">使用类和对象</h1>
<h2 id="构造函数和析构函数">构造函数和析构函数</h2>
<p>当没有给数据成员赋值时，其运行结果是随机数。</p>
<p>不少难以察觉的程序错误是由于变量没有被正确初始化或清除造成的，而初始化和清除工作很容易被人遗忘。</p>
<p>C++语言充分考虑了这个问题并很好地予以解决：<strong>把对象的初始化工作放在构造函数中，把清除工作放在析构函数中</strong>。</p>
<p>当对象被创建时，构造函数被自动执行，当对象消亡前，析构函数被自动执行。</p>
<h3 id="构造函数">构造函数</h3>
<p>构造函数的功能是在定义对象时被编译系统自动调用来创建对象并初始化对象。</p>
<p>其定义格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;类名&gt;::&lt;类名&gt;(&lt;参数表&gt;)</span><br><span class="line">&#123;</span><br><span class="line">　　&lt;函数体&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数名<strong>与类名相同</strong>；<strong>没有</strong>函数值类型</p>
<h3 id="无参构造函数">无参构造函数</h3>
<p>之前的例子都没有定义构造函数，那么它们的对象是怎么创建的呢???</p>
<h4 id="默认的无参构造函数">默认的无参构造函数</h4>
<p>事实上，如果在类中没有显式定义构造函数，那么编译系统就会<strong>自动生成一个默认形式的构造函数</strong>，这个构造函数的功能仅用于创建对象。其格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类名&gt;::&lt;类名&gt;()&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>默认的构造函数并不对所产生对象的数据成员赋初值；即新产生对象的数据成员的值是不确定的。</strong></p>
<p>在定义类时，<strong>只要显式定义了一个类的构造函数，则编译器就不产生默认的构造函数</strong></p>
<p><strong>不存在没有构造函数的对象！</strong></p>
<h4 id="带参数的构造函数">带参数的构造函数</h4>
<p>一般格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;构造函数名&gt;（&lt;类型1&gt; &lt;形参1&gt;，&lt;类型2&gt; &lt;形参2&gt;，…）；</span><br></pre></td></tr></table></figure>
<p>则定义对象的格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类名&gt; &lt;对象名&gt;（&lt;实参1&gt;，&lt;实参2&gt;，…）；</span><br></pre></td></tr></table></figure>
<p>将无参构造函数Time()与SetTime(…)合二为一，形成带参构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Time</span>(<span class="type">int</span> NewH, <span class="type">int</span> NewM, <span class="type">int</span> NewS);      </span><br><span class="line"><span class="comment">//带参构造函数的声明</span></span><br><span class="line">Time::<span class="built_in">Time</span>(<span class="type">int</span> NewH, <span class="type">int</span> NewM, <span class="type">int</span> NewS)     <span class="comment">//带参构造函数的实现</span></span><br><span class="line">&#123;</span><br><span class="line">	Hour=NewH;</span><br><span class="line">	Minute=NewM;</span><br><span class="line">	Second=NewS;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;构造函数被调用！&quot;</span>&lt;&lt;endl; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="类的数据成员的初始化">类的数据成员的初始化</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Box::<span class="built_in">Box</span>(<span class="type">int</span> h,<span class="type">int</span> w,<span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">   height=h;</span><br><span class="line">   width=w;<span class="comment">//数据成员在构造函数体内被初始化</span></span><br><span class="line">   legth=len;</span><br><span class="line">&#125;</span><br><span class="line">Box::<span class="built_in">Box</span>(<span class="type">int</span> h,<span class="type">int</span> w,<span class="type">int</span> len)</span><br><span class="line">:<span class="built_in">height</span>(h),<span class="built_in">width</span>(w),<span class="built_in">length</span>(len)<span class="comment">//构造函数成员（参数）初始化表</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="带默认参数的构造函数">带默认参数的构造函数</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Box</span>(<span class="type">int</span> w=<span class="number">10</span>,<span class="type">int</span> h=<span class="number">10</span>,<span class="type">int</span> len=<span class="number">10</span>); </span><br><span class="line">Box::<span class="built_in">Box</span>(<span class="type">int</span> w,<span class="type">int</span> h,<span class="type">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    height=h;</span><br><span class="line">    width=w;</span><br><span class="line">    length=len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在声明构造函数时，形参名可以省略</p>
<p>带默认参数的构造函数和重载构造函数同时使用时，要注意二义性问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a=<span class="number">3</span>,<span class="type">int</span> b=<span class="number">2</span>)&#123;x=a;	y=b;	&#125;</span><br><span class="line">    <span class="built_in">A</span>( )&#123; x=<span class="number">0</span>; y=<span class="number">0</span>; &#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">( )</span></span>&#123;	cout&lt;&lt;x&lt;&lt;“,”&lt;&lt;y&lt;&lt;endl;&#125;</span><br><span class="line"><span class="keyword">private</span>：<span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;	<span class="function">A  <span class="title">a2</span><span class="params">(<span class="number">7</span>,<span class="number">5</span>)</span></span>; </span><br><span class="line">    A  a1;<span class="comment">//两个构造函数均可供调用，构造函数不唯一，编译错误</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数的特点">构造函数的特点</h3>
<ol type="1">
<li>构造函数是成员函数，函数体可写在类中，也可写在类外。</li>
<li>构造函数的名字<strong>必须</strong>与类名同名，而不能由用户任意命名。</li>
<li>构造函数<strong>不能</strong>指定函数值类型，甚至void也不行。</li>
<li>构造函数可以没有参数，也可以有参数，允许重载，即可以定义参数不同的多个构造函数。</li>
<li>每个类都必须有一个构造函数，且是公有成员。如果用户自己没有定义构造函数，则C++系统会自动生成一个构造函数，只是这个构造函数没有参数，函数体也是空的，不执行初始化操作。</li>
<li>在定义类对象时，构造函数由系统自动调用，而不是像其他成员函数一样，由用户显式调用。</li>
</ol>
<h3 id="析构函数">析构函数</h3>
<p>析构函数的功能是在对象的生存期即将结束的时刻，由编译系统自动调用来完成一些<strong>清理</strong>工作。</p>
<p>析构函数也是类的一个公有成员函数，它的名称是由类名前面加“~”构成，也<strong>不指定返回值类型</strong>。</p>
<p>其定义格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;类名&gt;::~&lt;类名&gt;()</span><br><span class="line">&#123;</span><br><span class="line">　　&lt;函数体&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">Box</span>();        <span class="comment">//析构函数的声明</span></span><br><span class="line">Box::~<span class="built_in">Box</span>()  <span class="comment">//析构函数的实现</span></span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;“This is destructor!”&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有定义析构函数，同构造函数一样，编译系统会提供默认形式的析构函数：</p>
<p><类名>::~<类名>(){}</p>
<h3 id="析构函数的特点">析构函数的特点</h3>
<p>析构函数是成员函数，函数体可写在类体内，也可以写在类体外。</p>
<p>析构函数的<strong>函数名与类名相同</strong>，并在前面加“~”字符，用来与构造函数加以区别。析构函数<strong>不指定返回值类型</strong>。</p>
<p>析构函数<strong>没有参数</strong>，因此<strong>不能重载</strong>。一个类中只能定义一个析构函数。</p>
<p>每个类都<strong>必须有一个</strong>析构函数。如果类中没有显式定义析构函数，则编译系统自动生成一个<strong>默认</strong>形式的析构函数，作为该类的公有成员。</p>
<p>析构函数在对象生存期结束前由编译系统自动调用。</p>
<h3 id="构造函数和析构函数的调用顺序">构造函数和析构函数的调用顺序</h3>
<p>在一般情况下，调用构造函数与声明对象的顺序相同，而调用析构函数的次序正好与创建对象的顺序相反。</p>
<p><img data-src="image-20201206215738802.png" alt="image-20201206215738802" style="zoom:50%;" /></p>
<p>### 构造函数析构函数的调用时机</p>
<p><strong>全局对象</strong>的构造函数在文件中的所有函数（包括main函数）执行之前调用。当main函数执行完毕或调用exit函数时，调用析构函数。</p>
<p><strong>局部自动对象</strong>在建立对象时调用构造函数。在函数调用结束、对象释放时先调用析构函数。</p>
<p>函数中的<strong>静态局部对象</strong>，在第一次调用此函数建立对象时调用一次构造函数，在调用结束时对象并不释放，因此也不调用析构函数， 只在main函数执行完毕或调用exit函数时，调用析构函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fn</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Student stud1;<span class="comment">//定义自动局部对象</span></span><br><span class="line"><span class="type">static</span> Student stud2;<span class="comment">//定义静态局部对象</span></span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数调用顺序为：stud1的构造函数，stud2的构造函数，stud1的析构函数，stud2的析构函数。</p>
<h3 id="复制拷贝构造函数">复制（拷贝）构造函数</h3>
<p>生成一个对象的副本有两种途径：对象的赋值和复制。</p>
<p><strong>对象的赋值</strong>（同类对象）</p>
<p><对象1> = <对象2>;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Setxy</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; m &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1, a2;</span><br><span class="line">    a1.m = <span class="number">10</span>;</span><br><span class="line">    a1.n = <span class="number">20</span>; <span class="comment">//为公有成员数据赋值</span></span><br><span class="line">    a1.<span class="built_in">Setxy</span>(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    a2 = a1; <span class="comment">//同类型的对象之间可以整体赋值，与对象中成员的访问权限无关</span></span><br><span class="line">    a1.<span class="built_in">Print</span>();</span><br><span class="line">    a2.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2,5</span><br><span class="line">10,20</span><br><span class="line">2,5</span><br><span class="line">10,20</span><br></pre></td></tr></table></figure>
<p>相当于数据成员间相互赋值</p>
<p><strong>对象的复制</strong></p>
<p><类名> <对象2>(<对象1>); <类名> <对象2>=<对象1>;</p>
<p>对象赋值与对象复制的不同</p>
<ul>
<li>对象的赋值是对一个已经存在的对象赋值，因此必须先定义被赋值的对象，才能进行赋值。</li>
<li>对象的复制是从无到有地建立一个新对象，并使它与一个已有的对象完全相同。</li>
<li>用一个类对象初始化该类的另一个对象被称为<strong>默认按成员初始化</strong>。</li>
<li>类的设计者也可以通过提供特殊的<strong>复制构造函数</strong>（copy constructor）来改变默认的行为。</li>
<li>复制构造函数是一种特殊的构造函数，它的功能是<strong>用一个已知的对象</strong>来<strong>初始化</strong>一个被定义的<strong>同类的对象</strong>。</li>
</ul>
<p>复制构造函数的定义格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class &lt;类名&gt;</span><br><span class="line">&#123;</span><br><span class="line">public：</span><br><span class="line">    &lt;类名&gt;(&lt;参数表&gt;);　          　　//构造函数</span><br><span class="line">    &lt;类名&gt;(const &lt;类名&gt;&amp; &lt;对象名&gt;);  //复制构造函数的声明</span><br><span class="line">…</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;类名&gt;::&lt;类名&gt;(const &lt;类名&gt;&amp; &lt;对象名&gt;)</span><br><span class="line">                                //复制构造函数的实现</span><br><span class="line">&#123;</span><br><span class="line">    &lt;函数体&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果程序员没有显式定义复制构造函数，编译系统就会自动生成一个默认形式的复制构造函数</p>
<p>其功能是创建新对象把已知对象的每个数据成员的值都复制到新创建的对象中，而不做其他处理。其格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;类名&gt;::&lt;类名&gt;( const &lt;类名&gt;&amp; &lt;对象名&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    …  //把已知对象的每个数据成员的值都</span><br><span class="line">        //复制到新创建的对象中，而不做其他处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三种构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Box();            //无参构造函数</span><br><span class="line">Box(int h,int w ,int len):height(h),width(w),length(len)&#123;&#125;//带参构造函数</span><br><span class="line">Box(const Box&amp; b);//复制构造函数</span><br></pre></td></tr></table></figure>
<h3 id="复制构造函数与普通构造函数的区别">复制构造函数与普通构造函数的区别</h3>
<p>形式上不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;类名&gt;(&lt;参数表&gt;);　          　　</span><br><span class="line">&lt;类名&gt;(const &lt;类名&gt;&amp; &lt;对象名&gt;);</span><br></pre></td></tr></table></figure>
<p>在建立对象时，实参类型不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box box1(15,30,25);//实参为整数</span><br><span class="line">Box box2(box1);//实参是对象名</span><br></pre></td></tr></table></figure>
<p>被调用的情况不同</p>
<ul>
<li>普通构造函数在程序中创建对象时被调用</li>
<li>复制构造函数在用已有对象复制一个新对象时被调用，在以下3种情况下需要复制对象</li>
</ul>
<p>程序中需要新建立一个对象，并用另一个同类的对象对它初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Box <span class="title">box1</span><span class="params">(<span class="number">15</span>,<span class="number">30</span>,<span class="number">25</span>)</span></span>;</span><br><span class="line">Box box2=box1;或<span class="function">Box <span class="title">box2</span><span class="params">(box1)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当函数的参数为类对象时，在调用函数时需要将实参对象完整地传递给形参：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Box b)</span> <span class="comment">//形参是类的对象</span></span></span><br><span class="line"><span class="function"></span>&#123; … &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Box <span class="title">box1</span><span class="params">(<span class="number">12</span>,<span class="number">15</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">    <span class="built_in">fun</span>(box1);           </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当函数的返回值是类的对象，在函数调用完毕将返回值带回函数调用处时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Box <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="function">Box <span class="title">box1</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> box1; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Box box2;</span><br><span class="line">    box2=<span class="built_in">f</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复制构造函数的特点">复制构造函数的特点</h3>
<p>复制构造函数是成员函数，函数体可写在类中，也可以写在类外。</p>
<p>复制构造函数名与类名相同，并且也不指定函数值类型。</p>
<p>复制构造函数<strong>只有一个参数</strong>，并且<strong>是对同类对象的引用</strong>。</p>
<p>每个类都必须有一个复制构造函数。如果类中没有显式定义复制构造函数，则编译系统自动生成一个默认形式的复制构造函数，作为该类的公有成员。</p>
<h2 id="对象间的数据共享">对象间的数据共享</h2>
<p>静态成员是C++提供的解决同一个类的不同对象之间数据和函数共享问题的机制。</p>
<p>类的静态成员分为静态数据成员和静态成员函数。</p>
<h3 id="类的非静态数据成员">类的非静态数据成员</h3>
<p>一个类的所有对象具有相同的属性是指属性的个数、名称、数据类型相同，各个对象的属性值则可以各不相同。</p>
<p>这样的属性在面向对象方法中称为“<strong>实例属性</strong>”，在C++程序中以类的<strong>非静态数据成员</strong>表示。</p>
<h3 id="类的静态数据成员">类的静态数据成员</h3>
<p>面向对象方法中还有“<strong>类属性</strong>”的概念。如果某个属性为整个类所共有，不属于任何一个具体对象，则采用static关键字来声明为<strong>静态成员</strong>。</p>
<p><strong>静态成员</strong>是类的所有对象共享的成员，而不是某个对象的成员，它<strong>在对象中不占存储空间</strong>，是<strong>属于整个类的成员</strong>。</p>
<p>静态数据成员不随对象的建立而分配空间，也不随对象的撤销而释放。它是在程序编译时分配空间，到程序结束时才释放空间。</p>
<h3 id="静态成员的定义">静态成员的定义</h3>
<p>定义格式如下：</p>
<p>static　<静态成员的定义>;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123; </span><br><span class="line">    <span class="type">int</span> x,y;  </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Setxy</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;x=a; y=b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">A a1, a2;</span><br></pre></td></tr></table></figure>
<h3 id="静态数据成员">静态数据成员</h3>
<p>静态数据成员是在所有对象之外单独开辟空间。</p>
<p>只要在类中定义了静态数据成员，即使不定义对象，也为静态数据成员分配空间，它可以被访问。</p>
<p>在一个类中可以有一个或多个静态数据成员，所有的对象共享这些静态数据成员，都可以访问它。</p>
<h3 id="静态数据成员的初始化">静态数据成员的初始化</h3>
<p><strong>不能</strong>用参数初始化表对静态数据成员初始化，<strong>也不能</strong>在构造函数体内初始化，静态数据成员<strong>只能</strong>在<strong>类体外</strong>进行初始化。</p>
<p>静态数据成员初始化格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;数据类型&gt; &lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;;</span><br></pre></td></tr></table></figure>
<p>不能在初始化语句中加static</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x, y; <span class="comment">//定义静态成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a = <span class="number">0</span>, <span class="type">int</span> b = <span class="number">0</span>, <span class="type">int</span> c = <span class="number">0</span>, <span class="type">int</span> d = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i = a;</span><br><span class="line">        j = b;</span><br><span class="line">        x = c;</span><br><span class="line">        y = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i =&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;j=&quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;y=&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> A::x = <span class="number">0</span>; <span class="comment">//给静态数据成员分配空间和初始化</span></span><br><span class="line"><span class="type">int</span> A::y = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">Show</span>();</span><br><span class="line">    <span class="function">A <span class="title">b</span><span class="params">(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>, <span class="number">400</span>)</span></span>;</span><br><span class="line">    b.<span class="built_in">Show</span>();</span><br><span class="line">    a.<span class="built_in">Show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i=2,j=3,x=4,y=5</span><br><span class="line">i=100,j=200,x=300,y=400</span><br><span class="line">i=2,j=3,x=300,y=400</span><br></pre></td></tr></table></figure>
<h3 id="静态数据成员的使用">静态数据成员的使用</h3>
<p>在类的成员函数中可以<strong>直接</strong>访问该类的静态数据成员，而不必使用成员访问运算符或作用域运算符。</p>
<p>在类外<strong>必须</strong>使用成员访问运算符或作用域运算符访问<strong>公有</strong>静态数据成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;对象名&gt;.&lt;静态数据成员&gt;</span><br><span class="line">&lt;类名&gt;::&lt;静态数据成员&gt;</span><br></pre></td></tr></table></figure>
<p>静态数据成员与全局变量一样都是静态分配存储空间的，<strong>但全局变量在程序中的任何位置都可以访问它，而静态数据成员受到访问权限的约束。必须是public权限时，才可能在类外进行访问。</strong></p>
<p>公有静态数据成员的作用域只限于定义该类的作用域内。在此作用域内，可以通过类名和作用域运算符访问静态数据成员，而不论类对象是否存在。</p>
<h3 id="静态成员函数">静态成员函数</h3>
<p>静态成员函数就是使用<strong>static</strong>关键字声明的成员函数。</p>
<p>和静态数据成员一样，静态成员函数是类的一部分，而不是对象的一部分。</p>
<p>静态成员函数的作用是为了能处理静态数据成员。</p>
<p>静态成员函数没有this 指针。</p>
<p>静态成员函数可以<strong>直接访问</strong>该类的静态成员，但<strong>不能直接访问</strong>类中的<strong>非</strong>静态成员。</p>
<p>如果静态成员函数中要使用非静态成员时，必须通过参数传递方式得到对象名，然后可以通过对象名来访问非静态成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> b; <span class="comment">//静态数据成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Tc</span>(<span class="type">int</span> c)</span><br><span class="line">    &#123;</span><br><span class="line">        a = c;</span><br><span class="line">        b += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">display</span><span class="params">(Tc C)</span> <span class="comment">//Tc的对象为形参</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; C.a &lt;&lt; <span class="string">&quot;,b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="comment">// C.a非静态成员，用对象名来引用，b静态成员，直接引用</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Tc::b = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Tc <span class="title">A</span><span class="params">(<span class="number">2</span>)</span>, <span class="title">B</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    Tc::<span class="built_in">display</span>(A);<span class="comment">//直接用类名来调用静态成员函数</span></span><br><span class="line">    Tc::<span class="built_in">display</span>(B);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=2,b=8</span><br><span class="line">a=4,b=8</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> b; <span class="comment">//静态数据成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Tc</span>(<span class="type">int</span> c)</span><br><span class="line">    &#123;</span><br><span class="line">        a = c;</span><br><span class="line">        b += c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">display</span><span class="params">(Tc C)</span></span>; <span class="comment">//Tc的对象为形参</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Tc::display</span><span class="params">(Tc C)</span> <span class="comment">//不用static修饰</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; C.a &lt;&lt; <span class="string">&quot;,b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Tc::b = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Tc <span class="title">A</span><span class="params">(<span class="number">2</span>)</span>, <span class="title">B</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    Tc::<span class="built_in">display</span>(A);</span><br><span class="line">    Tc::<span class="built_in">display</span>(B);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象指针">对象指针</h2>
<p>与基本数据类型的变量一样，每一个对象在创建之后都会在内存中占有一定的空间。</p>
<p>因此，既可以通过对象名访问对象，也可以通过对象的起始地址来访问一个对象，即对象指针。</p>
<p>对象指针就是用于存放对象数据起始地址的变量。</p>
<p>声明对象指针的一般格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类名&gt;  *&lt;对象指针名&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="对象指针的初始化">对象指针的初始化</h3>
<p>一般格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;类名&gt; *&lt;对象指针名&gt;=&amp;&lt;对象名&gt;;</span><br><span class="line">&lt;对象指针名&gt;=&amp;&lt;对象名&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="通过指针访问对象成员">通过指针访问对象成员</h3>
<p>一般格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;对象指针名&gt; -&gt; &lt;公有成员&gt; </span><br><span class="line">boxp-&gt;volumn();</span><br><span class="line">(*&lt;对象指针名&gt;).&lt;公有成员&gt;</span><br><span class="line">(*boxp).volumn();</span><br></pre></td></tr></table></figure>
<p>通过对象指针访问学生类的成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Student s1;                    <span class="comment">//定义Student类的对象s1</span></span><br><span class="line">s1.<span class="built_in">input</span>(<span class="number">1</span>, <span class="string">&quot;Zhang Hua&quot;</span>, <span class="number">95</span>);  <span class="comment">//通过s1访问公有成员函数</span></span><br><span class="line">s1.<span class="built_in">display</span>();                  <span class="comment">//通过对象访问公有成员函数</span></span><br><span class="line">Student *pstu = &amp;s1;           <span class="comment">//定义Student类的对象指针pstu,并指向对象s1</span></span><br><span class="line">pstu-&gt;<span class="built_in">input</span>(<span class="number">2</span>, <span class="string">&quot;Wang Li&quot;</span>, <span class="number">90</span>); <span class="comment">//通过指针访问公有成员函数</span></span><br><span class="line">pstu-&gt;<span class="built_in">display</span>();               <span class="comment">//通过指针访问公有成员函数</span></span><br><span class="line">(*pstu).<span class="built_in">modify</span>(<span class="number">85</span>);</span><br><span class="line">(*pstu).<span class="built_in">display</span>();</span><br></pre></td></tr></table></figure>
<h3 id="动态对象">动态对象</h3>
<p>用new运算符创建动态对象的一般格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new &lt;类名&gt;;</span><br><span class="line">new &lt;类名&gt;(&lt;初值列表&gt;);</span><br></pre></td></tr></table></figure>
<p>用delete运算符删除new建立的对象，释放指针所指向的内存空间。使用格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete &lt;指向对象的指针变量名&gt;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Box *pbox1 = new Box; //定义指向Box对象的指针变量pbox1</span><br><span class="line">    cout &lt;&lt; &quot;The volume of box1 is &quot; &lt;&lt; pbox1-&gt;volume() &lt;&lt; endl;</span><br><span class="line">    delete pbox1;                     //释放pbox1指向的对象空间</span><br><span class="line">    Box *pbox2 = new Box(15, 30, 25); //定义指向Box对象的指针变量pbox2，</span><br><span class="line">                                      //在pbox2中存放对象的起始地址并初始化对象</span><br><span class="line">    cout &lt;&lt; &quot;The volume of box2 is &quot; &lt;&lt; pbox2-&gt;volume() &lt;&lt; endl;</span><br><span class="line">    //指针访问成员</span><br><span class="line">    delete pbox2; //释放pbox2指向的对象空间</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="this指针">this指针</h3>
<p>this指针是一个特殊的<strong>隐含</strong>指针，它隐含于每一个成员函数（静态成员函数除外）中，也就是说，<strong>每个成员函数都有一个this指针参数</strong>。</p>
<p>this指针指向调用该函数的对象，即this指针的值是<strong>当前被调用的成员函数所在的对象的起始地址</strong>。</p>
<p>当一个对象调用成员函数时，编译系统先将<strong>对象的地址赋给this指针</strong>，然后调用成员函数，每次成员函数存取数据成员时，则隐含使用this指针。</p>
<p>通常不显式地使用this指针来调用数据成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Box <span class="title">a</span><span class="params">(<span class="number">15</span>, <span class="number">18</span>, <span class="number">20</span>)</span>, <span class="title">b</span><span class="params">(<span class="number">16</span>, <span class="number">20</span>, <span class="number">26</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;volume of a is &quot;</span> &lt;&lt; a.<span class="built_in">volume</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;volume of b is &quot;</span> &lt;&lt; b.<span class="built_in">volume</span>() &lt;&lt; endl;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Box::volume</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (height * width * length);<span class="comment">//隐含使用this指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Box::volume</span><span class="params">(Box *<span class="keyword">this</span>)</span><span class="comment">//在实际编程时，函数的声明中并没有包含这个参数。编译器会把该对象的地址加入到参数列表中。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;height) * (<span class="keyword">this</span>-&gt;width) * (<span class="keyword">this</span>-&gt;length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制构造函数中隐含使用this指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TAdd</span>(<span class="type">const</span> TAdd&amp; p) </span><br><span class="line">&#123;  <span class="comment">/* this-&gt;*/</span>x=p.x; <span class="comment">/*this-&gt;*/</span>y=p.y;</span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;copy constructor.&quot;</span>&lt;&lt;endl;&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数中显式使用this指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TAdd</span>(<span class="type">int</span> x,<span class="type">int</span> y) </span><br><span class="line">&#123;   <span class="keyword">this</span>-&gt;x=x; <span class="keyword">this</span>-&gt;y=y;</span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;constructor.&quot;</span>&lt;&lt;endl;&#125;</span><br></pre></td></tr></table></figure>
<p>this指针一般用于返回当前对象自身。</p>
<p>同样也可以使用*<strong>this</strong>来标识调用该成员函数的当前对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x	this-&gt;x	(*this).x</span><br></pre></td></tr></table></figure>
<p>this指针是一个const指针，成员函数不能对其进行赋值。</p>
<p>静态成员中不能访问this指针，因为静态成员函数不从属于任何对象。</p>
<p>this指针的另一种用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void Student::copy_stud(const Student &amp; stu)</span><br><span class="line">&#123;</span><br><span class="line">   if(this!=&amp;stu) //this指针中含有被调用的类对象的地址</span><br><span class="line">&#123;…         //把stu的值复制到*this中</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###　成员指针</p>
<p>类的成员可能是一些变量、函数或者对象等，因此可以将它们的地址存放到一个指针变量中。这样，就可以使指针直接指向对象的成员，进而可以通过这些指针访问对象的成员。</p>
<p>这样的指针称为<strong>成员指针</strong>，或者说是指向对象的成员的指针变量。</p>
<h3 id="指向非静态数据成员的指针">指向非静态数据成员的指针</h3>
<p>定义指向对象数据成员的指针变量的方法和定义指向普通变量的指针变量方法相同。</p>
<p>一般形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型名  *指针变量名； </span><br></pre></td></tr></table></figure>
<h3 id="指向非静态成员函数的指针">指向非静态成员函数的指针</h3>
<p>定义指向公有成员函数的指针变量的一般形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型名 (类名:: *指针变量名)(参数列表)； </span><br></pre></td></tr></table></figure>
<p>使指针变量指向一个公有成员函数的一般形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指针变量名=&amp;类名::成员函数名 //&amp;可省略</span><br></pre></td></tr></table></figure>
<p>通过成员函数指针、对象指针、对象访问公有成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> xx=<span class="number">0</span>,<span class="type">int</span> yy=<span class="number">0</span>)</span><br><span class="line">     &#123; X=xx; Y=yy; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> X;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetY</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> Y;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> X,Y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Point <span class="title">A</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>)</span></span>;<span class="comment">//声明对象A</span></span><br><span class="line">Point *p1=&amp;A;</span><br><span class="line">      <span class="comment">//声明对象指针并初始化</span></span><br><span class="line"><span class="built_in">int</span> (Point::*pGetX)()= Point::GetX;</span><br><span class="line">      <span class="comment">//声明成员函数指针并初始化</span></span><br><span class="line">cout&lt;&lt;(A.*pGetX)()&lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">      <span class="comment">//使用成员函数指针访问成员函数</span></span><br><span class="line">cout&lt;&lt;(p1-&gt;GetX)()&lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">      <span class="comment">//使用对象指针访问成员函数</span></span><br><span class="line">cout&lt;&lt;A.<span class="built_in">GetX</span>()&lt;&lt;endl;</span><br><span class="line">      <span class="comment">//使用对象名访问成员函数</span></span><br></pre></td></tr></table></figure>
<h3 id="指向类的静态成员的指针">指向类的静态成员的指针</h3>
<p>对类的静态成员的访问是不依赖于对象的，因此可以用普通的指针来指向和访问静态成员。</p>
<p>【例】通过指针访问类的静态数据成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> xx = <span class="number">0</span>, <span class="type">int</span> yy = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        X = xx;</span><br><span class="line">        Y = yy;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;                      <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">const</span> Point &amp;p); <span class="comment">//复制构造函数的声明</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> X; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Y; &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count; <span class="comment">//静态数据成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> X, Y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Point::count = <span class="number">0</span>; <span class="comment">//静态数据成员的初始化</span></span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">const</span> Point &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    X = p.X;</span><br><span class="line">    Y = p.Y;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *countp = &amp;Point::count;</span><br><span class="line">    <span class="comment">//声明一个int型指针，指向类的//静态成员</span></span><br><span class="line">    <span class="function">Point <span class="title">A</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Point A: &quot;</span> &lt;&lt; A.<span class="built_in">GetX</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; A.<span class="built_in">GetY</span>();</span><br><span class="line">    <span class="comment">//通过对象访问成员函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; Object id= &quot;</span> &lt;&lt; *countp &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//通过指针访问静态数据成员</span></span><br><span class="line">    <span class="function">Point <span class="title">B</span><span class="params">(A)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Point B: &quot;</span> &lt;&lt; B.<span class="built_in">GetX</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; B.<span class="built_in">GetY</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; Object id= &quot;</span> &lt;&lt; *countp &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point A：4,5 Object id=1</span><br><span class="line">Point B：4,5 Object id=2</span><br></pre></td></tr></table></figure>
<p>【例】定义函数指针访问类的静态成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> xx = <span class="number">0</span>, <span class="type">int</span> yy = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        X = xx;</span><br><span class="line">        Y = yy;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;                      <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">const</span> Point &amp;p); <span class="comment">//复制构造函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> X; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Y; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GetC</span><span class="params">()</span> <span class="comment">//静态成员函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Object id=&quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> X, Y;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count; <span class="comment">//静态数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line">Point::<span class="built_in">Point</span>(<span class="type">const</span> Point &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    X = p.X;</span><br><span class="line">    Y = p.Y;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Point::count = <span class="number">0</span>; <span class="comment">//静态数据成员  //的初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*gc)() = Point::GetC;</span><br><span class="line">    <span class="comment">//声明一个指向函数的指针，指向类的 //静态成员函数</span></span><br><span class="line">    <span class="function">Point <span class="title">A</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>)</span></span>; <span class="comment">//声明对象A</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Point A: &quot;</span> &lt;&lt; A.<span class="built_in">GetX</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; A.<span class="built_in">GetY</span>();</span><br><span class="line">    (*gc)();    <span class="comment">//通过指针访问静态成员函数</span></span><br><span class="line">    <span class="function">Point <span class="title">B</span><span class="params">(A)</span></span>; <span class="comment">//声明对象B</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Point B: &quot;</span> &lt;&lt; B.<span class="built_in">GetX</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; B.<span class="built_in">GetY</span>();</span><br><span class="line">    <span class="built_in">gc</span>(); <span class="comment">//通过指针访问静态成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象引用">对象引用</h3>
<p>引用（Reference）是某个变量（对象）的别名（alias）。</p>
<p>指针通过地址间接访问对象，而引用是直接访问对象。</p>
<p>【例】示例对象的引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Time myTime;</span><br><span class="line">Time &amp;refTime=myTime; <span class="comment">//声明引用时必须初始化为一个对象</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;First Time set and output:&quot;</span>&lt;&lt;endl;</span><br><span class="line">refTime.<span class="built_in">SetTime</span>(<span class="number">12</span>,<span class="number">0</span>,<span class="number">0</span>); </span><br><span class="line">refTime.<span class="built_in">ShowTime</span>(); </span><br><span class="line">myTime.<span class="built_in">ShowTime</span>();</span><br></pre></td></tr></table></figure>
<p>如果实参是对象，那么“通过值来传递一个对象”的具体含义是由这个对象的复制构造函数定义的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Student <span class="title">returnS</span><span class="params">(Student s)</span></span>&#123;<span class="keyword">return</span> s;&#125;</span><br><span class="line">Student stu1;</span><br><span class="line">stu1.<span class="built_in">returnS</span>(stu1);</span><br></pre></td></tr></table></figure>
<p>避免通过值来传递对象，而是通过引用来传递。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Student&amp; <span class="title">returnS</span><span class="params">(Student&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> s;&#125;</span><br></pre></td></tr></table></figure>
<p>参数传递的是引用，没有构造函数或析构函数被调用，节约了系统资源，提高了运行效率。</p>
<h2 id="共享数据的保护">共享数据的保护</h2>
<p>常量定义格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &lt;数据类型名&gt; &lt;常量名&gt;=&lt;表达式&gt;;</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const float PI;			</span><br><span class="line">PI=3.1415926;　　　　　//错误,常量在程序运行过程中不允许改变，因此在定义时必须初始化。</span><br></pre></td></tr></table></figure>
<h3 id="常对象">常对象</h3>
<p>常对象是其<strong>数据成员值</strong>在对象的整个生存期间内<strong>不能被改变</strong>的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const  &lt;类名&gt;　&lt;对象名&gt;(&lt;初始化值&gt;);</span><br><span class="line"></span><br><span class="line">&lt;类名&gt; const &lt;对象名&gt;(&lt;初始化值&gt;);</span><br></pre></td></tr></table></figure>
<p>常对象的所有数据成员都是常量，不能改变。因此，常对象必须初始化。</p>
<p><strong>不能</strong>通过常对象调用普通的成员函数，可以调用常成员函数。</p>
<p>如果要修改常对象中某个数据成员的值，可以将数据成员声明为<strong>mutable</strong>，这样就可以用声明为const的成员函数来修改它的值。</p>
<h3 id="类的常成员">类的常成员</h3>
<p>类的数据成员和成员函数可以声明为const，分别为常数据成员和常成员函数。</p>
<h4 id="常数据成员">常数据成员</h4>
<p>在任何函数中都不能对常数据成员赋值。</p>
<p><strong>只能</strong>通过构造函数的参数初始化表对常数据成员进行初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int Hour;</span><br><span class="line">Time::Time(int h):Hour(h)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>类的所有对象中的常数据成员的值均不能改变，但不同对象中的该数据成员的值可以不同（在定义对象时给出）。</p>
<p>【例】示例常数据成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a;        <span class="comment">//非静态常数据成员</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> b; <span class="comment">//静态常数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> A::b = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//静态常数据成员在类外初始化</span></span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> i) : <span class="built_in">a</span>(i)</span><br><span class="line"><span class="comment">//非静态常数据成员只能通过初始化表来获得初值</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt;”:”&lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">100</span>)</span>, <span class="title">a2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//定义并初始化对象a1和a2</span></span><br><span class="line">    a1.<span class="built_in">print</span>();</span><br><span class="line">    a2.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100:10</span><br><span class="line">0:10</span><br></pre></td></tr></table></figure>
<h4 id="常成员函数">常成员函数</h4>
<p>通过常成员函数来引用本类中的数据成员，但不能修改它们。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;数据类型&gt;&lt;函数名&gt;(&lt;参数表&gt;)const;</span><br></pre></td></tr></table></figure>
<p>const是函数类型的一部分，在声明函数和定义函数时都要有const，在调用时不必加const。</p>
<p>常成员函数<strong>不能更新</strong>对象的数据成员，也<strong>不能调用</strong>该类中的<strong>非const成员函数</strong>。</p>
<p>通过常对象只能调用它的常成员函数，而不能调用其他成员函数。</p>
<p>常对象中的成员函数不是常成员函数，除非成员函数有const修饰。</p>
<p>const关键字可以用于对重载函数的区分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">R</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">R</span>(<span class="type">int</span> r1, <span class="type">int</span> r2)</span><br><span class="line">    &#123;</span><br><span class="line">        R1 = r1;</span><br><span class="line">        R2 = r2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> R1, R2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">R::print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; R1 &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; R2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">R::print</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; R1 &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; R2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">a</span><span class="params">(<span class="number">5</span>, <span class="number">4</span>)</span></span>;         <span class="comment">//声明普通对象a</span></span><br><span class="line">    a.<span class="built_in">print</span>();         <span class="comment">//普通对象a调用普通成员函数</span></span><br><span class="line">    <span class="function"><span class="type">const</span> R <span class="title">b</span><span class="params">(<span class="number">20</span>, <span class="number">52</span>)</span></span>; <span class="comment">//常对象b</span></span><br><span class="line">    b.<span class="built_in">print</span>();         <span class="comment">//常对象b调用常成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5-4</span><br><span class="line">20+52</span><br></pre></td></tr></table></figure>
<h3 id="const成员和非const成员之间的调用关系">const成员和非const成员之间的调用关系</h3>
<table>
<thead>
<tr class="header">
<th>数据成员</th>
<th>非const成员函数</th>
<th>const成员函数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>非const数据成员</td>
<td>可以引用，也可以改变值</td>
<td>可以引用，但不可以改变值</td>
</tr>
<tr class="even">
<td>const数据成员</td>
<td>可以引用，但不可以改变值</td>
<td>可以引用，但不可以改变值</td>
</tr>
<tr class="odd">
<td>const对象的数据成员</td>
<td>不允许引用和改变值</td>
<td>可以引用，但不可以改变值</td>
</tr>
</tbody>
</table>
<h3 id="const与指针">const与指针</h3>
<p>指向对象的<strong>常指针</strong>：指针变量声明为const型并初始化，指针本身的值不能改变，即<strong>其指向不能改变</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 * const 指针变量名=对象地址</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Time <span class="title">t1</span><span class="params">(<span class="number">10</span>,<span class="number">12</span>,<span class="number">15</span>)</span>,t2</span>;</span><br><span class="line">Time *<span class="type">const</span> ptr1=&amp;t1;<span class="comment">//ptr1是指向t1对象的常指针</span></span><br><span class="line">ptr1=&amp;t2;   <span class="comment">//错误，ptr1不能改变指向</span></span><br></pre></td></tr></table></figure>
<p>常指针始终指向同一个对象，但是可以改变其所指对象中数据成员的值 。</p>
<p><strong>指向常对象的指针：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const  类型名 *指针变量名; </span><br></pre></td></tr></table></figure>
<p>如果存在一个常对象，<strong>只能</strong>用指向常对象的指针指向它，而不能用非const型的指针指向它。</p>
<p>指向常对象的指针还可以指向非const型的对象，此时不能通过指针改变该对象的值；但是指针本身的值可以改变。</p>
<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Time <span class="title">t1</span><span class="params">(<span class="number">10</span>,<span class="number">12</span>,<span class="number">15</span>)</span>,t2</span>;</span><br><span class="line"><span class="type">const</span> Time *p=&amp;t1;<span class="comment">//p是指向常对象的指针，//并指向t1对象</span></span><br><span class="line">(*p).hour=<span class="number">18</span>;   <span class="comment">//错误，不能通过指针改变              //t1的值</span></span><br><span class="line">t1.hour=<span class="number">18</span>;<span class="comment">//正确，t1不是常对象</span></span><br><span class="line">p=&amp;t2;<span class="comment">//正确，p改为指向t2</span></span><br></pre></td></tr></table></figure></p>
<p>指向常对象的指针可以指向const和非const型的对象，而指向非const型对象的指针只能指向非const的对象。</p>
<h3 id="常引用">常引用</h3>
<p>如果在声明引用时用const修饰，被声明的引用就是常引用。</p>
<p>常引用所引用的对象不能被更新。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const  &lt;数据类型&gt;　&amp;&lt;引用名&gt;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void fun(const Time &amp;t);</span><br></pre></td></tr></table></figure>
<p>在函数中不能改变t的值，也就是不能改变其对应的实参对象的值。</p>
<h2 id="对象数组">对象数组</h2>
<p>对象数组的元素是对象。声明一维对象数组的一般格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类名&gt; &lt;数组名&gt;[&lt;下标表达式&gt;]</span><br></pre></td></tr></table></figure>
<p>在建立数组时，需要调用构造函数。数组中有多少个元素，就调用多少次构造函数。</p>
<p>在定义数组时可以提供实参以实现初始化。</p>
<p>如果构造函数只有一个参数，在定义数组时可以直接在等号后面的大括号内提供实参。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student stud[3]=&#123;60,70,78&#125;;</span><br></pre></td></tr></table></figure>
<p>如果构造函数有多个参数，在定义对象数组时在大括号中分别写出构造函数并指定实参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Ex</span>(<span class="type">int</span> x=<span class="number">0</span>, <span class="type">char</span> c=‘c’);  <span class="comment">//声明构造函数</span></span><br><span class="line">Ex z[<span class="number">2</span>]=&#123;<span class="built_in">Ex</span>(<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>),<span class="built_in">Ex</span>(<span class="number">1</span>,<span class="string">&#x27;d&#x27;</span>)&#125;; <span class="comment">//对象数组的初始化</span></span><br></pre></td></tr></table></figure>
<p>每个数组元素都是对象，通过该对象，便可以访问到它的公有成员。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;数组名&gt;[&lt;下标&gt;].&lt;成员名&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z[<span class="number">0</span>].<span class="built_in">outdata</span>();</span><br></pre></td></tr></table></figure>
<p>【例】示例对象数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Box</span>(<span class="type">int</span> h = <span class="number">10</span>, <span class="type">int</span> w = <span class="number">12</span>, <span class="type">int</span> len = <span class="number">15</span>) ：<span class="built_in">height</span>(h), <span class="built_in">width</span>(w), <span class="built_in">length</span>(len) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">volume</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Box::volume</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> height * width * length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Box a[<span class="number">2</span>] = &#123;<span class="built_in">Box</span>(<span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>), <span class="built_in">Box</span>(<span class="number">15</span>, <span class="number">18</span>, <span class="number">20</span>)&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;volume of a[0] is：&quot;</span> &lt;&lt; a[<span class="number">0</span>].<span class="built_in">volume</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;volume of a[1] is：&quot;</span> &lt;&lt; a[<span class="number">1</span>].<span class="built_in">volume</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【例】示例动态对象数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CPoint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CPoint</span>(<span class="type">int</span> x0, <span class="type">int</span> y0 = <span class="number">0</span>) <span class="comment">//带默认参数的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = x0;</span><br><span class="line">        y = y0;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;constructor1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CPoint</span>() <span class="comment">//无参数构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;constructor2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">(<span class="type">int</span> x0 = <span class="number">0</span>, <span class="type">int</span> y0 = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = x0;</span><br><span class="line">        y = y0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; x &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; y &lt;&lt; endl; &#125; <span class="comment">//输出私有数据成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CPoint *ptr = <span class="keyword">new</span> CPoint[<span class="number">5</span>];</span><br><span class="line">    <span class="comment">//为对象数组动态申请内存单元</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">if</span> (!ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;allocation failure&quot;</span> &lt;&lt; endl; <span class="comment">//申请失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;input  data：&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; k++, ptr++) <span class="comment">//为对象数组各元素赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        ptr-&gt;<span class="built_in">input</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;output:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; k++)</span><br><span class="line">        (--ptr)-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">delete</span>[] ptr;</span><br><span class="line">    <span class="comment">//释放为对象数组动态申请的内存单元</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象成员">对象成员</h2>
<p>用类对象作为另一个类的成员，这个成员称为对象成员或者子对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">&#125;;</span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">    int j;</span><br><span class="line">    A a; //对象成员</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="对象成员的初始化">对象成员的初始化</h3>
<p>对象成员的初始化有两种情况，一种是在构造函数成员初始化表中被初始化，一种是在函数体内被初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> A &amp;a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A m_a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象成员在初始化列表中被初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B::<span class="built_in">B</span>(<span class="type">const</span> A &amp;a) : <span class="built_in">m_a</span>(a)</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象成员在函数体内被初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">B::<span class="built_in">B</span>(<span class="type">const</span> A &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    m_a = a;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【例】示例对象成员。</p>
<p>用Point类来描述点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> xx = <span class="number">0</span>, <span class="type">int</span> yy = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        X = xx;</span><br><span class="line">        Y = yy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">const</span> Point &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        X = p.X;</span><br><span class="line">        Y = p.Y;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;In Point copy constructor.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> X; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> X, Y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义线段距离Distance类来计算两个点之间的距离，在构造函数中实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Distance</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Distance</span>(Point xp1, Point xp2);</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetD</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> dist; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Point p1, p2; <span class="comment">//对象成员p1，p2</span></span><br><span class="line">    <span class="type">double</span> dist;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//构造函数中通过调用复制构造函数初始化对象成员p1、p2</span></span><br><span class="line">Distance::<span class="built_in">Distance</span>(Point xp1, Point xp2) : <span class="built_in">p1</span>(xp1), <span class="built_in">p2</span>(xp2)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;in Distance constructor.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">double</span> x = <span class="built_in">double</span>(p1.<span class="built_in">GetX</span>() - p2.<span class="built_in">GetX</span>());</span><br><span class="line">    <span class="type">double</span> y = <span class="built_in">double</span>(p1.<span class="built_in">GetY</span>() - p2.<span class="built_in">GetY</span>());</span><br><span class="line">    dist = <span class="built_in">sqrt</span>(x * x + y * y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">//主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">myp1</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span>, <span class="title">myp2</span><span class="params">(<span class="number">5</span>, <span class="number">6</span>)</span></span>; <span class="comment">//定义Point类的对象myp1，myp2</span></span><br><span class="line">    <span class="function">Distance <span class="title">myd</span><span class="params">(myp1, myp2)</span></span>;     <span class="comment">//定义 Distance类的对象myd</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The distance is:&quot;</span>;</span><br><span class="line">    cout &lt;&lt; myd.<span class="built_in">GetD</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In Point copy constructor.</span><br><span class="line">In Point copy constructor.</span><br><span class="line">In Point copy constructor.</span><br><span class="line">In Point copy constructor.</span><br><span class="line">in Distance constructor.</span><br><span class="line">The distance is:5</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<p>一般来说，在类中出现了对象成员时，创建本类对象既要对本类的数据成员进行初始化，又要对对象成员进行初始化。</p>
<p>先调用对象成员的构造函数，再调用本类的构造函数。析构函数的调用顺序刚好相反。</p>
<p>如果调用本类默认形式的构造函数，那么也只能调用对象成员的默认形式的构造函数。</p>
<h3 id="对象成员数组">对象成员数组</h3>
<p>一个对象可以作为另一个类的成员，那么对象成员数组同样也可以作为另一个类的成员。</p>
<p>【例】示例对象成员数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CLesson</span> <span class="comment">//定义选课类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CLesson</span>();                                <span class="comment">//无参构造函数</span></span><br><span class="line">    <span class="built_in">CLesson</span>(string lesson);                   <span class="comment">//带参构造函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLesson</span><span class="params">(string lesname)</span></span>;           <span class="comment">//设置选修课程</span></span><br><span class="line">    <span class="function">string <span class="title">GetLesson</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> LessonName; &#125; <span class="comment">//获取选修课程名</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string LessonName; <span class="comment">//课程名</span></span><br><span class="line">&#125;;</span><br><span class="line">CLesson::<span class="built_in">CLesson</span>(string lesson)</span><br><span class="line">&#123;</span><br><span class="line">    LessonName = lesson;</span><br><span class="line">&#125;</span><br><span class="line">CLesson::<span class="built_in">CLesson</span>()</span><br><span class="line">&#123;</span><br><span class="line">    LessonName = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CLesson::setLesson</span><span class="params">(string lesname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LessonName = lesname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="comment">//定义学生类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> value, string str)</span><br><span class="line">    &#123;</span><br><span class="line">        ID = value;</span><br><span class="line">        name = str;</span><br><span class="line">        Number = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddLesson</span><span class="params">(string lesson)</span></span>; <span class="comment">//增加选修课程</span></span><br><span class="line">    <span class="function">string <span class="title">GetLesson</span><span class="params">(<span class="type">int</span> index)</span>    <span class="comment">//获取选修课程名</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LessonName[index].<span class="built_in">GetLesson</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">GetStudentName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125; <span class="comment">//获取学生姓名</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetNum</span><span class="params">()</span>                             <span class="comment">//获取选修课程门数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ID;                <span class="comment">//学号</span></span><br><span class="line">    string name;           <span class="comment">//姓名</span></span><br><span class="line">    CLesson LessonName[<span class="number">5</span>]; <span class="comment">//对象成员数组</span></span><br><span class="line">    <span class="type">int</span> Number;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::AddLesson</span><span class="params">(string lesson)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Number &lt; <span class="number">4</span>) <span class="comment">//设置最多选课数         LessonName[Number++].setLesson(lesson);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">student1</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;Wang Li&quot;</span>)</span></span>; <span class="comment">//定义学生</span></span><br><span class="line">    student1.<span class="built_in">AddLesson</span>(<span class="string">&quot;Computer&quot;</span>); <span class="comment">//增加一门选修课</span></span><br><span class="line">    student1.<span class="built_in">AddLesson</span>(<span class="string">&quot;English&quot;</span>);  <span class="comment">//增加一门选修课</span></span><br><span class="line">    <span class="type">int</span> number = student1.<span class="built_in">GetNum</span>(); <span class="comment">//统计选修课数</span></span><br><span class="line">    cout &lt;&lt; student1.<span class="built_in">GetStudentName</span>() &lt;&lt; <span class="string">&quot; course is:&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; number; i++)</span><br><span class="line">        cout &lt;&lt; student1.<span class="built_in">GetLesson</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">//输出所选课程名</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类模板">类模板</h2>
<p>同函数模板一样，使用类模板可以为类定义一种模式，使得类中的某些数据成员、某些成员函数的参数、某些成员函数的返回值能取任意类型。</p>
<p><strong>类模板是对一批仅有成员数据类型不同的类的抽象。</strong></p>
<p>类模板的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class 类型参数&gt;  </span><br><span class="line">class &lt;类模板名&gt;</span><br><span class="line">&#123; </span><br><span class="line">    &lt;类成员的声明&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，<类型参数>可以有一个或多个。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">//声明一个模板，类型参数名为T</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Compare</span> <span class="comment">//类模板名为Compare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Compare</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Compare</span>(T a, T b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">max</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="类模板的使用">类模板的使用</h3>
<p>由于类模板包含类型参数，因此又称为<strong>参数化的类</strong>。如果说类是对象的抽象，对象是类的实例，则<strong>类模板是类的抽象，类是类模板的实例</strong>。</p>
<p>由类模板经实例化而生成的具体类称之为<strong>模板类</strong>。</p>
<p>利用类模板定义的只是对类的描述，它本身还不是一个实实在在的类。</p>
<p>要定义类模板的对象（即实例），需要用下列格式的语句：</p>
<ul>
<li><p>类模板名 <实际的类型> <对象名></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Compare&lt;<span class="type">int</span>&gt; cmp;</span><br></pre></td></tr></table></figure></li>
<li><p>类模板名 <实际的类型> <对象名>[(实际参数表)];</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Compare&lt;<span class="type">int</span>&gt; <span class="title">cmp</span><span class="params">(<span class="number">3</span>,<span class="number">7</span>)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Compare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Compare</span>(T a, T b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">max</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Compare&lt;<span class="type">int</span>&gt; <span class="title">cmp1</span><span class="params">(<span class="number">3</span>, <span class="number">7</span>)</span></span>;</span><br><span class="line">    <span class="comment">// int Compare类，cmp1为该类的一个对象</span></span><br><span class="line">    cout &lt;&lt; cmp1.<span class="built_in">max</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="function">Compare&lt;<span class="type">double</span>&gt; <span class="title">cmp2</span><span class="params">(<span class="number">4.3</span>, <span class="number">9.6</span>)</span></span>;</span><br><span class="line">    <span class="comment">// double Compare类，cmp2为该类的一个对象</span></span><br><span class="line">    cout &lt;&lt; cmp2.<span class="built_in">max</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="function">Compare&lt;<span class="type">char</span>&gt; <span class="title">cmp3</span><span class="params">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// char Compare类，cmp3为该类的一个对象</span></span><br><span class="line">    cout &lt;&lt; cmp3.<span class="built_in">max</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">9.6</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<h3 id="类模板的实例化">类模板的实例化</h3>
<p>类模板实例化以及类实例化的逻辑关系:</p>
<p><img data-src="image-20201207212818189.png" alt="image-20201207212818189" style="zoom:50%;" /></p>
<h3 id="类模板中的成员函数的定义">类模板中的成员函数的定义</h3>
<p>可以放在类模板的定义体中（此时与类中的成员函数的定义方法一致）</p>
<p>也可以放在类模板的外部，此时成员函数的定义格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class 类型参数&gt; </span><br><span class="line">&lt;返回值类型&gt; &lt;类模板名&gt;&lt;类型参数&gt;::&lt;函数名&gt;（&lt;参数表&gt;）</span><br><span class="line">&#123;</span><br><span class="line">    &lt;函数体&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意！</strong></p>
<p>在类模板外定义成员函数时，每一个函数前均加上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class 类型参数&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T Compare&lt;T&gt;::<span class="built_in">max</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &gt; y) ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<p>类模板的类型参数可以有一个或多个，每个类型前面都必须加class</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;…&#125;;</span><br></pre></td></tr></table></figure>
<p>在定义对象时分别代入实际的类型名</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A&lt;<span class="type">int</span>,<span class="type">double</span>&gt; obj;</span><br></pre></td></tr></table></figure>
<p>使用类模板时要注意其作用域，只能在其有效作用域内用它定义对象。如果类模板是在文件开头定义的，则该文件范围内为有效作用域，可以在其中的任何地方使用类模板。</p>
<h3 id="使用默认参数的类模板">使用默认参数的类模板</h3>
<p>类模板可以包含与通用类型相关的<strong>默认参数</strong>。当类模板被实例化时，如果没有指定其它的数据类型，则使用默认类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T=int&gt;</span><br><span class="line">class Array&#123;…&#125;; //使用默认参数的类模板</span><br><span class="line"></span><br><span class="line">Array&lt;double&gt; doubleob;</span><br><span class="line">Array&lt;&gt; defaultob;</span><br></pre></td></tr></table></figure>
<h2 id="测试-2">测试</h2>
<p>写出下面程序的运行结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cstring&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPicture</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> m_bSatiate;</span><br><span class="line">    <span class="type">char</span> m_szName[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CPicture</span>(<span class="type">char</span> *szName = <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">CPicture</span>(CPicture &amp;CopyPicture);</span><br><span class="line">    ~<span class="built_in">CPicture</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;展览结束了，&quot;</span> &lt;&lt; m_szName &lt;&lt; <span class="string">&quot;也该撤去了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">char</span> *<span class="title">GetName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_szName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; m_bSatiate = <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Finish</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_bSatiate)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;这么美的画一定有很多人喜欢!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;都什么时候了还不开展!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">CPicture::<span class="built_in">CPicture</span>(<span class="type">char</span> *szName)</span><br><span class="line">&#123;</span><br><span class="line">    m_bSatiate = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (szName == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;画家还没有为我命名&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_szName[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(m_szName, szName);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我是&quot;</span> &lt;&lt; m_szName &lt;&lt; <span class="string">&quot;，是一幅美丽的油画 &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">CPicture::<span class="built_in">CPicture</span>(CPicture &amp;CopyPicture)</span><br><span class="line">&#123;</span><br><span class="line">    m_bSatiate = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(m_szName, CopyPicture.<span class="built_in">GetName</span>());</span><br><span class="line">    <span class="built_in">strcat</span>(m_szName, <span class="string">&quot;的复制品&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我是&quot;</span> &lt;&lt; m_szName &lt;&lt; <span class="string">&quot;,也是一幅油画&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Begin</span><span class="params">(CPicture Picture)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Picture.<span class="built_in">Show</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">CPicture <span class="title">Picture</span><span class="params">(<span class="string">&quot;日出&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">Begin</span>(Picture);</span><br><span class="line">    Picture.<span class="built_in">Finish</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我是日出，是一幅美丽的油画</span><br><span class="line">我是日出的复制品,也是一幅油画</span><br><span class="line">展览结束了，日出的复制品也该撤去了</span><br><span class="line">都什么时候了还不开展!</span><br><span class="line">展览结束了，日出也该撤去了</span><br></pre></td></tr></table></figure>
<h1 id="运算符重载">运算符重载</h1>
<h2 id="运算符重载的定义">运算符重载的定义</h2>
<h3 id="提出问题">提出问题</h3>
<p>复数的加减运算问题：</p>
<ul>
<li>对于非基本数据类型，如复数、分数，如何在程序中进行运算？</li>
<li>能否直接用运算符（+、-、*、/）进行运算？</li>
</ul>
<p>自定义一个复数类Complex完成复数的加减运算</p>
<p>设计复数类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>				<span class="comment">//复数类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r=<span class="number">0.0</span>,<span class="type">double</span> i=<span class="number">0.0</span>) <span class="comment">//构造函数</span></span><br><span class="line">    &#123; real=r; imag=i; &#125;  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">　　<span class="type">double</span> real, imag;         	<span class="comment">//定义实部、虚部</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<h3 id="思考">思考</h3>
<p>是否能通过下面的代码完成复数的加减运算?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义复数对象</span></span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.3</span>, <span class="number">2.5</span>)</span></span>; </span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">2.1</span>, <span class="number">1.4</span>)</span></span>;</span><br><span class="line">    Complex c3, c4;</span><br><span class="line">    </span><br><span class="line">    c3 =  c1 + c2;</span><br><span class="line">    c4 =  c1 - c2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>C++预定义的“+”、“-”运算只支持基本数据类型，并不支持用户自定义类型。</p>
<h3 id="重新设计复数类complex">重新设计复数类Complex</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123; 							 </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r=<span class="number">0.0</span>,<span class="type">double</span> i=<span class="number">0.0</span>) <span class="comment">//构造函数</span></span><br><span class="line">    &#123; real=r; imag=i; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Real</span><span class="params">( )</span></span>&#123;<span class="keyword">return</span> real;&#125; <span class="comment">//返回复数的实部</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Imag</span><span class="params">( )</span></span>&#123;<span class="keyword">return</span> imag;&#125;<span class="comment">//返回复数的虚部</span></span><br><span class="line">    <span class="function">Complex <span class="title">add</span><span class="params">(Complex &amp;c)</span></span>;    <span class="comment">//函数重载，实现复数加复数</span></span><br><span class="line">    <span class="function">Complex <span class="title">add</span><span class="params">(<span class="type">double</span> d)</span></span>;      <span class="comment">//函数重载，实现复数加实数</span></span><br><span class="line">    <span class="function">Complex <span class="title">sub</span><span class="params">(Complex &amp;c)</span></span>;    <span class="comment">//函数重载，实现复数减复数</span></span><br><span class="line">    <span class="function">Complex <span class="title">sub</span><span class="params">(<span class="type">double</span> d)</span></span>;     <span class="comment">//函数重载，实现复数减实数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> real, imag; 	<span class="comment">//定义实部、虚部</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="成员函数定义">成员函数定义</h3>
<p>完成复数与复数相加</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">Complex::add</span><span class="params">(Complex &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Complex temp;</span><br><span class="line">    temp.real = real + c.real;</span><br><span class="line">    temp.imag = imag + c.imag;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>完成复数与实数相加</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">Complex::add</span><span class="params">(<span class="type">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Complex temp;</span><br><span class="line">    temp.real = real + d;</span><br><span class="line">    temp.imag = imag;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.3</span>, <span class="number">2.5</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">2.1</span>, <span class="number">1.4</span>)</span></span>;</span><br><span class="line">    Complex c3, c4;</span><br><span class="line">    c3 = c1.<span class="built_in">add</span>(c2);</span><br><span class="line">    c4 = c1.<span class="built_in">sub</span>(c2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3= &quot;</span> &lt;&lt; c3.<span class="built_in">Real</span>() &lt;&lt; <span class="string">&quot; +i &quot;</span> &lt;&lt; c3.<span class="built_in">Imag</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c4= &quot;</span> &lt;&lt; c4.<span class="built_in">Real</span>() &lt;&lt; <span class="string">&quot; +i &quot;</span> &lt;&lt; c4.<span class="built_in">Imag</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不如c3=c1+c2直观!</p>
<h2 id="运算符重载的两种形式">运算符重载的两种形式</h2>
<h3 id="运算符重载-1">运算符重载</h3>
<p>C++提供了<strong>运算符重载机制</strong>，使得系统预定义的运算符能够完成用户自定义数据类型的运算。</p>
<p>运算符重载就是为用户自定义类型<strong>重新定义运算符</strong>，使同一个运算符既可以作用于预定义的数据类型，也可以作用于用户自定义的数据类型。</p>
<p>运算符重载本质上是一种特殊的<strong>函数重载</strong>。</p>
<p>为了重载运算符，必须定义一个运算符重载函数，<strong>由这个函数来完成该运算符应该完成的操作</strong>。<strong>运算符的操作数通常是类的对象</strong>。</p>
<p>可以将运算符重载函数作为<strong>类的成员函数或者是友元函数</strong>。</p>
<h3 id="重载为类的成员函数">重载为类的成员函数</h3>
<p>格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;函数类型&gt; operator &lt;运算符&gt;(&lt;参数表&gt;) //operator是关键字</span><br><span class="line">&#123;	函数体	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A  <span class="keyword">operator</span>+(A &amp;);<span class="comment">//重载了A类的“+”运算符</span></span><br></pre></td></tr></table></figure>
<h3 id="在复数类中重载运算符">在复数类中重载运算符</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>		<span class="comment">//复数类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> r=<span class="number">0.0</span>,<span class="type">double</span> i=<span class="number">0.0</span>)&#123;real=r;imag=i;&#125; </span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">double</span> <span class="title">Real</span><span class="params">( )</span></span>&#123;<span class="keyword">return</span> real;&#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">double</span> <span class="title">Imag</span><span class="params">( )</span></span>&#123;<span class="keyword">return</span> imag;&#125; </span><br><span class="line">    Complex <span class="keyword">operator</span>+( Complex &amp;c); <span class="comment">//重载运算符“+”</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+( <span class="type">double</span> d); <span class="comment">//重载运算符“+”</span></span><br><span class="line">    Complex <span class="keyword">operator</span>-( Complex &amp;c); <span class="comment">//重载运算符“-”</span></span><br><span class="line">    Complex <span class="keyword">operator</span>-( <span class="type">double</span> d);  <span class="comment">//重载运算符&quot;-&quot;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> real,imag; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="运算符重载函数定义">运算符重载函数定义</h3>
<p>完成复数与复数相加</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Complex Complex::<span class="keyword">operator</span> +(Complex &amp;c)</span><br><span class="line">&#123;</span><br><span class="line">    Complex temp;</span><br><span class="line">    temp.real = real + c.real;</span><br><span class="line">    temp.imag = imag + c.imag;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>完成复数与实数相加</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Complex Complex::<span class="keyword">operator</span> +(<span class="type">double</span> d)</span><br><span class="line">&#123;</span><br><span class="line">    Complex temp;</span><br><span class="line">    temp.real = real + d;</span><br><span class="line">    temp.imag = imag;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.3</span>, <span class="number">2.5</span>)</span></span>;</span><br><span class="line">    <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">2.1</span>, <span class="number">1.4</span>)</span></span>;</span><br><span class="line">    Complex c3, c4;</span><br><span class="line">    c3 = c1 + c2; <span class="comment">//相当于c3=c1.operator +(c2);</span></span><br><span class="line">    c4 = c1 - c2; <span class="comment">//相当于c4=c1.operator -(c2);</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c3= &quot;</span> &lt;&lt; c3.<span class="built_in">Real</span>() &lt;&lt; <span class="string">&quot; +i &quot;</span> &lt;&lt; c3.<span class="built_in">Imag</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c4= &quot;</span> &lt;&lt; c4.<span class="built_in">Real</span>() &lt;&lt; <span class="string">&quot; +i &quot;</span> &lt;&lt; c4.<span class="built_in">Imag</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="说明">说明</h3>
<p>在C++中不允许重载有三个操作数的运算符。</p>
<p>运算符重载为成员函数时<strong>最多有一个形参</strong>。</p>
<p>运算符重载的<strong>实质就是函数重载</strong>，只不过函数名换成了关键字operator和具体要重载的运算符。</p>
<p>运算符重载的函数参数<strong>就是该运算符涉及的操作数</strong>，因此运算符重载在参数个数上是有限制的，这是它不同于函数重载之处。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a = <span class="number">0</span>) &#123; i = a; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddA</span><span class="params">(A &amp;a, A &amp;b)</span> <span class="comment">//利用函数进行类之间的运算</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        i = a.i + b.i;</span><br><span class="line">    &#125;</span><br><span class="line">    A <span class="keyword">operator</span>+(A &amp;a) <span class="comment">//重载运算符+</span></span><br><span class="line">    &#123;</span><br><span class="line">        A t;</span><br><span class="line">        t.i = i + a.i;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">10</span>)</span>, <span class="title">a2</span><span class="params">(<span class="number">20</span>)</span>, a3</span>;</span><br><span class="line">    a1.<span class="built_in">Show</span>();</span><br><span class="line">    a2.<span class="built_in">Show</span>();</span><br><span class="line">    a3 = a1 + a2;    <span class="comment">//重新解释了加法，可以直接进行类的运算</span></span><br><span class="line">    a3.<span class="built_in">AddA</span>(a1, a2); <span class="comment">//调用专门的功能函数</span></span><br><span class="line">    a3.<span class="built_in">Show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运算符重载为成员函数时，左操作数必须是对象本身，由左操作数调用右操作数。最后将函数返回值赋给运算结果的对象。</p>
<h3 id="运算符重载的规则">运算符重载的规则</h3>
<p>重载的功能应当与原有功能类似，不能改变原运算符的操作数个数，同时至少要有一个操作数的类型是自定义类型。</p>
<p>重载之后运算符的优先级和结合性都不会改变，并且要保持原运算符的语法结构。参数和函数值类型都可以重新说明。</p>
<p>当用<strong>成员函数实现运算符的重载时</strong>，运算符重载函数的参数只能有两种情况：<strong>没有参数或带有一个参数</strong>。</p>
<p>在重载<strong>双目</strong>运算符时，只能带有<strong>一个参数</strong>。参数可以是对象，对象的引用，或其它类型的参数。</p>
<h3 id="不能重载的运算符">不能重载的运算符</h3>
<table>
<thead>
<tr class="header">
<th>不能重载的运算符</th>
<th style="text-align: left;">说　明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>::</td>
<td style="text-align: left;">作用域运算符</td>
</tr>
<tr class="even">
<td>.</td>
<td style="text-align: left;">成员访问运算符</td>
</tr>
<tr class="odd">
<td>*</td>
<td style="text-align: left;">成员指针访问运算符</td>
</tr>
<tr class="even">
<td>?:</td>
<td style="text-align: left;">条件运算符</td>
</tr>
<tr class="odd">
<td>sizeof</td>
<td style="text-align: left;">长度运算符：求表达式或数据类型所占存储空间字节数</td>
</tr>
</tbody>
</table>
<h3 id="单目运算符的重载">单目运算符的重载</h3>
<p>只具有一个操作数的运算符为单目运算符，最常用的为++及--。</p>
<p>先自加或后自加的<strong>重载运算符函数的返回值不一致</strong>，<strong>必须在重载时予以区分</strong>。</p>
<p>++为前置运算符时，它的运算符重载函数的一般格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt; operator ++()</span><br></pre></td></tr></table></figure>
<p>++为后置运算符时，它的运算符重载函数的一般格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;  operator ++(int)</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">float</span> a = <span class="number">0</span>, <span class="type">float</span> b = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    A <span class="keyword">operator</span>++()</span><br><span class="line">    &#123;</span><br><span class="line">        A t;</span><br><span class="line">        t.x = ++x;</span><br><span class="line">        t.y = ++y;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    A <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        A t;</span><br><span class="line">        t.x = x++;</span><br><span class="line">        t.y = y++;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span>, b</span>;</span><br><span class="line">    b = ++a;</span><br><span class="line">    b = a++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运算符重载为成员函数后，它可以自由地访问类的所有成员。实际使用时，总是通过该类的某个对象来访问重载的运算符。</p>
<p>运算符重载为类的成员函数时，函数的参数个数比原来操作数少一个（后置“++”和后置“--”除外）。</p>
<p>用成员函数实现运算符的重载时，<strong>运算符的左操作数为当前对象</strong>，并且要用到隐含的this指针。</p>
<p><strong>运算符重载函数不能定义为静态的成员函数，因为静态的成员函数中没有this指针。</strong></p>
<h3 id="说明-1">说明</h3>
<p>如果是双目运算符，左操作数一定是对象本身，由this指针给出，另一个操作数需要由运算符重载的参数表来传递。</p>
<p>如果是单目运算符，操作数由对象的this指针给出，就不再需要任何参数。但重载“++”和“--”运算符时，C++约定，如果在参数表中放一个整型参数，则表示重载的运算符为后置运算符。</p>
<h2 id="友元的作用和定义">友元的作用和定义</h2>
<p>根据类的封装性，一般将数据成员声明为私有成员，外部不能直接访问，只能通过类的公有成员函数对私有成员进行访问。</p>
<p>C++<strong>从高效的角度出发</strong>，提供友元机制，使被声明为友元的函数或者其他类可以直接访问当前类中的私有成员，又不改变其私有成员的访问权限。</p>
<p>友元可以是一个<strong>全局函数</strong>、另一个类的<strong>成员函数</strong>或者是一个<strong>类</strong>。分别称为友元函数和友元类。友元类的所有成员函数都是友元函数，可以访问被访问类的任何成员。</p>
<p><strong>友元声明以关键字friend开始，只能出现在被访问类的定义中。</strong>具体格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">friend  &lt;函数值类型&gt;  &lt;函数名&gt;(&lt;参数表&gt;);</span><br><span class="line">friend  class &lt;类名&gt;; </span><br></pre></td></tr></table></figure>
<p><strong>友元函数不是该类的成员函数，它破坏了类的封装性和隐蔽性，使得非成员函数可以访问类的私有成员。</strong></p>
<p>一个类的友元可以自由地用该类中的所有成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">float</span> a, <span class="type">float</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">Sum</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;                <span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">float</span> <span class="title">Sum</span><span class="params">(A &amp;a)</span> </span>&#123; <span class="keyword">return</span> a.x + a.y; &#125; <span class="comment">//友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">t1</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>)</span>, <span class="title">t2</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; t1.<span class="built_in">Sum</span>() &lt;&lt; endl; <span class="comment">//成员函数的调用，利用对象名调用</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Sum</span>(t2) &lt;&lt; endl;  <span class="comment">//友元函数的调用，直接调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>友元函数只能用对象名引用类中的数据。</p>
<h3 id="友元函数与普通函数">友元函数与普通函数</h3>
<p>友元函数近似于<strong>普通函数</strong>，它不带有this指针，<strong>因此必须将对象名或对象的引用作为友元函数的参数</strong>，这样才能访问到对象的成员。</p>
<p><strong>友元函数必须在类的定义中声明</strong>，其函数体可在类内定义，也可在类外定义。</p>
<p><strong>友元函数可以访问该类中的所有成员（公有的、私有的和保护的）</strong>，而普通函数只能访问类中的公有成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">float</span> a, <span class="type">float</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">Getx</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">Gety</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">Sum</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x + y; &#125; <span class="comment">//成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">float</span> <span class="title">Sum</span><span class="params">(A &amp;)</span></span>;        <span class="comment">//友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Sum</span><span class="params">(A &amp;a)</span> </span>&#123; <span class="keyword">return</span> a.x + a.y; &#125;             <span class="comment">//友元函数,可以直接调用类中私有成员</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Sumxy</span><span class="params">(A &amp;a)</span> </span>&#123; <span class="keyword">return</span> a.<span class="built_in">Getx</span>() + a.<span class="built_in">Gety</span>(); &#125; <span class="comment">//普通函数，必须通过公有函数访问私有成员</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">t1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span>, <span class="title">t2</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span>, <span class="title">t3</span><span class="params">(<span class="number">100</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; t1.<span class="built_in">Sum</span>() &lt;&lt; endl;  <span class="comment">//对象调用成员函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Sum</span>(t2) &lt;&lt; endl;   <span class="comment">//调用友元函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Sumxy</span>(t3) &lt;&lt; endl; <span class="comment">//调用普通函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>友元函数不受类中访问权限关键字的限制，可以把它放在类的私有、公有或保护部分，其作用都是一样的。换言之，<strong>在类中对友元函数指定访问权限不起作用</strong>。</p>
<p>友元函数的作用域与普通函数的作用域相同。</p>
<p>谨慎使用友元函数</p>
<ul>
<li>通常使用友元函数来<strong>取</strong>对象中的数据成员值，而<strong>不修改</strong>对象中的成员值，保证数据安全。</li>
</ul>
<p>大多数情况下友元函数是某个类的成员函数，<strong>即A类中的某个成员函数是B类中的友元函数，这个成员函数可以直接访问B类中的私有数据</strong>。这就实现了类与类之间的沟通。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">( B &amp;)</span></span>;<span class="comment">//既是类A的成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">A::fun</span><span class="params">( B &amp;)</span></span>;<span class="comment">//又是类B的友元函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>A类中的成员函数fun()是B类的友元函数。即在fun()中可以直接引用B类的私有成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>   <span class="title class_">B</span>  ;	<span class="comment">//先定义A类，则首先对B类作引用性说明</span></span><br><span class="line"><span class="keyword">class</span>   <span class="title class_">A</span>&#123;</span><br><span class="line">   ......		<span class="comment">//类A的成员定义</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span>  <span class="title">fun</span><span class="params">( B &amp; )</span></span>;<span class="comment">//函数的原型说明</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">B</span>&#123;	......</span><br><span class="line">    <span class="function"><span class="keyword">friend</span>  <span class="type">void</span>  <span class="title">A::fun</span><span class="params">( B &amp; )</span></span>;<span class="comment">//定义友元函数</span></span><br><span class="line">&#125;；</span><br><span class="line">    <span class="function"><span class="type">void</span>  <span class="title">A::fun</span> <span class="params">( B  &amp;b)</span>	   <span class="comment">//函数的完整定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     ......		<span class="comment">//函数体的定义</span></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>A类中有一个函数可以直接引用B类的私有成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">//必须在此进行引用性说明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">float</span> a, <span class="type">float</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Sum</span><span class="params">(B &amp;)</span></span>; <span class="comment">//说明友元函数的函数原型，是A类的成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> m, n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">float</span> a, <span class="type">float</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        m = a;</span><br><span class="line">        n = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">A::Sum</span><span class="params">(B &amp;)</span></span>; <span class="comment">//说明A类的成员函数是B类的友元函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::Sum</span><span class="params">(B &amp;b)</span>       <span class="comment">//定义该友元函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = b.m + b.n;</span><br><span class="line">    y = b.m - b.n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">B <span class="title">b1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    a1.<span class="built_in">Sum</span>(b1); <span class="comment">//调用该函数，因是A类的成员函数，故用A类的对象调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="友元类">友元类</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">//B类是A类的友元</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    ..... <span class="comment">//B类可以自由使用A类中的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于B类而言，A类是透明的</p>
<p>B类必须通过<strong>A类的对象</strong>使用A类的成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> r;</span><br><span class="line">    <span class="type">float</span> h;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">float</span> a, <span class="type">float</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        r = a;</span><br><span class="line">        h = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">Getr</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">Geth</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> h; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">//定义B类为A类的友元</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> n = <span class="number">1</span>) &#123; number = n; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(A &amp;a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; PI * a.r * a.r * a.h * number &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="comment">//求A类的某个对象*n的体积</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">25</span>, <span class="number">40</span>)</span>, <span class="title">a2</span><span class="params">(<span class="number">10</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    <span class="function">B <span class="title">b1</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    b1.<span class="built_in">Show</span>(a1) ； b1.<span class="built_in">Show</span>(a2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="友元小结">友元小结</h3>
<p>友元的出现主要是为了解决一些实际问题，友元本身不是面向对象的内容。</p>
<p>通过友元机制，一个类或函数可以直接访问另一类中的非公有成员。</p>
<p>可以将全局函数、类、类的成员函数声明为友元。</p>
<p>友元关系是不能传递的。B类是A类的友元，C类是B类的友元，C类和A类之间，如果没有声明，就没有任何友元关系，不能进行数据共享。</p>
<p>友元关系是单向的，如果声明B类是A类的友元，B类的成员函数就可以访问A类的私有成员和保护成员。但A类的成员不能访问B类的私有成员和保护成员，除非声明A类是B类的友元。</p>
<h3 id="运算符重载的使用">运算符重载的使用</h3>
<p>运算符重载有两种方式：运算符重载为<strong>类的成员函数</strong>，运算符重载为<strong>类的友元函数</strong>。</p>
<p>当运算符重载为类的成员函数时，对于单目运算符，操作数一定是对象本身，对于双目运算符，左操作数一定是对象。</p>
<p>当运算符重载为友元函数时，参数中同样必须有一个是用户自定义类型的对象，但不限定其必须是左操作数。</p>
<p>运算符重载为<strong>成员函数</strong>时，是由一个操作数调用另一个操作数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A  a, b, c;</span><br><span class="line">c=a+b;	<span class="comment">//实际上是c=a.operator+(b);</span></span><br><span class="line">c=++a;	<span class="comment">//实际上是c=a.operator++();</span></span><br><span class="line">c+=a;	<span class="comment">//实际上是c.operator+=(a);</span></span><br><span class="line"><span class="comment">//即函数的实参只有一个或没有。</span></span><br></pre></td></tr></table></figure>
<p>将运算符的重载函数定义为友元函数，<strong>参与运算的对象全部成为函数参数</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A  a, b, c;</span><br><span class="line">c=a+b;	<span class="comment">//实际上是 c=operator+(a, b);</span></span><br><span class="line">c=++a;	<span class="comment">//实际上是 c=operator++(a);</span></span><br><span class="line">c+=a;	<span class="comment">//实际上是 operator+=(c, a);</span></span><br></pre></td></tr></table></figure>
<h3 id="重载为类的友元函数">重载为类的友元函数</h3>
<p>语法形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> &lt;函数值类型&gt; <span class="keyword">operator</span> &lt;运算符&gt;(&lt;参数表&gt;)</span><br><span class="line">&#123;</span><br><span class="line">        &lt;函数体&gt;；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运算符重载为类的友元函数<strong>最多只能有两个参数</strong></p>
<p>如果重载双目运算符，则<strong>第一个参数代表左操作数，第二个参数代表右操作数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a = <span class="number">0</span>) &#123; i = a; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="keyword">friend</span> A <span class="keyword">operator</span>+(A &amp;, A &amp;); <span class="comment">//友元函数，两个参数，为引用</span></span><br><span class="line">&#125;;</span><br><span class="line">A <span class="keyword">operator</span>+(A &amp;a, A &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    A t;</span><br><span class="line">    t.i = a.i + b.i;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">10</span>)</span>, <span class="title">a2</span><span class="params">(<span class="number">20</span>)</span>, a3</span>;</span><br><span class="line">    a1.<span class="built_in">Show</span>();</span><br><span class="line">    a2.<span class="built_in">Show</span>();</span><br><span class="line">    a3 = a1 + a2; <span class="comment">//重新解释了加法，可以直接进行类的运算</span></span><br><span class="line">    a3.<span class="built_in">Show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单目运算符重载">单目运算符重载</h3>
<p><strong>++为前置运算符时</strong>，它的运算符重载函数的一般格式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A <span class="keyword">operator</span> ++(A &amp;a)</span><br></pre></td></tr></table></figure>
<p><strong>++为后置运算符时</strong>，它的运算符重载函数的一般格式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A <span class="keyword">operator</span> ++(A &amp;a, <span class="type">int</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a = <span class="number">0</span>) &#123; i = a; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="keyword">friend</span> A <span class="keyword">operator</span>++(A &amp;a)</span><br><span class="line">    &#123;</span><br><span class="line">        a.i++;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> A <span class="keyword">operator</span>++(A &amp;a, <span class="type">int</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        A t;</span><br><span class="line">        t.i = a.i;</span><br><span class="line">        a.i++;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">10</span>)</span>, a2, a3</span>;</span><br><span class="line">    a2 = ++a1;</span><br><span class="line">    a3 = a1++;</span><br><span class="line">    a2.<span class="built_in">Show</span>();</span><br><span class="line">    a3.<span class="built_in">Show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i=11</span><br><span class="line">i=11</span><br></pre></td></tr></table></figure>
<p>【例】示例运算符重载为类的友元函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cmath&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span>;</span><br><span class="line"><span class="type">double</span> <span class="keyword">operator</span>+(Triangle &amp;t1, Triangle &amp;t2);</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Triangle</span>(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> s;</span><br><span class="line">        x = i;</span><br><span class="line">        y = j;</span><br><span class="line">        z = k;</span><br><span class="line">        s = (x + y + z) / <span class="number">2.0</span>;</span><br><span class="line">        area = <span class="built_in">sqrt</span>(s * (s - x) * (s - y) * (s - z));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disparea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Area=&quot;</span> &lt;&lt; area &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">double</span> <span class="keyword">operator</span>+(Triangle &amp;t1, Triangle &amp;t2) <span class="comment">//运算符重载为友元函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> t1.area + t2.area;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    <span class="type">double</span> area;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Triangle <span class="title">t1</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span>, <span class="title">t2</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="type">double</span> s;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t1:&quot;</span>;</span><br><span class="line">    t1.<span class="built_in">disparea</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t2:&quot;</span>;</span><br><span class="line">    t2.<span class="built_in">disparea</span>();</span><br><span class="line">    s = t1 + t2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;总面积=&quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1:Area=6</span><br><span class="line">t2:Area=9.92157</span><br><span class="line">总面积=15.9216</span><br></pre></td></tr></table></figure>
<p>【例】定义一个字符串类Str，重载运算符&gt;，用于两个字符串的大于的比较运算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cstring&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Str</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Str</span>() &#123; p = <span class="literal">NULL</span>; &#125;</span><br><span class="line">    <span class="built_in">Str</span>(<span class="type">char</span> *str) &#123; p = str; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; cout &lt;&lt; p; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;(Str &amp;string1, Str &amp;string2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(string1.p, string2.p) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Str <span class="title">string1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span>, <span class="title">string2</span><span class="params">(<span class="string">&quot;Book&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; (string1 &gt; string2) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<p>【例】将上例扩展到对==，<和>三个运算符进行重载。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cstring&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Str</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Str</span>() &#123; p = <span class="literal">NULL</span>; &#125;</span><br><span class="line">    <span class="built_in">Str</span>(<span class="type">char</span> *str) &#123; p = str; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;(Str &amp;string1, Str &amp;string2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(string1.p, string2.p) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(Str &amp;string1, Str &amp;string2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(string1.p, string2.p) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(Str &amp;string1, Str &amp;string2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(string1.p, string2.p) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">compare</span><span class="params">(Str &amp;string1, Str &amp;string2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">operator</span>&gt;(string1, string2) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        string1.<span class="built_in">display</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&gt;&quot;</span>;</span><br><span class="line">        string2.<span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">operator</span>&lt;(string1, string2) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        string1.<span class="built_in">display</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&lt;&quot;</span>;</span><br><span class="line">        string2.<span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">operator</span>==(string1, string2) == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        string1.<span class="built_in">display</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;=&quot;</span>;</span><br><span class="line">        string2.<span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Str <span class="title">string1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span>, <span class="title">string2</span><span class="params">(<span class="string">&quot;Book&quot;</span>)</span>,</span></span><br><span class="line"><span class="function">        <span class="title">string3</span><span class="params">(<span class="string">&quot;Computer&quot;</span>)</span>, <span class="title">string4</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">compare</span>(string1, string2);</span><br><span class="line">    <span class="built_in">compare</span>(string2, string3);</span><br><span class="line">    <span class="built_in">compare</span>(string1, string4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello&gt;Book</span><br><span class="line">Book&lt;Computer</span><br><span class="line">Hello=Hello</span><br></pre></td></tr></table></figure>
<h3 id="重载输入运算符和输出运算符">重载输入运算符和输出运算符</h3>
<p>对象不能直接输入输出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">float</span> a = <span class="number">0</span>, <span class="type">float</span> b = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Set</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    a.<span class="built_in">Set</span>(<span class="number">20</span>, <span class="number">30</span>); <span class="comment">//输入对象数据</span></span><br><span class="line">    a.<span class="built_in">Show</span>();      <span class="comment">//输出对象数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20,30</span><br></pre></td></tr></table></figure>
<p>在C++中允许用户重载运算符“&lt;&lt;”和“&gt;&gt;”，<strong>实现对象的输入和输出</strong>。重载这两个运算符时，在对象所在的类中，<strong>将重载这两个运算符的函数说明为该类的友元函数</strong>。</p>
<p>重载输入运算符的一般格式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span>  istream &amp;  operater&gt;&gt;(istream &amp;, ClassName &amp;);</span><br><span class="line"><span class="comment">//友元   返回值类型   函数名      左操作数    右操作数</span></span><br></pre></td></tr></table></figure>
<p>cin&gt;&gt;a; ==&gt; operator&gt;&gt;(cin, a);</p>
<p>返回值类型：类istream的引用，cin中可以连续使用运算符“&gt;&gt;”。<code>cin&gt;&gt;a&gt;&gt;b;</code></p>
<p>第一个参数：是&gt;&gt;的左操作数cin类型,类istream的引用</p>
<p>第二个参数：是&gt;&gt;的右操作数,即欲输入的对象的引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">friend</span>  istream&amp; operater&gt;&gt;(istream &amp;, A &amp;);<span class="comment">//在类中原型说明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//在类外定义函数</span></span><br><span class="line">istream &amp;  operater&gt;&gt;(istream &amp;is, A &amp;a)</span><br><span class="line">&#123;    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Input a:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    is&gt;&gt;a.x&gt;&gt;a.y;<span class="comment">// 重新定义输入流</span></span><br><span class="line">    <span class="keyword">return</span>  is;<span class="comment">// 返回输入流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">incount</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c1, c2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">incount</span>(<span class="type">int</span> a = <span class="number">0</span>, <span class="type">int</span> b = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c1 = a;</span><br><span class="line">        c2 = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;c1=&quot;</span> &lt;&lt; c1 &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">                           &lt;&lt; <span class="string">&quot;c2=&quot;</span> &lt;&lt; c2 &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;, incount &amp;);</span><br><span class="line">&#125;;</span><br><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, incount &amp;cc)</span><br><span class="line">&#123;</span><br><span class="line">    is &gt;&gt; cc.c1 &gt;&gt; cc.c2;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    incount x1, x2;</span><br><span class="line">    x1.<span class="built_in">show</span>();</span><br><span class="line">    x2.<span class="built_in">show</span>();</span><br><span class="line">    cin &gt;&gt; x1;</span><br><span class="line">    cin &gt;&gt; x2;</span><br><span class="line">    x1.<span class="built_in">show</span>();</span><br><span class="line">    x2.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重载输出运算符的一般格式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span>  ostream &amp;  operater&lt;&lt;(ostream &amp;, ClassName &amp;);</span><br><span class="line"><span class="comment">//友元   返回值类型   函数名      左操作数    右操作数 </span></span><br></pre></td></tr></table></figure>
<p>cout&lt;&lt;a; ==&gt; operator&lt;&lt;(cout, a);</p>
<p>与输入（提取）运算符比较：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span>  istream&amp;  operater&gt;&gt;(istream &amp;, ClassName &amp;);</span><br></pre></td></tr></table></figure>
<p>将输入流改为输出流。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;operater&lt;&lt;(ostream &amp;, A &amp;);</span><br><span class="line">    <span class="comment">//在类中原型说明</span></span><br><span class="line">&#125;;</span><br><span class="line">ostream &amp;operater&lt;&lt;(ostream &amp;os, A &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The object is :&quot;</span> &lt;&lt; endl;</span><br><span class="line">    os &lt;&lt; a.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; a.y &lt;&lt; endl; <span class="comment">//重新定义输出流</span></span><br><span class="line">    <span class="keyword">return</span> os;                       <span class="comment">//返回输出流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">incount</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> c1, c2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">incount</span>(<span class="type">int</span> a = <span class="number">0</span>, <span class="type">int</span> b = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c1 = a;</span><br><span class="line">        c2 = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">void</span>)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;c1=&quot;</span> &lt;&lt; c1 &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">                           &lt;&lt; <span class="string">&quot;c2=&quot;</span> &lt;&lt; c2 &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;, incount &amp;);</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;, incount &amp;);</span><br><span class="line">&#125;;</span><br><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, incount &amp;cc)</span><br><span class="line">&#123;</span><br><span class="line">    is &gt;&gt; cc.c1 &gt;&gt; cc.c2;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, incount &amp;cc) <span class="comment">//重载cout&lt;&lt;</span></span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;c1=&quot;</span> &lt;&lt; cc.c1 &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">       &lt;&lt; <span class="string">&quot;c2=&quot;</span> &lt;&lt; cc.c2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    incount x1, x2;</span><br><span class="line">    cout &lt;&lt; x1 &lt;&lt; x2; <span class="comment">//调用输出函数</span></span><br><span class="line">    cin &gt;&gt; x1;        <span class="comment">//调用输入函数</span></span><br><span class="line">    cin &gt;&gt; x2;</span><br><span class="line">    cout &lt;&lt; x1 &lt;&lt; x2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两种运算符重载形式的比较">两种运算符重载形式的比较</h3>
<p>用友元或成员函数重载运算符在功能上没有什么区别。有时<strong>将双目运算符重载为友元函数比重载为成员函数使用起来更灵活。</strong></p>
<p>对于双目运算符，重载为成员函数时，仅一个参数，另一个被隐含；重载为友元函数时，有两个参数，没有隐含参数。</p>
<p>对于前置单目运算符，重载为成员函数时，没有参数；重载为友元函数时，有一个参数。 后置单目运算符重载时比前置单目运算符多一个整型参数。</p>
<h2 id="类型转换运算符重载">类型转换运算符重载</h2>
<h3 id="基本类型到类类型的转换">基本类型到类类型的转换</h3>
<p>同类型的对象可以相互赋值，相当于类中的数据成员相互赋值。</p>
<p>如果<strong>直接将数据赋给对象</strong>，所赋入的数据需要强制类型转换，<strong>这种转换需要调用构造函数</strong>。也就是利用<strong>构造函数</strong>能完成从基本类型到类类型的转换。</p>
<p>使用构造函数进行类型转换必须有一个前提，那就是在这个类中定义一个只有一个参数的构造函数——<strong>转换构造函数</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Complex</span>(<span class="type">double</span> r)&#123;real=r;imag=<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<p>其作用是将double型的参数r转换成Comlex类的对象，将r作为复数的实部，虚部为0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.5</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>建立Complex类对象c1，实部值为3.5，虚部值为0。它的作用就是将double型值转换成一个名为c1的Complex类对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;调用构造函数\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;调用析构函数\n&quot;</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    b1.<span class="built_in">Print</span>();</span><br><span class="line">    b1 = <span class="number">10</span>; <span class="comment">//b1=B(10) 产生一个临时对象</span></span><br><span class="line">    b1.<span class="built_in">Print</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;退出主函数\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">调用构造函数</span><br><span class="line">1</span><br><span class="line">调用构造函数 //创建临时对象</span><br><span class="line">调用析构函数 //这里是临时对象析构了</span><br><span class="line">10</span><br><span class="line">退出主函数</span><br><span class="line">调用析构函数</span><br></pre></td></tr></table></figure>
<p>注意：当构造函数只有一个参数时，可以用=强制赋值。</p>
<h3 id="类类型到基本类型的转换">类类型到基本类型的转换</h3>
<p>利用类型转换运算符重载将A类的对象a转换成某种基本数据类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl; <span class="comment">//错误！类的对象不能直接输出</span></span><br><span class="line">    return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换构造函数能够把基本类型数据转换成指定类对象，但不能把类对象转换为基本类型数据。</p>
<p>C++引入一种特殊的成员函数——<strong>类型转换</strong>函数。类型转换函数实际上就是一个类型转换运算符<strong>重载函数</strong>。</p>
<p>类型转换函数专门用来将类类型转换为基本数据类型，它只能被重载为成员函数。</p>
<p>重载类型转换运算符函数格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">operator〈返回基本类型名〉（）</span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    return 〈基本类型值〉</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数前不需要加函数值类型。</p>
<p>转换函数的调用是隐含的，没有参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a = <span class="number">0</span>) &#123; i = a; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a1</span><span class="params">(<span class="number">10</span>)</span>, <span class="title">a2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> Real, Imag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> real, <span class="type">double</span> imag)</span><br><span class="line">    &#123;</span><br><span class="line">        Real = real;</span><br><span class="line">        Imag = imag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span>; <span class="comment">//成员函数，定义类转换 Complex－&gt;double</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Complex::<span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Real * Real + Imag * Imag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">3.7</span>, <span class="number">4.5</span>)</span></span>;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    d = <span class="number">2.5</span> + c1; <span class="comment">//隐式调用类型转换函数</span></span><br><span class="line">    cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">36.44</span><br></pre></td></tr></table></figure>
<h2 id="本章小结">本章小结</h2>
<p>运算符重载不是每个程序必须具有的功能，它的出现只是为了增加程序的易读性。</p>
<p>运算符重载不是新的机制，其实质是函数重载。与函数重载不同的是，运算符重载在参数上有限制。</p>
<p>运算符重载有两种形式：重载为类的成员函数、重载为类的友元函数。当运算符重载为成员函数时，左操作数一定是当前对象本身，而重载为友元函数时，该运算符所涉及的所有操作数都必须出现在函数的参数列表当中。操作数出现的顺序按照参数从左到右出现的顺序决定。</p>
<p>类的友元可以访问类的所有成员。友元可以是普通函数，其他类的成员函数，也可以是其他类。友元关系既不能传递、也不可逆。</p>
<p>友元不是纯面向对象的产物，它在类之间、类与普通函数之间共享了内部封装的数据，破坏了类的封装性，设计它的目的是为了实用。因此，在实际编程过程中，应尽量避免使用友元。</p>
<p>类类型转换函数只能是成员函数，不能是友元函数。<strong>转换函数的操作数是对象</strong>。</p>
<h2 id="测试-3">测试</h2>
<p>1.改正下面代码中的错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>()&#123;itsWeight=<span class="number">0</span>; itsAge=<span class="number">0</span>;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> itsWeight;</span><br><span class="line">    <span class="type">int</span> itsAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetValue</span><span class="params">(Animal &amp; ta, <span class="type">int</span> tw, <span class="type">int</span> tn)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    ta.itsWeight = tw;</span><br><span class="line">    ta.itsAge = tn;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    Animal peppy;</span><br><span class="line">    <span class="built_in">SetValue</span>(peppy, <span class="number">7</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<p>2.要求重载运算符“+”，使之能用于矩阵相加(分别重载为类的成员函数和友元函数),实现两个2行3列矩阵的相加。</p>
<h1 id="继承与派生">继承与派生</h1>
<h2 id="继承的引出">继承的引出</h2>
<h3 id="共性与差别的表示">共性与差别的表示</h3>
<ul>
<li>孤立的类只能描述实体集合的特征同一性，而客观世界中实体集合的划分通常还要考虑实体特征方面有关联的相似性。</li>
<li>“相似”——既有共同点，又有差别
<ul>
<li>内涵的相似性：在客观世界中具有一般— 特殊的关系。（例如：雇员和经理。）</li>
<li>结构的相似性：具有相似的表示。（例如：飞机仪表盘的仪表）</li>
</ul></li>
<li>如果将相似的事物用不同的类型来表示，能够表示其差别，但体现不了它们之间存在共性的事实，且共性的表示也可能不一致。当扩充维护过程中需要对其共性部分进行修改时，就面临着保持一致性的问题。</li>
<li>如果将相似的事物用相同的类型来表示，则体现其差别就十分困难，且失去了类型化的支持。一旦需扩充和修改也将影响用此种类型表示的所有其他事物。</li>
</ul>
<h3 id="继承性inheritance">继承性（inheritance）</h3>
<p>定义：在类之间既能体现其共性和差别，又能给出其间存在共性和差别关系的信息，还能将这样的关系按照需要进行传递的类型化机制。</p>
<p>继承是OOP中最关键的一方面</p>
<ul>
<li>程序设计
<ul>
<li>减少冗余代码</li>
<li>不加修改地重用已经过测试的代码</li>
</ul></li>
<li>设计
<ul>
<li>分类法是人们用于组织信息的自然方法</li>
<li>应该按照同样的方法（继承）来组织软件</li>
</ul></li>
<li>软件工程
<ul>
<li>灵活性－派生类可以覆盖基类方法、添加新的属性和行为</li>
<li>扩展性－派生类可以适应新创建的元素</li>
</ul></li>
</ul>
<h2 id="派生类的定义">派生类的定义</h2>
<p>派生是指由基类创建新类的过程，派生类的定义格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class &lt;派生类名&gt;：&lt;继承方式&gt; &lt;基类名&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &lt;派生类新定义成员&gt;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;  <span class="comment">//基类成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A <span class="comment">//A派生了B，B继承了A，</span></span><br><span class="line">            <span class="comment">//B自动拥有A的成员</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;  <span class="comment">//定义派生类的新成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="派生后的访问权限控制">派生后的访问权限控制</h2>
<p>派生类继承了基类的数据成员和成员函数，它们在派生类中的访问属性由继承方式控制。</p>
<p>类的继承方式有public(公有继承)、protected(保护继承)和private(私有继承)三种。<strong>默认情况下为私有继承</strong>。</p>
<p>三种继承方式下派生类中基类成员的访问控制权限</p>
<table>
<thead>
<tr class="header">
<th></th>
<th><strong>公有继承</strong></th>
<th><strong>保护继承</strong></th>
<th><strong>私有继承</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>公有成员</strong></td>
<td><strong>公有</strong></td>
<td><strong>保护</strong></td>
<td><strong>私有</strong></td>
</tr>
<tr class="even">
<td><strong>保护成员</strong></td>
<td><strong>保护</strong></td>
<td><strong>保护</strong></td>
<td><strong>私有</strong></td>
</tr>
<tr class="odd">
<td><strong>私有成员</strong></td>
<td><strong>派生类成员不可访问</strong></td>
<td><strong>派生类成员不可访问</strong></td>
<td><strong>派生类成员不可访问</strong></td>
</tr>
</tbody>
</table>
<h3 id="公有继承">公有继承</h3>
<p>在派生类中，<strong>基类的公有成员和保护成员被继承后分别成为派生类的公有成员和保护成员</strong>。</p>
<p>派生类的新成员可以直接访问它们，而派生类的新成员<strong>不能</strong>直接<strong>访问</strong>基类的<strong>私有成员</strong>。在类外，<strong>派生类的对象可以访问</strong>继承下来的基类公有成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> <span class="comment">//基类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//公有成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InitP</span><span class="params">(<span class="type">float</span> xx = <span class="number">0</span>, <span class="type">float</span> yy = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        X = xx;</span><br><span class="line">        Y = yy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">float</span> xOff, <span class="type">float</span> yOff)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        X += xOff;</span><br><span class="line">        Y += yOff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> X; &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">//私有数据成员</span></span><br><span class="line">    <span class="type">float</span> X, Y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Point <span class="comment">//派生类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//新增公有成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InitR</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">float</span> w, <span class="type">float</span> h)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">InitP</span>(x, y);</span><br><span class="line">        W = w;</span><br><span class="line">        H = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用基类公有成员函数</span></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetH</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> H; &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetW</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> W; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">//新增私有数据成员</span></span><br><span class="line">    <span class="type">float</span> W, H;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rectangle rect;</span><br><span class="line">    <span class="comment">//声明Rectangle类的对象</span></span><br><span class="line">    rect.<span class="built_in">InitR</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="comment">//设置矩形的数据</span></span><br><span class="line">    rect.<span class="built_in">Move</span>(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">//移动矩形位置</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The date of rect(X,Y,W,H):&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; rect.<span class="built_in">GetX</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; rect.<span class="built_in">GetY</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; rect.<span class="built_in">GetW</span>()</span><br><span class="line">         &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; rect.<span class="built_in">GetH</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The date of rect(X,Y,W,H):</span><br><span class="line">5,5,20,10</span><br></pre></td></tr></table></figure>
<h3 id="保护继承">保护继承</h3>
<p>在派生类中，<strong>基类的公有成员和保护成员全部成为派生类的保护成员</strong>。</p>
<p>派生类的新成员可以直接访问它们，而派生类的新成员<strong>不能</strong>直接访问基类的私有成员。在类外，<strong>派生类的对象不能访问基类的所有成员</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> <span class="comment">//基类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//公有成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InitP</span><span class="params">(<span class="type">float</span> xx = <span class="number">0</span>, <span class="type">float</span> yy = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        X = xx;</span><br><span class="line">        Y = yy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">float</span> xOff, <span class="type">float</span> yOff)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        X += xOff;</span><br><span class="line">        Y += yOff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> X; &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">//保护成员</span></span><br><span class="line">    <span class="type">float</span> X, Y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">protected</span> Point</span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//新增外部接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InitR</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">float</span> w, <span class="type">float</span> h)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">InitP</span>(x, y); <span class="comment">//派生类访问基类成员</span></span><br><span class="line">        W = w;</span><br><span class="line">        H = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">float</span> xOff, <span class="type">float</span> yOff)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Point::<span class="built_in">Move</span>(xOff, yOff);</span><br><span class="line">        <span class="comment">//显式访问基类成员</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Point::<span class="built_in">GetX</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Point::<span class="built_in">GetY</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetH</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> H; &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetW</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> W; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">//新增私有数据</span></span><br><span class="line">    <span class="type">float</span> W, H;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rectangle rect;           <span class="comment">//声明Rectangle类的对象</span></span><br><span class="line">    rect.<span class="built_in">InitR</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">20</span>, <span class="number">10</span>); <span class="comment">//设置矩形的数据</span></span><br><span class="line">    rect.<span class="built_in">Move</span>(<span class="number">3</span>, <span class="number">2</span>);          <span class="comment">//移动矩形位置</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The data of rect(X,Y,W,H):&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; rect.<span class="built_in">GetX</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; rect.<span class="built_in">GetY</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; rect.<span class="built_in">GetW</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; rect.<span class="built_in">GetH</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The data of rect(X,Y,W,H):</span><br><span class="line">5,5,20,10</span><br></pre></td></tr></table></figure>
<p>保护成员具有两面性，对外界（如主函数或非派生类的成员函数）而言是不可见的，但对于它的派生类则是可见的。</p>
<h3 id="私有继承">私有继承</h3>
<p>在派生类中，<strong>基类的公有成员和保护成员全部成为派生类的私有成员</strong>。</p>
<p>派生类的新成员可以直接访问它们，而派生类的新成员<strong>不能</strong>直接访问基类的私有成员。在类外，<strong>派生类的对象不能访问基类的所有成员</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> <span class="comment">//基类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//公有成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InitP</span><span class="params">(<span class="type">float</span> xx = <span class="number">0</span>, <span class="type">float</span> yy = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        X = xx;</span><br><span class="line">        Y = yy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">float</span> xOff, <span class="type">float</span> yOff)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        X += xOff;</span><br><span class="line">        Y += yOff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> X; &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>: <span class="comment">//保护成员</span></span><br><span class="line">    <span class="type">float</span> X, Y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">private</span> Point</span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//新增外部接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InitR</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">float</span> w, <span class="type">float</span> h)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">InitP</span>(x, y); <span class="comment">//派生类访问基类成员</span></span><br><span class="line">        W = w;</span><br><span class="line">        H = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">float</span> xOff, <span class="type">float</span> yOff)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Point::<span class="built_in">Move</span>(xOff, yOff);</span><br><span class="line">        <span class="comment">//显式访问基类成员</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Point::<span class="built_in">GetX</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Point::<span class="built_in">GetY</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetH</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> H; &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetW</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> W; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">//新增私有数据</span></span><br><span class="line">    <span class="type">float</span> W, H;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Rectangle rect;           <span class="comment">//声明Rectangle类的对象</span></span><br><span class="line">    rect.<span class="built_in">InitR</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">20</span>, <span class="number">10</span>); <span class="comment">//设置矩形的数据</span></span><br><span class="line">    rect.<span class="built_in">Move</span>(<span class="number">3</span>, <span class="number">2</span>);          <span class="comment">//移动矩形位置</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The data of rect(X,Y,W,H):&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; rect.<span class="built_in">GetX</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; rect.<span class="built_in">GetY</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; rect.<span class="built_in">GetW</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; rect.<span class="built_in">GetH</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The data of rect(X,Y,W,H):</span><br><span class="line">5,5,20,10</span><br></pre></td></tr></table></figure>
<p>不能在派生类构造函数体中显式调用基类构造函数来初始化基类成员！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> <span class="comment">//基类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">float</span> xx = <span class="number">0</span>, <span class="type">float</span> yy = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        X = xx;</span><br><span class="line">        Y = yy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Move</span><span class="params">(<span class="type">float</span> xOff, <span class="type">float</span> yOff)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        X += xOff;</span><br><span class="line">        Y += yOff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> X; &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> X, Y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Point</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">float</span> x, <span class="type">float</span> y, <span class="type">float</span> w, <span class="type">float</span> h) <span class="comment">//派生类构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Point</span>(x, y); <span class="comment">//调用基类构造函数</span></span><br><span class="line">        W = w;</span><br><span class="line">        H = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetH</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> H; &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetW</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> W; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> W, H;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Rectangle <span class="title">rect</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">20</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//声明Rectangle类的对象</span></span><br><span class="line">    rect.<span class="built_in">Move</span>(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">//移动矩形位置</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The date of rect(X,Y,W,H):&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; rect.<span class="built_in">GetX</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; rect.<span class="built_in">GetY</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; rect.<span class="built_in">GetW</span>() &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; rect.<span class="built_in">GetH</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The data of rect(X,Y,W,H):</span><br><span class="line">3,2,20,10</span><br></pre></td></tr></table></figure>
<h2 id="派生类的构造函数和析构函数">派生类的构造函数和析构函数</h2>
<h3 id="派生类的构造函数和析构函数-1">派生类的构造函数和析构函数</h3>
<p>解决的办法是通过成员初始化表来完成，在成员初始化表中可以显式调用基类构造函数对基类成员初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;派生类名&gt;(&lt;总参数表&gt;)：&lt;基类名&gt;(&lt;参数表1&gt;)，&lt;对象成员名&gt;(&lt;参数表2&gt;)</span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类数据成员的初始化&gt;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Rectangle</span>(<span class="type">float</span> x,<span class="type">float</span> y,<span class="type">float</span> w,<span class="type">float</span> h):<span class="built_in">Point</span>(x,y)</span><br><span class="line">&#123;W=w;H=h;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Rectangle</span>(<span class="type">float</span> x,<span class="type">float</span> y,<span class="type">float</span> w,<span class="type">float</span> h):<span class="built_in">Point</span>(x,y),<span class="built_in">W</span>(w),<span class="built_in">H</span>(h)&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数和析构函数的调用顺序-1">构造函数和析构函数的调用顺序</h3>
<p>构造函数调用顺序为：基类的构造函数→对象成员构造函数→派生类的构造函数。</p>
<p>析构函数调用顺序刚好相反。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A Constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A Destructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B Constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B Destructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A Constructor</span><br><span class="line">B Constructor</span><br><span class="line">B Destructor</span><br><span class="line">A Destructor</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;A Constructor1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        x1 = i;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A Constructor2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispa</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;x1=&quot;</span> &lt;&lt; x1 &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123; cout &lt;&lt; <span class="string">&quot;B Constructor1&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> i) : <span class="built_in">A</span>(i + <span class="number">10</span>) <span class="comment">//成员初始化表</span></span><br><span class="line">    &#123;</span><br><span class="line">        x2 = i;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B Constructor2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dispb</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">dispa</span>(); <span class="comment">//调用基类成员函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x2=&quot;</span> &lt;&lt; x2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    b.<span class="built_in">dispb</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A Constructor2</span><br><span class="line">B Constructor2</span><br><span class="line">x1=12</span><br><span class="line">x2=2</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>当基类中没有显式定义构造函数，或定义了无参构造函数时，派生类构造函数的初始化表可以省略对基类构造函数的调用，而采用<strong>隐含调用</strong>。</p>
<p>当基类的构造函数使用一个或多个参数时，<strong>派生类需要定义构造函数</strong>，提供将参数传递给基类构造函数的途径。这时，<strong>派生类构造函数的函数体可能为空</strong>，仅起到参数传递作用。</p>
<p>如果在基类中既定义了无参构造函数，又定义了带参构造函数，则在定义派生类构造函数时，既可以包含基类构造函数和参数，也可以不包含基类构造函数。</p>
<p>无论是哪种继承方式，基类的私有成员在派生类中都是不可被访问的。只能通过基类的成员函数访问基类的私有数据成员</p>
<p><strong>如果在一个派生类中要访问基类中的私有成员，可以将这个派生类声明为基类的友元。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">    friend class  Derive;</span><br><span class="line">     .....</span><br><span class="line">&#125;</span><br><span class="line">class Derive:public Base &#123;</span><br><span class="line">     ..... // 直接使用Base中的私有成员</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>友元关系是不能继承的。B类是A类的友元，C类是B类的派生类，则C类和A类之间没有任何友元关系，除非C类声明A类是友元。</p>
<h2 id="多继承与虚基类">多继承与虚基类</h2>
<p>一个类可以从一个或者多个基类派生而来。根据派生类继承基类的个数，将继承分为<strong>单</strong>继承和<strong>多</strong>继承。</p>
<p>当派生类有多个基类时称为多继承。单继承可以看作是多继承的一个特例，多继承可以看作是多个单继承的组合，它们有很多相同特性。</p>
<h3 id="多继承派生类的定义">多继承派生类的定义</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class &lt;派生类名&gt;：&lt;继承方式&gt; &lt;基类名1&gt;，…，&lt;继承方式&gt; &lt;基类名n&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &lt;派生类新定义成员&gt;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<h3 id="多继承派生类的构造函数">多继承派生类的构造函数</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;派生类名&gt;(&lt;总参数表&gt;):&lt;基类名1&gt;(&lt;参数表1&gt;)，…，&lt; 基类名n&gt; (&lt;参数表n&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    &lt;派生类数据成员的初始化&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><总参数表>包含完成所有基类初始化所需的参数</p>
<p>构造函数调用顺序是：先调用所有基类的构造函数，再调用对象成员类构造函数，最后调用派生类的构造函数。</p>
<p>处于同一层次的各基类构造函数的调用顺序取决于<strong>定义派生类时所指定的基类顺序</strong>，与派生类构造函数中所定义的成员初始化列表顺序无关。</p>
<p>如果有多个成员类对象，则构造函数的调用顺序是<strong>对象在类中被声明的顺序</strong>，而不是它们出现在成员初始化表中的顺序。</p>
<p>析构函数的调用顺序与构造函数的调用顺序相反。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        a = i;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A Destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> j)</span><br><span class="line">    &#123;</span><br><span class="line">        b = j;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">B</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B Destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> k) : <span class="built_in">A</span>(k + <span class="number">2</span>), <span class="built_in">B</span>(k - <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c = k;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C Constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">disp</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        A::<span class="built_in">disp</span>();</span><br><span class="line">        B::<span class="built_in">disp</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;c=&quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">C</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;C Destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">C <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    obj.<span class="built_in">disp</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">B Constructor</span><br><span class="line">A Constructor</span><br><span class="line">C Constructor</span><br><span class="line">a=12</span><br><span class="line">b=8</span><br><span class="line">c=10</span><br><span class="line">C Destructor</span><br><span class="line">A Destructor</span><br><span class="line">B Destructor</span><br></pre></td></tr></table></figure>
<h3 id="多继承引起的二义性问题">多继承引起的二义性问题</h3>
<h4 id="两个基类有同名成员">两个基类有同名成员</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="type">int</span> a ;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="type">int</span> a ;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="type">int</span> b ;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译错误</span></span><br><span class="line">C c1;</span><br><span class="line">c1.a=<span class="number">3</span>;</span><br><span class="line">c1.<span class="built_in">display</span>();</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确写法</span></span><br><span class="line">C c1;</span><br><span class="line">c1.A::a=<span class="number">3</span>;</span><br><span class="line">c1.A::<span class="built_in">display</span>();</span><br></pre></td></tr></table></figure>
<h4 id="两个基类和派生类三者都有同名成员">两个基类和派生类三者都有同名成员</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="type">int</span> a ;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="type">int</span> a ;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="type">int</span> a ;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//访问的是派生类C中的成员</span><br><span class="line">C c1;</span><br><span class="line">c1.a=3;</span><br><span class="line">c1.display();</span><br></pre></td></tr></table></figure>
<p>基类的同名成员在派生类中被屏蔽，或者说，派生类新增加的同名成员隐藏了基类中的同名成员</p>
<h4 id="如果类a和类b是从同一个基类派生的">如果类A和类B是从同一个基类派生的</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">N</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;A::a =&quot;</span> &lt;&lt; a &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> N</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="type">int</span> a1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> N</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="type">int</span> a2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="type">int</span> a3;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;a3 =&quot;</span>&lt;&lt; a3 &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="虚基类">虚基类</h3>
<p>为避免对基类成员访问的二义性问题，可以将<strong>直接基类（如A、B）的共同基类（如N）</strong>设置为<strong>虚基类</strong>，这样共同基类（N）在内存中只有一个副本存在。</p>
<p>虚基类的定义格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class &lt;派生类名&gt;:virtual &lt;继承方式&gt;&lt;共同基类名&gt;;</span><br></pre></td></tr></table></figure>
<p>【说明】引进虚基类后，派生类对象中只存在一个虚基类成员的副本。</p>
<p>为了保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类，否则仍然会出现对基类的多次继承。</p>
<p>【例】示例虚基类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; a = <span class="number">10</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A1</span>() &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A2</span>() &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : A1, A2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">10</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h4 id="构造函数的调用顺序">构造函数的调用顺序</h4>
<p>虚基类的初始化与一般多继承的初始化在语法上相同，但构造函数的调用顺序有所不同，规则如下：</p>
<ul>
<li>先调用虚基类的构造函数，再调用非虚基类的构造函数。</li>
<li>若同一层次中包含多个虚基类，其调用顺序为定义时的顺序。</li>
<li>若虚基类由非虚基类派生而来，则仍按先调用基类构造函数，再调用派生类构造函数的顺序。</li>
</ul>
<p>【例】示例多继承中有虚基类的情况，分析构造函数的调用顺序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Base1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Base2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Level1</span> : <span class="keyword">public</span> Base2, <span class="keyword">virtual</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Level1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Level1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Level2</span> : <span class="keyword">public</span> Base2, <span class="keyword">virtual</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Level2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Level2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TopLevel</span> : <span class="keyword">public</span> Level1, <span class="keyword">virtual</span> <span class="keyword">public</span> Level2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TopLevel</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class TopLevel&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TopLevel obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Base1</span><br><span class="line">class Base2</span><br><span class="line">class Level2</span><br><span class="line">class Base2</span><br><span class="line">class Level1</span><br><span class="line">class TopLevel</span><br></pre></td></tr></table></figure>
<h4 id="虚基类的初始化">虚基类的初始化</h4>
<p>如果在虚基类中只定义了带参数的构造函数，则要在其<strong>所有</strong>派生类（包括直接派生类或间接派生类）中，通过构造函数的初始化表对虚基类进行初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123; A(int i)&#123;&#125; … &#125;;</span><br><span class="line">class B:virtual public A</span><br><span class="line">&#123; B(int n):A(n)&#123;&#125;… &#125;;</span><br><span class="line">class C:virtual public A</span><br><span class="line">&#123; C(int n):A(n)&#123;&#125;… &#125;; </span><br><span class="line">class D:public B, public C</span><br><span class="line">&#123; D(int n):A(n),B(n),C(n)&#123;&#125;… &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>如果多继承不牵涉到对同一基类的派生，就没有必要定义虚基类。</p>
<p>使用多继承时要十分小心，经常会出现二义性问题。</p>
<p>能用单一继承解决的问题就不要使用多继承。</p>
<h2 id="测试-4">测试</h2>
<p>1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i, <span class="type">int</span> j)</span><br><span class="line">    &#123;</span><br><span class="line">        a = i;</span><br><span class="line">        b = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a += x;</span><br><span class="line">        b += y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k, <span class="type">int</span> l) : <span class="built_in">A</span>(i, j), <span class="built_in">x</span>(k), <span class="built_in">y</span>(l) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; <span class="built_in">move</span>(<span class="number">3</span>, <span class="number">5</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; A::<span class="built_in">show</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">aa</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    aa.<span class="built_in">show</span>();</span><br><span class="line">    <span class="function">B <span class="title">bb</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    bb.<span class="built_in">fun</span>();</span><br><span class="line">    bb.A::<span class="built_in">show</span>();</span><br><span class="line">    bb.B::<span class="built_in">show</span>();</span><br><span class="line">    bb.<span class="built_in">f1</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i, <span class="type">int</span> j) : <span class="built_in">a</span>(i), <span class="built_in">b</span>(j) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a += x;</span><br><span class="line">        b += y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">private</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k, <span class="type">int</span> l) : <span class="built_in">A</span>(i, j), <span class="built_in">x</span>(k), <span class="built_in">y</span>(l) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; <span class="built_in">move</span>(<span class="number">3</span>, <span class="number">5</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; A::<span class="built_in">show</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">aa</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    aa.<span class="built_in">show</span>();</span><br><span class="line">    <span class="function">B <span class="title">bb</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    bb.<span class="built_in">fun</span>();</span><br><span class="line">    bb.<span class="built_in">show</span>();</span><br><span class="line">    bb.<span class="built_in">f1</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">base</span>(<span class="type">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;constructing base  class &quot;</span> &lt;&lt; endl;</span><br><span class="line">        n = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;n=&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">base</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destructing base class &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">base1</span>(<span class="type">int</span> a)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;constructing base1 class &quot;</span> &lt;&lt; endl;</span><br><span class="line">        m = a;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m=&quot;</span> &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">base1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destructing base1 class &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">subs</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line">    base bobj;</span><br><span class="line">    base1 bobj1;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">subs</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span><br><span class="line">        : <span class="built_in">base</span>(a), <span class="built_in">bobj1</span>(b), <span class="built_in">bobj</span>(c)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;constructing sub class &quot;</span> &lt;&lt; endl;</span><br><span class="line">        x = d;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">subs</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destructing sub class &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">subs <span class="title">s</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多态性与虚函数">多态性与虚函数</h1>
<h2 id="类型兼容规则">类型兼容规则</h2>
<p><strong>类型兼容规则</strong>是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。</p>
<p>通过公有继承，派生类得到了基类中除构造函数、析构函数之外的所有成员。这样，<strong>公有派生类实际就具备了基类的所有功能</strong>，凡是基类能解决的问题，公有派生类都可以解决。</p>
<p>类型兼容规则中所指的替代包括以下情况： * 派生类的对象可以赋值给基类的对象。 * 派生类的对象可以初始化基类的引用。 * 派生类的对象的地址可以赋值给基类的指针变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;…&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;…&#125;;</span><br><span class="line">A a, *pa;</span><br><span class="line">B b;</span><br></pre></td></tr></table></figure>
<p>a=b; 派生类的对象可以赋值给基类的对象。即用派生类对象中从基类继承来的成员，逐个赋值给基类对象的成员。 * 只能用派生类对象对其基类对象赋值，而不能用基类对象对其派生类对象赋值。 * 同一基类的不同派生类对象之间也不能赋值。</p>
<p>A &amp;a1=b; 派生类的对象可以初始化基类的引用 。</p>
<p>pa=&amp;b; 派生类的对象的地址可以赋值给基类的指针变量 。</p>
<p>在替代之后，派生类对象就可以作为基类的对象使用，但<strong>只能访问从基类继承的成员</strong>。</p>
<p>对象只能调用转换后类型中定义的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BaseClass baseObject;</span><br><span class="line">DerivedClass derivedObject;</span><br><span class="line">baseObject=derivedObject;</span><br><span class="line"></span><br><span class="line">derivedObject.derivedFun(); 	√</span><br><span class="line">derivedObject.baseFun(); 		√</span><br><span class="line"></span><br><span class="line">baseObject.baseFun(); 			√</span><br><span class="line">baseObject.derivedFun(); 		×</span><br></pre></td></tr></table></figure>
<p>【例】示例类型兼容规则的应用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>        　　　　　</span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;   cout&lt;&lt;<span class="string">&quot;Base class&quot;</span>&lt;&lt;endl;   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive1</span>:<span class="keyword">public</span> Base    </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;   cout&lt;&lt;<span class="string">&quot;Derivel class&quot;</span>&lt;&lt;endl;   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive2</span>:<span class="keyword">public</span> Base   </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;   cout&lt;&lt;<span class="string">&quot;Derive2 class&quot;</span>&lt;&lt;endl;   &#125;</span><br><span class="line">&#125;;	</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Base obj1,*p;   </span><br><span class="line"><span class="comment">//定义基类对象obj1和基类对象指针p</span></span><br><span class="line">    Derive1 obj2;   </span><br><span class="line">    Derive2 obj3;   </span><br><span class="line">    p=&amp;obj1;        <span class="comment">//p指向obj1</span></span><br><span class="line">    p-&gt;<span class="built_in">who</span>();       </span><br><span class="line"><span class="comment">//通过指针p调用obj1的公有成员函数//who()</span></span><br><span class="line">    p=&amp;obj2;        <span class="comment">//p指向obj2</span></span><br><span class="line">    p-&gt;<span class="built_in">who</span>();       </span><br><span class="line"><span class="comment">//p只能访问从基类继承下来的who()</span></span><br><span class="line">    p=&amp;obj3;   　　 <span class="comment">//p指向obj2</span></span><br><span class="line">    p-&gt;<span class="built_in">who</span>();       </span><br><span class="line"><span class="comment">//p只能访问从基类继承下来的who()</span></span><br><span class="line">    obj2.<span class="built_in">who</span>();</span><br><span class="line">    obj3.<span class="built_in">who</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base class</span><br><span class="line">Base class</span><br><span class="line">Base class</span><br><span class="line">Derive1 class</span><br><span class="line">Derive2 class</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> n) &#123; num = n; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graduate</span> : <span class="keyword">public</span> Student</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Graduate</span>(<span class="type">int</span> n, string name) : <span class="built_in">Student</span>(n), <span class="built_in">name</span>(name)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Student::<span class="built_in">display</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">stud1</span><span class="params">(<span class="number">1001</span>)</span></span>;</span><br><span class="line">    <span class="function">Graduate <span class="title">grad1</span><span class="params">(<span class="number">2001</span>, <span class="string">&quot;Wang&quot;</span>)</span></span>;</span><br><span class="line">    Student *pt = &amp;stud1;</span><br><span class="line">    pt-&gt;<span class="built_in">display</span>();</span><br><span class="line">    pt = &amp;grad1;</span><br><span class="line">    pt-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num:1001</span><br><span class="line">num:2001</span><br></pre></td></tr></table></figure>
<p>如果基类指针要访问派生类的成员函数，怎么办？</p>
<p>C++提供了多态机制来解决这个问题。</p>
<p>类型兼容规则是C++多态的重要基础。</p>
<h2 id="多态">多态</h2>
<p>多态（Polymorphism）是指具有相似功能的不同函数使用同一个名称来实现，从而可以使用相同的调用方式来调用这些具有不同功能的同名函数的特性。</p>
<p>调用同一个函数名，可以根据需要实现不同的功能。</p>
<p>从系统实现的角度，多态性分为两类：</p>
<p><strong>静态多态性</strong>：在程序编译时系统就能决定调用的是哪个函数。又称为编译时的多态性。静态多态性是通过函数的重载实现的（包括运算符重载）。</p>
<p><strong>动态多态性</strong>：在程序运行过程中才动态地确定操作所针对的对象。又称为运行时的多态性。动态多态性是通过虚函数实现的。</p>
<h2 id="联编">联编</h2>
<p>C++采用联编技术来支持多态。</p>
<p>联编是指把一个标识符名和一个存储地址联系在一起的过程。在多态的实现过程中，确定调用哪个同名函数的过程就是联编，又称绑定。</p>
<h3 id="联编的分类">联编的分类</h3>
<ul>
<li>按照联编进行的阶段来划分</li>
<li>静态联编：在<strong>编译阶段</strong>完成的联编，即在编译时确定调用哪个函数代码，通常在重载时使用。静态联编支持编译时多态。</li>
<li>动态联编：动态联编是指在程序执行之前，根据函数名和参数无法确定应该调用哪一个函数，必须在程序的执行过程中，<strong>根据具体的执行情况来动态地确定</strong>。在<strong>运行阶段</strong>完成的联编，通过继承和虚函数来实现。动态联编支持运行时多态。</li>
</ul>
<p><img data-src="image-20201201141728018.png" alt="image-20201201141728018" style="zoom:50%;" /></p>
<p>【例】静态联编示例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A student&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GStudent</span> : <span class="keyword">public</span> Student</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A graduate student&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student s1, *ps;</span><br><span class="line">    GStudent s2;</span><br><span class="line">    s1.<span class="built_in">print</span>();</span><br><span class="line">    s2.<span class="built_in">print</span>();</span><br><span class="line">    s2.Student::<span class="built_in">print</span>();</span><br><span class="line">    ps = &amp;s1;</span><br><span class="line">    ps-&gt;<span class="built_in">print</span>(); <span class="comment">//基类指针和基类成员函数发生关联</span></span><br><span class="line">    ps = &amp;s2;</span><br><span class="line">    ps-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="comment">//希望调用对象s2的输出函数，但调用的却是对象s1的输出函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A student</span><br><span class="line">A graduate student</span><br><span class="line">A student</span><br><span class="line">A student</span><br><span class="line">A student</span><br></pre></td></tr></table></figure>
<h2 id="虚函数">虚函数</h2>
<p>由虚函数实现的动态多态：同一类族中不同类的对象，对同一函数调用做出不同的响应。</p>
<p>虚函数的使用：</p>
<ul>
<li>类之间应满足类型兼容规则。</li>
<li>同名声明虚函数。</li>
<li>通过指针、引用来访问虚函数。</li>
</ul>
<p>虚函数就是在基类中被关键字virtual说明、并在一个或多个派生类中被重新定义的成员函数。</p>
<p>声明虚函数的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual &lt;函数值类型&gt; &lt;函数名&gt;(&lt;参数表&gt;);</span><br></pre></td></tr></table></figure>
<p>若要访问派生类中相同名字的函数，必须将基类中的<strong>同名函数定义为虚函数</strong>，这样，将不同的派生类对象的地址赋给基类的指针变量后，就可以<strong>动态地根据这种赋值语句调用不同类中的函数</strong>。</p>
<p>在程序运行时，不同类的对象调用各自的虚函数，这就是动态多态。</p>
<p>实现动态的多态性时，必须使用<strong>基类类型的指针变量</strong>或<strong>对象引用</strong>，并使其<strong>指向不同的派生类对象</strong>，并通过调用指针或引用所指向的虚函数才能实现动态的多态性。</p>
<p>【例】动态联编示例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="comment">//定义虚函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A student&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GStudent</span> : <span class="keyword">public</span> Student</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A graduate student&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student s1, *ps;</span><br><span class="line">    GStudent s2;</span><br><span class="line">    s1.<span class="built_in">print</span>();</span><br><span class="line">    s2.<span class="built_in">print</span>();</span><br><span class="line">    s2.Student::<span class="built_in">print</span>();</span><br><span class="line">    ps = &amp;s1;</span><br><span class="line">    ps-&gt;<span class="built_in">print</span>();</span><br><span class="line">    ps = &amp;s2;</span><br><span class="line">    ps-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="comment">//对象指针调用虚函数，采用动态联编方式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A student</span><br><span class="line">A graduate student</span><br><span class="line">A student</span><br><span class="line">A student</span><br><span class="line">A graduate student</span><br></pre></td></tr></table></figure>
<p>一个函数一旦被声明为虚函数，则无论声明它的类被继承了多少层，在每一层派生类中该函数都保持虚函数特性。因此，在派生类中重新定义该函数时，可以省略关键字virtual。</p>
<p>如果将上例中的Student类改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>; 　<span class="comment">//虚函数的声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Student::print</span><span class="params">()</span> <span class="comment">//虚函数的实现  X</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A student&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当虚函数声明与实现分开时，virtual关键字只用在虚函数的声明中，不能用在虚函数的实现中。</p>
<p>只有通过<strong>对象指针或对象引用</strong>来调用虚函数，才能实现动态联编。如果采用对象来调用虚函数，则采用的是静态联编方式。</p>
<p>在派生类中重新定义虚函数时，其函数原型包括返回类型、函数名、参数个数、类型和顺序，都<strong>必须</strong>与基类中的原型<strong>相同</strong>。</p>
<p>【例】采用对象引用调用虚函数，进而实现动态联编。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="comment">//定义虚函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A student&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GStudent</span> : <span class="keyword">public</span> Student</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A graduate student&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Student &amp;s)</span> <span class="comment">//对象引用作参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.<span class="built_in">print</span>(); <span class="comment">//采用对象引用调用虚函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student s1;</span><br><span class="line">    GStudent s2;</span><br><span class="line">    <span class="built_in">fun</span>(s1);</span><br><span class="line">    <span class="built_in">fun</span>(s2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A student</span><br><span class="line">A graduate student</span><br></pre></td></tr></table></figure>
<p>示例使用不恰当的虚函数的效果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is Base class &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subclass</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//编译错误</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is Sub class &quot;</span>;</span><br><span class="line">        <span class="type">float</span> y = <span class="built_in">float</span>(x);</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(Base &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; x.<span class="built_in">func</span>(<span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base bc;</span><br><span class="line">    Subclass sc;</span><br><span class="line">    <span class="built_in">test</span>(bc);</span><br><span class="line">    <span class="built_in">test</span>(sc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要定义一个基类的对象指针或对象引用，就可以调用期望的虚函数。</p>
<p>在实际应用中，不必过多地考虑类的层次关系，无须显式地写出虚函数的路径，只须将对象指针指向相应的派生类或引用相应的对象，通过动态联编就可以对消息做出正确的反应。</p>
<p><strong>虚函数小结</strong></p>
<p>如果期望在派生类中重新定义一个成员函数，那么就应该在基类中把该函数设为virtual。</p>
<p>以单一指令调用不同函数，这种性质就是“多态”。</p>
<p>虚函数是C++语言的多态性质和动态绑定的关键。</p>
<p>虚函数派生下去仍是虚函数，而且可以省略virtual关键词。</p>
<p><strong>声明虚函数时要注意</strong></p>
<p>一般来说，可将类簇中具有共性的成员函数声明为虚函数，而具有个性的函数没有必要声明为虚函数。但是下面的情况例外：</p>
<ul>
<li><strong>静态成员函数和友元函数不能声明为虚函数</strong>。因为静态成员函数和友元函数不属于某一个对象，没有多态性的特征。</li>
<li><strong>内联成员函数不能声明为虚函数</strong>。因为内联函数的执行代码是明确的，在编译时已被替换，没有多态性的特征。如果将那些在类声明时就定义内容的成员函数声明为虚函数，此时函数不是内联函数，而以多态性出现。</li>
<li><strong>构造函数不能是虚函数</strong>。构造函数是在定义对象时被调用，完成对象的初始化，此时对象还没有完全建立。虚函数作为运行时的多态性的基础，主要是针对对象的，而构造函数是在对象产生之前运行的。所以，将构造函数声明为虚函数是没有意义的。</li>
<li><strong>析构函数可以是虚函数</strong>。比如释放内存时，由于实施多态性时是通过将基类的指针指向派生类的对象来完成的，如果删除该指针，就会调用该指针指向的派生类的析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象才被完全释放。</li>
</ul>
<h3 id="虚析构函数">虚析构函数</h3>
<p>虚析构函数的声明格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚析构函数的声明格式如下：</span><br></pre></td></tr></table></figure>
<p>如果一个类的析构函数是虚函数，那么，由它派生的所有子类的析构函数也是虚函数。</p>
<p>【例】虚析构函数示例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot; Base destructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; cout &lt;&lt; <span class="string">&quot;Derived destructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *b = <span class="keyword">new</span> Derived;</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base destructor</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; cout &lt;&lt; <span class="string">&quot;Base destructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123; cout &lt;&lt; <span class="string">&quot;Derived destructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *b = <span class="keyword">new</span> Derived;</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived destructor</span><br><span class="line">Base destructor</span><br></pre></td></tr></table></figure>
<p>利用虚函数可以使所设计的软件系统变得灵活，提高了代码的可重用性。</p>
<p>虚函数为一个类簇中所有派生类的同一行为提供了统一的接口，使得程序员在使用一个类簇时只须记住一个接口即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> X, Y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> X = <span class="number">0</span>, <span class="type">int</span> Y = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;X = X, <span class="keyword">this</span>-&gt;Y = Y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="comment">//求面积</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Point</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> radius; <span class="comment">//半径</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">int</span> X, <span class="type">int</span> Y, <span class="type">double</span> R) : <span class="built_in">Point</span>(X, Y)</span><br><span class="line">    &#123;</span><br><span class="line">        radius = R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="comment">//求面积</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">P1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;P1.area()=&quot;</span> &lt;&lt; P1.<span class="built_in">area</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="function">Circle <span class="title">C1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;C1.area()=&quot;</span> &lt;&lt; C1.<span class="built_in">area</span>() &lt;&lt; endl;</span><br><span class="line">    Point *Pp;</span><br><span class="line">    Pp = &amp;C1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pp-&gt;area()=&quot;</span> &lt;&lt; Pp-&gt;<span class="built_in">area</span>() &lt;&lt; endl;</span><br><span class="line">    Point &amp;Rp = C1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Rp.area()=&quot;</span> &lt;&lt; Rp.<span class="built_in">area</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P1.area()=0</span><br><span class="line">C1.area()=1256.64</span><br><span class="line">Pp-&gt;area()=1256.64</span><br><span class="line">Rp.area()=1256.64</span><br></pre></td></tr></table></figure>
<p>当在派生类中定义了虚函数的重载函数，但并没有重新定义虚函数时，与虚函数同名的重载函数<strong>覆盖</strong>了派生类中的虚函数。此时试图通过派生类对象、指针、引用调用派生类的虚函数就会产生错误。</p>
<p>将上例中Circle类的double area( )改为:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="keyword">return</span> PI*radius*radius;&#125;</span><br></pre></td></tr></table></figure>
<p>那么virtual double area( ) 被double area(int i)覆盖，下面调用形式是<strong>错误</strong>的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Circle C1;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;C1.area( )=&quot;</span>&lt;&lt;C1.<span class="built_in">area</span>( )&lt;&lt;endl;</span><br><span class="line">Circle *Pp1=&amp;C1;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Pp1-&gt;area( )=&quot;</span>&lt;&lt;Pp1-&gt;<span class="built_in">area</span>( )&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>不改变Circle类中原来的虚函数，并加入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="keyword">return</span> PI*radius*radius;&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果与原来例子结果相同。</p>
<p>如果在派生类中没有重新定义虚函数，则不实现动态联编，派生类的对象将使用基类的虚函数代码。</p>
<p>在Circle类不定义任何area函数, 程序运行的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P1.area()=0</span><br><span class="line">C1.area()=0        // 调用了基类的virtual double area()</span><br><span class="line">Pp-&gt;area()=0       // 调用了基类的virtual double area()</span><br><span class="line">Rp.area()=0        // 调用了基类的virtual double area()</span><br></pre></td></tr></table></figure>
<h2 id="继承虚属性">继承虚属性</h2>
<p>基类中说明的虚函数具有<strong>自动向下</strong>传给它的派生类的性质。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is Base class &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subclass1</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is Sub1 class &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subclass2</span> : <span class="keyword">public</span> Subclass1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;This is Sub2 class &quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Subclass2 sc2;</span><br><span class="line">    Base &amp;bc = sc2;</span><br><span class="line">    cout &lt;&lt; bc.<span class="built_in">func</span>(<span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    Subclass1 &amp;sc1 = sc2;</span><br><span class="line">    cout &lt;&lt; sc1.<span class="built_in">func</span>(<span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is Base class 5</span><br><span class="line">This is Sub2 class 5</span><br></pre></td></tr></table></figure>
<p>一个类中的虚函数说明只对派生类中重定义的函数有影响，<strong>对</strong>它的<strong>基类中的函数并没有影响</strong>。</p>
<h2 id="纯虚函数">纯虚函数</h2>
<p>纯虚函数用<strong>virtual</strong>声明，<strong>没有任何实现</strong>、必须由派生类重新定义该函数提供实现</p>
<p>纯虚函数的声明格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual &lt;函数值类型&gt; &lt;函数名&gt;(&lt;参数表&gt;)=0;</span><br></pre></td></tr></table></figure>
<p>纯虚函数不需要定义实现方法，它的存在只是为了在派生类中被重新定义，只是为了提供一个多态的接口。</p>
<h2 id="抽象类">抽象类</h2>
<p>包含一个或多个纯虚函数的类称为抽象类。</p>
<p>如果派生类没有实现基类中的所有纯虚函数，派生类也是抽象类。</p>
<p>抽象类无法实例化，即不能创建抽象类的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Base base1; ×</span><br></pre></td></tr></table></figure>
<p>抽象类不能用作<strong>参数类型、函数值类型或显式转换的类型</strong>，但可以声明指向抽象类的指针或引用，通过指针或引用来指向并访问派生类对象，从而实现动态多态。</p>
<h2 id="纯虚函数与函数体为空的虚函数">纯虚函数与函数体为空的虚函数</h2>
<p>区别：</p>
<ul>
<li>前者没有函数体,而后者有函数体；</li>
<li>前者所在的类是抽象类,不能直接进行实例化,而后者所在的类是可以实例化的。</li>
</ul>
<p>共同点：</p>
<ul>
<li>可以派生出新的类，然后在新类中给出虚函数新的实现，而且这种新的实现可以具有多态特征。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123; <span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123; x = <span class="number">1000</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//定义纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123; <span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123; y = <span class="number">2000</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;y=&quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125; <span class="comment">//重新定义纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123; <span class="comment">//派生类</span></span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>() &#123; z = <span class="number">3000</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;z=&quot;</span> &lt;&lt; z &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; &#125; <span class="comment">//重新定义纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *pa;</span><br><span class="line">    B b;</span><br><span class="line">    C c;</span><br><span class="line">    pa = &amp;b;</span><br><span class="line">    pa-&gt;<span class="built_in">print</span>();</span><br><span class="line">    pa = &amp;c;</span><br><span class="line">    pa-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="comment">// A  a;     pa=&amp;a;       pa-&gt;print(); 不能定义抽象类的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y=2000</span><br><span class="line">z=3000</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<ul>
<li><p>在定义纯虚函数时，不能定义虚函数的实现部分。</p></li>
<li><p>纯虚函数只有函数的名字而不具备函数的功能，<strong>在没有重新定义这种纯虚函数之前，不能调用这种函数</strong>。</p></li>
<li><p>抽象类只能作为派生类的基类，不能用来说明这种类的对象。</p></li>
<li><p>在以抽象类作为基类的派生类中必须有纯虚函数的实现部分，即必须有重定义纯虚函数的函数体。否则，这样的派生类也是抽象类，不能产生对象。</p></li>
</ul>
<p>【例】示例纯虚函数及抽象类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shapes</span> <span class="comment">//抽象类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setvalue</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> w = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = d;</span><br><span class="line">        y = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">//纯虚函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> : <span class="keyword">public</span> Shapes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">area</span><span class="params">()</span> <span class="comment">//计算矩形面积</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;area of rectangle:&quot;</span> &lt;&lt; x * y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shapes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">area</span><span class="params">()</span> <span class="comment">//计算圆面积</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;area of circle:&quot;</span> &lt;&lt; PI * x * x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shapes *ptr[<span class="number">2</span>]; <span class="comment">//声明抽象类指针</span></span><br><span class="line">    Square s1;      <span class="comment">//声明派生类对象</span></span><br><span class="line">    Circle c1;      <span class="comment">//声明派生类对象</span></span><br><span class="line">    ptr[<span class="number">0</span>] = &amp;s1;</span><br><span class="line">    <span class="comment">//抽象类指针指向派生类对象</span></span><br><span class="line">    ptr[<span class="number">0</span>]-&gt;<span class="built_in">setvalue</span>(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">    ptr[<span class="number">0</span>]-&gt;<span class="built_in">area</span>();</span><br><span class="line">    <span class="comment">//抽象类指针调用派生类成员函数,实现多态</span></span><br><span class="line">    ptr[<span class="number">1</span>] = &amp;c1;</span><br><span class="line">    <span class="comment">//抽象类指针指向派生类对象</span></span><br><span class="line">    ptr[<span class="number">1</span>]-&gt;<span class="built_in">setvalue</span>(<span class="number">10</span>);</span><br><span class="line">    ptr[<span class="number">1</span>]-&gt;<span class="built_in">area</span>();</span><br><span class="line">    <span class="comment">//抽象类指针调用派生类成员函数,实现多态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">area of rectangle:50</span><br><span class="line">area of circle:314.159</span><br></pre></td></tr></table></figure>
<p>【例】示例抽象类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B0</span> <span class="comment">//抽象类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">//外部接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B1</span> : <span class="keyword">public</span> B0 <span class="comment">//公有派生</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B1::display()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D1</span> : <span class="keyword">public</span> B1 <span class="comment">//公有派生</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;D1::display()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(B0 *ptr)</span> <span class="comment">//普通函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ptr-&gt;<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B0 *p; <span class="comment">//声明抽象基类指针</span></span><br><span class="line">    B1 b1; <span class="comment">//声明派生类对象</span></span><br><span class="line">    D1 d1; <span class="comment">//声明派生类对象</span></span><br><span class="line">    p = &amp;b1;</span><br><span class="line">    <span class="comment">//抽象类指针指向派生类对象</span></span><br><span class="line">    <span class="built_in">f1</span>(p);</span><br><span class="line">    <span class="comment">//调用派生类B1的成员函数display()</span></span><br><span class="line">    p = &amp;d1;</span><br><span class="line">    <span class="comment">//抽象类指针指向派生类对象</span></span><br><span class="line">    <span class="built_in">f1</span>(p);</span><br><span class="line">    <span class="comment">//调用派生类D1的成员函数display()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B1::display()</span><br><span class="line">D1::display()</span><br></pre></td></tr></table></figure>
<h2 id="测试-5">测试</h2>
<p>1.指出下面程序中的错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D1</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;D1 class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span> : B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;D2 class&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B obj1, *p;</span><br><span class="line">    D1 obj2;</span><br><span class="line">    D2 obj3;</span><br><span class="line">    obj1 = obj2;     <span class="comment">//（A）</span></span><br><span class="line">    obj2.B::<span class="built_in">print</span>(); <span class="comment">//（B）</span></span><br><span class="line">    p = &amp;obj2;       <span class="comment">//（C）</span></span><br><span class="line">    p-&gt;<span class="built_in">print</span>();</span><br><span class="line">    p = &amp;obj3; <span class="comment">//（D）</span></span><br><span class="line">    p-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(D)'B' is an inaccessible base of 'D2'</p>
<p>2.写出下面程序的运行结果。如果将Point类的area()函数定义为虚函数，其运行结果是什么？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x1, <span class="type">int</span> y1)</span><br><span class="line">    &#123;</span><br><span class="line">        x = x1;</span><br><span class="line">        y = y1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rect</span> : <span class="keyword">public</span> Point</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rect</span>(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> u1, <span class="type">int</span> w1) : <span class="built_in">Point</span>(x1, y1)</span><br><span class="line">    &#123;</span><br><span class="line">        u = u1;</span><br><span class="line">        w = w1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> u * w; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> u, w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(Point &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; p.<span class="built_in">area</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Rect <span class="title">rec</span><span class="params">(<span class="number">2</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="built_in">fun</span>(rec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为0</p>
<p>若定义为虚函数，输出为60</p>
<h1 id="输入输出流">输入输出流</h1>
<h2 id="流">流</h2>
<h3 id="分析问题">分析问题</h3>
<p>C++没有定义任何用于执行输入或输出的语句，但可以使用C语言中的标准I/O函数printf()和scanf()来解决此问题。</p>
<p>printf()与scanf()存在两个缺点： * 非类型安全 * 不可扩充性</p>
<p>C++使用类型安全的I/O流操作。不同类型的I/O流操作都是重载的，没有定义过I/O功能的类型不具备I/O操作的能力。</p>
<p>通过修改和扩充，C++既可作为标准数据类型数据的I/O，也能用于自定义类型的对象的I/O，这种扩展性是C++最有价值的特点之一。</p>
<p>C++用输入输出流来解决这个问题。</p>
<h3 id="流-1">流</h3>
<p>所谓流（stream）是指数据从一个位置流向另一个位置。流是字节的序列。</p>
<p>输入／输出是一种数据传递操作，可以看作字符序列在计算机内存与外设之间的流动，C++将数据从一个对象到另一个对象的流动抽象为“流”。流动的方向不同，构成输入/输出流，即I/O流。</p>
<h3 id="io流">I/O流</h3>
<p>在C++程序中，数据可以从键盘流入到程序，也可以从程序流向屏幕或磁盘文件。从流中获取数据的操作称为<strong>提取操作</strong>，向流中添加数据的操作称为<strong>插入操作</strong>。</p>
<p>数据的输入/输出就是通过I/O流来实现的。</p>
<p>编译系统已经以<strong>运算符或函数</strong>的形式做好了对标准外设（<strong>键盘、屏幕、文件</strong>）的接口，使用时只需按照要求的格式调用即可。</p>
<h3 id="io流类库的层次结构">I/O流类库的层次结构</h3>
<p><img data-src="image-20201201143609221.png" alt="image-20201201143609221" style="zoom:50%;" /></p>
<h3 id="io流类库的头文件">I/O流类库的头文件</h3>
<p><strong>iostream</strong>:I/O流类库的最主要的头文件，包含了对输入输出流进行操作所需的基本信息，还包括cin、cout、cerr和clog共4个流对象。</p>
<p><strong>fstream</strong>:用于用户管理的文件的I/O操作。</p>
<p><strong>strstream</strong>:用于字符串流I/O。</p>
<p><strong>stdiostream</strong>:用于混合使用C和C++的I/O操作。</p>
<p><strong>iomanip</strong>:使用格式化I/O时应包含此头文件。</p>
<h2 id="无格式输入输出">无格式输入/输出</h2>
<p>无格式输入/输出就是按系统预定义的格式进行的输入/输出。</p>
<p>按默认约定，每个C++程序都能使用标准I/O流，如标准输入、标准输出。</p>
<ul>
<li><p><strong>cin</strong>用来处理标准输入，即键盘输入；cout用来处理标准输出，即屏幕输出。它们被定义在<strong>iostream</strong>头文件中。</p></li>
<li><p>在使用cout和cin前，要用编译预处理命令将所使用的头文件包含到源程序中，其格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="无格式输出">无格式输出</h3>
<p>“&lt;&lt;”是预定义的插入运算符，作用在流类对象cout上，实现默认格式的屏幕输出。使用cout输出表达式值到屏幕上的格式如下： <strong>cout&lt;&lt;E1&lt;&lt;E2&lt;&lt;…&lt;&lt;Em;</strong><br />
其中，E1、E2、…、Em为均为表达式。</p>
<p>用“cout&lt;&lt;”输出基本类型的数据时，可以不必考虑数据是什么类型，系统会判断数据的类型，并调用与之匹配的运算符重载函数。</p>
<p>cout是ostream流类的对象，它在iostream头文件中作为全局对象定义，其格式如下： ostream cout(stdout); 其中，stdout表示标准输出设备名（屏幕）。</p>
<h3 id="无格式输入">无格式输入</h3>
<p>“&gt;&gt;”是预定义的提取运算符，作用在流类对象cin上，实现默认格式的键盘输入。使用cin将数据输入到变量的格式如下： <strong>cin&gt;&gt;V1&gt;&gt;V2&gt;&gt;…&gt;&gt;Vn;</strong><br />
其中，V1、V2、…、Vn都是变量。功能是暂停执行程序，等待用户从键盘输入数据，各数据间用空格或Tab键分隔，输入数据类型要与接受变量类型一致，输完后，按回车键结束。</p>
<p>cin是istream流类的对象，它在iostream头文件中作为全局对象定义，其格式如下： istream cin(stdin); 其中，stdin表示标准输入设备名（键盘）。</p>
<h3 id="输入输出的格式控制">输入输出的格式控制</h3>
<p>C++提供了两种格式化输入/输出方式： * 一种是用流对象的有关成员函数进行格式化输入输出。 * 另一种是用专门的控制符进行格式化输入输出。</p>
<h3 id="用流对象的成员函数格式化">用流对象的成员函数格式化</h3>
<p>流成员函数主要是通过对状态标志、输出宽度、填充字符以及输出精度的操作来完成输入/输出格式化。</p>
<p>输入/输出的格式由各种状态标志来确定，在ios类中定义为枚举量。</p>
<p>枚举量定义在ios类中，因此引用时必须包含<strong>ios</strong>::前缀。使用时应该全部用符号名，绝不要用数值。</p>
<h3 id="用流对象的成员函数对状态标志进行操作">用流对象的成员函数对状态标志进行操作</h3>
<p>ios类有3个成员函数可以对状态标志进行操作，并且定义了一个long型数据成员记录当前状态标志。这些状态标志可用位或运算符“|”进行组合。</p>
<p>这三个函数必须用流类对象（cin或cout）来调用。</p>
<p>用setf函数设置状态标志， 其一般格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">ios::setf</span><span class="params">(<span class="type">long</span> flags)</span></span></span><br></pre></td></tr></table></figure>
<p>用unsetf函数清除状态标志，其一般格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">ios::unsetf</span><span class="params">(<span class="type">long</span> flags)</span></span></span><br></pre></td></tr></table></figure>
<p>用函数flags取状态标志有两种形式，其格式分别如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">ios::flags</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure>
<p>返回与流相关的当前状态标志值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">ios::flags</span><span class="params">(<span class="type">long</span> flag)</span></span></span><br></pre></td></tr></table></figure>
<p>将流的状态标志值设置为flag，并返回设置前的状态标志值。</p>
<p>以上三组函数必须用流类对象（cin或cout）来调用，其格式如下： <流对象名>.<函数名>(ios::<状态标志>)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">setf</span>(ios::showpos);</span><br><span class="line">cout.<span class="built_in">setf</span>(ios::scientific);</span><br><span class="line">cout.<span class="built_in">setf</span>(ios::showpos| ios::scientific);</span><br></pre></td></tr></table></figure>
<p>【例】　示例对状态标志的操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showflags</span><span class="params">(<span class="type">long</span> f)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> f;</span><br><span class="line">    f = cout.<span class="built_in">flags</span>();                                       <span class="comment">//取当前状态标志</span></span><br><span class="line">    <span class="built_in">showflags</span>(f);                                           <span class="comment">//显示状态值</span></span><br><span class="line">    cout.<span class="built_in">setf</span>(ios::showpos | ios::scientific | ios::fixed); <span class="comment">//追加状态标志</span></span><br><span class="line">    f = cout.<span class="built_in">flags</span>();                                       <span class="comment">//取当前状态标志</span></span><br><span class="line">    <span class="built_in">showflags</span>(f);                                           <span class="comment">//显示状态值</span></span><br><span class="line">    cout.<span class="built_in">unsetf</span>(ios::scientific);                           <span class="comment">//从状态标志中去掉 scientific</span></span><br><span class="line">    f = cout.<span class="built_in">flags</span>();                                       <span class="comment">//取当前状态标志</span></span><br><span class="line">    <span class="built_in">showflags</span>(f);                                           <span class="comment">//显示状态值</span></span><br><span class="line">    f = cout.<span class="built_in">flags</span>(ios::hex);                               <span class="comment">//重新设置状态标志</span></span><br><span class="line">    <span class="built_in">showflags</span>(f);</span><br><span class="line">    f = cout.<span class="built_in">flags</span>(); <span class="comment">//取当前状态标志</span></span><br><span class="line">    <span class="built_in">showflags</span>(f);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showflags</span><span class="params">(<span class="type">long</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0x8000</span>; i; i = i &gt;&gt; <span class="number">1</span>) <span class="comment">//用右移方式使i中的值为&quot;1&quot;的位不断右移</span></span><br><span class="line">        <span class="keyword">if</span> (i &amp; f)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;1&quot;</span>; <span class="comment">//判断f中的某一位是否为&quot;1&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000001000000001</span><br><span class="line">0011001000100001</span><br><span class="line">0010001000100001</span><br><span class="line">0010001000100001</span><br><span class="line">0000100000000000</span><br></pre></td></tr></table></figure>
<h3 id="用流对象的成员函数设置输出宽度">用流对象的成员函数设置输出宽度</h3>
<p>设置输出宽度函数有两种形式，其格式分别如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ios::width</span><span class="params">(<span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ios::width</span><span class="params">()</span>       </span></span><br></pre></td></tr></table></figure>
<p>第一种形式是设置输出宽度，并返回原来的输出宽度；第二种形式是返回当前输出宽度，默认输出宽度为0。</p>
<p>只对其后的第一个输出项有效。</p>
<h3 id="设置填充字符">设置填充字符</h3>
<p>填充字符的作用是当输出值不满输出宽度时用填充字符来填充，默认填充字符为空格。它与width()函数配合使用，否则没有意义。</p>
<p>设置填充字符函数有两种形式，其格式分别如下： char ios::fill(char ch) char ios::fill()</p>
<p>第一种形式是重新设置填充字符，并返回设置前的填充字符；第二种形式是返回当前的填充字符。</p>
<h3 id="设置输出精度">设置输出精度</h3>
<p>设置浮点数输出精度有两种形式，其格式分别如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ios::precision</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ios::precision</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>第一种形式是重新设置输出精度，并返回设置前的输出精度；第二种形式是返回当前的输出精度。默认输出精度为6 。</p>
<h3 id="用流成员函数put输出字符">用流成员函数put输出字符</h3>
<p>ostream类除了提供用于格式控制的成员函数外，还提供了专用于输出单个字符的成员函数put。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout.<span class="built_in">put</span>(‘a’);  </span><br><span class="line">cout.<span class="built_in">put</span>(<span class="number">97</span>);</span><br><span class="line">cout.<span class="built_in">put</span>(<span class="number">71</span>).<span class="built_in">put</span>(<span class="number">79</span>);</span><br></pre></td></tr></table></figure>
<p>【例】 示例设置输出宽度、填充字符、输出精度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    i = cout.<span class="built_in">width</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;width:&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">8</span>);</span><br><span class="line">    cout &lt;&lt; cout.<span class="built_in">width</span>() &lt;&lt; <span class="string">&quot;(new width)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    c = cout.<span class="built_in">fill</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;filling word is:&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;(ASCII code&quot;</span> &lt;&lt; (<span class="type">int</span>)c &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout.<span class="built_in">fill</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; cout.<span class="built_in">fill</span>() &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; (<span class="type">int</span>)cout.<span class="built_in">fill</span>() &lt;&lt; <span class="string">&quot;)(new filling word)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    j = cout.<span class="built_in">precision</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;precision:&quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">8</span>);</span><br><span class="line">    cout &lt;&lt; <span class="number">123.456789</span> &lt;&lt; <span class="string">&quot;(example)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; cout.<span class="built_in">precision</span>() &lt;&lt; <span class="string">&quot;(new precision)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">width:0</span><br><span class="line">       8(new width)</span><br><span class="line">filling word is: (ASCII code32)</span><br><span class="line">*(42)(new filling word)</span><br><span class="line">precision:6</span><br><span class="line">123.45679(example)</span><br><span class="line">8(new precision)</span><br></pre></td></tr></table></figure>
<h3 id="用于字符输入的流成员函数">用于字符输入的流成员函数</h3>
<h4 id="用get函数读入一个字符">用get函数读入一个字符</h4>
<p>(1)不带参数的get函数</p>
<ul>
<li>cin.get()用来从指定的输入流中提取一个字符（包括空白字符），函数的返回值就是读入的字符。</li>
</ul>
<p>若遇到输入流中的文件结束符，则函数返回文件结束标志EOF。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;enter a sentence :&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span> ((c = cin.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">        cout.<span class="built_in">put</span>(c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)有一个参数的get函数</p>
<ul>
<li>cin.get(ch)用来从输入流中读取一个字符，赋给字符变量ch。</li>
</ul>
<p>读取成功返回非0值（真），如失败（遇文件结束符）则函数返回0值（假）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;enter a sentence :&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span> (cin.<span class="built_in">get</span>(c)) <span class="comment">//读取一个字符赋给c，如果读取成功，返回真</span></span><br><span class="line">        cout.<span class="built_in">put</span>(c);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)有三个参数的get函数</p>
<ul>
<li>cin.get(字符数组/字符指针，字符个数n，终止字符)</li>
<li>从输入流中读取n-1个字符，赋给指定的字符数组（或字符指针指向的数组）。</li>
<li>如果在读取n-1个字符之前遇到指定的终止字符，则提前读取结束。</li>
<li>如果读取成功返回非0值（真），如失败（遇文件结束符）则函数返回0值（假）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[<span class="number">20</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;enter a sentence:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin.<span class="built_in">get</span>(ch, <span class="number">10</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">    cin.<span class="built_in">get</span>(ch, <span class="number">20</span>, <span class="string">&#x27;\n&#x27;</span>); <span class="comment">//指定换行符为终止字符</span></span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enter a sentence:</span><br><span class="line">you!/her.</span><br><span class="line">you!</span><br><span class="line">/her.</span><br></pre></td></tr></table></figure>
<p>cin.get(ch,20,‘’); &lt;==&gt; cin.get(ch,20);</p>
<h4 id="用getline函数读入一行字符">用getline函数读入一行字符</h4>
<p>cin.getline(字符数组（或字符指针），字符个数n，终止字符)</p>
<p>从输入流中读取一行字符，其用法与带3个参数的get函数类似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[<span class="number">20</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;enter a sentence:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; ch;</span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">    cin.<span class="built_in">getline</span>(ch, <span class="number">20</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">    cin.<span class="built_in">getline</span>(ch, <span class="number">20</span>);</span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enter a sentence:</span><br><span class="line">I like C++./I study C++./I am happy.</span><br><span class="line">I</span><br><span class="line"> like C++.</span><br><span class="line">I study C++./I am h</span><br></pre></td></tr></table></figure>
<h3 id="istream类的其他成员函数">istream类的其他成员函数</h3>
<h4 id="eof函数">eof函数</h4>
<p>无参函数，表示文件结束。</p>
<p>从输入流读取数据，如果到达文件末尾（遇文件结束符），返回非零值（真），否则为0（假）。 while(!cin.eof())</p>
<h4 id="peek函数">peek函数</h4>
<p>无参函数，表示“观察”，观测下一个字符。</p>
<p>返回值是当前指针指向的当前字符，但只是观测，指针仍停留在当前位置，并不后移。</p>
<p>如果要访问的字符是文件结束符，则函数值是EOF。 c=cin.peek()；</p>
<h4 id="putback函数">putback函数</h4>
<p>将前面用get或getline函数从输入流中读取的字符ch返回到输入流，插入到当前指针位置，以供后面读取。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;enter a sentence:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin.<span class="built_in">getline</span>(c, <span class="number">15</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    ch = cin.<span class="built_in">peek</span>(); <span class="comment">//观看当前字符</span></span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">    cin.<span class="built_in">putback</span>(c[<span class="number">0</span>]); <span class="comment">//将‘I’插入到指针所指处</span></span><br><span class="line">    cin.<span class="built_in">getline</span>(c, <span class="number">15</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enter a sentence:</span><br><span class="line">I am a boy./ am a student./</span><br><span class="line">I am a boy.</span><br><span class="line">32</span><br><span class="line">I am a student</span><br></pre></td></tr></table></figure>
<h4 id="ignore函数">ignore函数</h4>
<p>cin.ignore(n,终止字符)</p>
<p>跳过输入流中n个字符，或在遇到指定的终止字符时提前结束（此时跳过包括终止字符在内的若干字符）。</p>
<p>ignore（5，’A’）;//跳过5个字符，遇’A’后不再跳</p>
<p>ignore(); &lt;==&gt; ignore(1,EOF);</p>
<p>不用ignore函数的情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[<span class="number">20</span>];</span><br><span class="line">    cin.<span class="built_in">get</span>(ch, <span class="number">20</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The first part is:&quot;</span> &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">    cin.<span class="built_in">get</span>(ch, <span class="number">20</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The second part is:&quot;</span> &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I like C++./I study C++./I am happy.</span><br><span class="line">The first part is:I like C++.</span><br><span class="line">The second part is:</span><br></pre></td></tr></table></figure>
<p>使用ignore函数的情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[<span class="number">20</span>];</span><br><span class="line">    cin.<span class="built_in">get</span>(ch, <span class="number">20</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The first part is:&quot;</span> &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">    cin.<span class="built_in">ignore</span>(); <span class="comment">//跳过输入流中一个字符</span></span><br><span class="line">    cin.<span class="built_in">get</span>(ch, <span class="number">20</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The second part is:&quot;</span> &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I like C++./I study C++./I am happy.</span><br><span class="line">The first part is:I like C++.</span><br><span class="line">The second part is:I study C++.</span><br></pre></td></tr></table></figure>
<h3 id="用控制符格式化">用控制符格式化</h3>
<p>为了不直接以标志位的方式去处理流的状态， c++标准库提供了标准的控制符专门操控这些状态。</p>
<p>这组控制符不属于任何类成员，定义在iomanip头文件中。</p>
<p>将它们用在提取运算符“&gt;&gt;”或插入运算符“&lt;&lt;”后面来设定输入/输出格式，即在读写对象之间插入一个修改状态的操作。</p>
<p>设置输入/输出宽度setw(int) * 用整型参数来制定输入/输出域的宽度。使用时只对其后一项输入/输出有效。 * 当用于输出时，若实际宽度小于设置宽度时，数据向右对齐，反之则按数据的实际宽度输出。 * 当用于输入时，若输入的数据宽度超过设置宽度时，超出的数据部分被截断而被作为下一项输入内容。</p>
<p>【例】　用控制符示例设置输入/输出宽度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *p = <span class="string">&quot;12345&quot;</span>, *q = <span class="string">&quot;678&quot;</span>;</span><br><span class="line">    <span class="type">char</span> f[<span class="number">4</span>], g[<span class="number">4</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; q &lt;&lt; <span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; p &lt;&lt; q &lt;&lt; endl; <span class="comment">//设置输出宽度</span></span><br><span class="line">    cin &gt;&gt; <span class="built_in">setw</span>(<span class="number">4</span>) &gt;&gt; f &gt;&gt; g;                               <span class="comment">//设置输入宽度</span></span><br><span class="line">    cout &lt;&lt; f &lt;&lt; endl</span><br><span class="line">         &lt;&lt; g &lt;&lt; endl</span><br><span class="line">         &lt;&lt; <span class="string">&quot;i:&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">12345   67812345678</span><br><span class="line">12345</span><br><span class="line">123     //设置宽度为N，那么会截取N-1位</span><br><span class="line">45</span><br><span class="line">i:10</span><br></pre></td></tr></table></figure>
<p>设置输出填充字符setfill(char)</p>
<ul>
<li>与ios::fill相同，常与setw(int)联合使用，从而向不满设置输出宽度的空间填入指定的字符，不设置则填空格。</li>
<li>设置后直至下一次设置前一直有效。</li>
<li>参数可以是字符常量或字符变量。</li>
</ul>
<p>设置输出精度setprecision(int)</p>
<ul>
<li>指明输出实数的有效位数。</li>
<li>参数为0时，按默认有效位数6输出。</li>
<li>在以fixed形式和scientific形式输出时参数为小数位数。</li>
</ul>
<p>setiosflags(ios::fixed)用定点方式表示实数。</p>
<p>setiosflags(ios::scientific)用科学记数法方式表示实数。</p>
<ul>
<li>如果setprecision(n)与setiosflags(ios::fixed)合用，可以控制小数点右边的数字个数。</li>
<li>如果setprecision(n)与setiosflags(ios::scientific)合用，可以控制科学记数法中尾数的小数位数。</li>
</ul>
<p>setiosflags(ios::left)输出数据左对齐</p>
<p>setiosflags(ios::right)输出数据右对齐</p>
<p>setiosflags(ios::uppercase)大写表示</p>
<p>setiosflags(ios::showpos)输出正数时给出“+”号</p>
<p>setiosflags(ios::skipws)忽略前导空格</p>
<p>resetiosflags()终止已设置的输出格式状态，在括号中应指定内容</p>
<p>【例】　设置对齐方式和输出宽度示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> values[] = &#123;<span class="number">1.23</span>, <span class="number">35.36</span>, <span class="number">653.7</span>, <span class="number">4358.24</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *names[] = &#123;<span class="string">&quot;Zoot&quot;</span>, <span class="string">&quot;Jimmy&quot;</span>, <span class="string">&quot;Al&quot;</span>, <span class="string">&quot;Stan&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        cout &lt;&lt; <span class="built_in">setiosflags</span>(ios::left) <span class="comment">//设置左对齐</span></span><br><span class="line">             &lt;&lt; <span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; names[i]</span><br><span class="line">             &lt;&lt; <span class="built_in">resetiosflags</span>(ios::left) <span class="comment">//取消左对齐</span></span><br><span class="line">             &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; values[i]</span><br><span class="line">             &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Zoot        1.23</span><br><span class="line">Jimmy      35.36</span><br><span class="line">Al         653.7</span><br><span class="line">Stan     4358.24</span><br></pre></td></tr></table></figure>
<p>【例】　分别用浮点、定点的方式表示一个实数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> f=<span class="number">22.0</span>/<span class="number">7</span>;</span><br><span class="line">    <span class="comment">//在用浮点形式表示的输出中，setprecision(n)表示实数的有效位数</span></span><br><span class="line">    cout&lt;&lt;f&lt;&lt;endl;                    <span class="comment">//默认有效位数为6</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">3</span>)&lt;&lt;f&lt;&lt;endl;   <span class="comment">//设置有效位数为3</span></span><br><span class="line"><span class="comment">//在用定点形式表示的输出中，setprecision(n)表示实数的小数位数</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">setiosflags</span>(ios::fixed); </span><br><span class="line">    cout&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">8</span>)&lt;&lt;f&lt;&lt;endl;   <span class="comment">//小数位数为8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.14286   </span><br><span class="line">3.14      </span><br><span class="line">3.14285714</span><br></pre></td></tr></table></figure>
<p>设置输入/输出整型数数制dec、hex和oct。</p>
<p>控制换行的控制符endl</p>
<p>代表输出单字符‘\0’的控制符ends</p>
<h3 id="用户自定义控制符函数">用户自定义控制符函数</h3>
<p>建立输出控制符函数的格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">manip_name</span><span class="params">(ostream&amp; stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &lt;自定义语句序列&gt;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【例】 示例用户自定义输出控制符函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">setup</span><span class="params">(ostream&amp; stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stream.<span class="built_in">setf</span>(ios::left);</span><br><span class="line">    stream&lt;&lt;<span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;<span class="built_in">setfill</span>(<span class="string">&#x27;$&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="number">10</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;setup&lt;&lt;<span class="number">10</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 10$$$$$$$$ </span><br></pre></td></tr></table></figure>
<p>建立输入控制符函数的格式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">manip_name</span><span class="params">(istream&amp; stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &lt;自定义语句序列&gt;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">istream&amp; <span class="title">prompt</span><span class="params">(istream&amp; stream)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;hex;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Enter number using hex format：&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    cin&gt;&gt;prompt&gt;&gt;i;</span><br><span class="line">    cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter number using hex format:ff</span><br><span class="line">255</span><br></pre></td></tr></table></figure>
<h2 id="文件的输入输出">文件的输入/输出</h2>
<p>C++把文件看作是一个字符（字节）的序列，即由一个个字符（字节）顺序组成。</p>
<p>根据数据的组织形式，可分为ASCII码文件和二进制文件。</p>
<ul>
<li>ASCII码文件又称为文本文件，它的每一个字节存放一个ASCII码，代表一个字符。</li>
<li>二进制文件是把内存中的数据按其在内存中的存储形式原样输出到磁盘文件存放。</li>
</ul>
<p>由于ASCII码形式与字符一一对应，因此便于对字符进行输出或逐个处理，但它要占用较多的存储空间，若存于二进制文件中，可以节省存储空间，但不能直接输出字符形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">56：ASCII表示为 00110101 00110110，占两字节</span><br><span class="line">56：二进制表示为 111000，占六个二进制位</span><br></pre></td></tr></table></figure>
<h3 id="文件流">文件流</h3>
<p>C++在头文件fstream中定义了C++的文件流类体系 ,当程序中使用文件时，要包含头文件fstream,其中定义了各种文件操作运算符及函数。</p>
<p><img data-src="image-20201208141413317.png" alt="image-20201208141413317" style="zoom:50%;" /></p>
<p>程序对<strong>文本文件</strong>的操作与对键盘、显示器的操作比较：</p>
<p><img data-src="image-20201208141437933.png" alt="image-20201208141437933" style="zoom:50%;" /></p>
<p>在涉及<strong>文本文件</strong>的操作时，将输入文件看成键盘，将输出文件看成显示器，格式不变。<strong>只需在程序中增加打开与关闭文件的语句。</strong></p>
<h3 id="c中进行文件操作的一般步骤">C++中进行文件操作的一般步骤</h3>
<p>为文件定义一个流类对象；</p>
<p>使用open()函数建立（或打开）文件。如果文件不存在，则建立该文件；如果磁盘上已存在该文件，则打开该文件；</p>
<p>进行读写操作。在建立（或打开）的文件上执行所要求的输入/输出操作。一般来说，在内存与文件的数据传输中，由内存到文件称为输出或写，反之则称为输入或读；</p>
<p>使用close()函数关闭文件。当完成操作后，应把打开的文件关闭，避免误操作。</p>
<p>在C++中，打开一个文件就是将这个文件与一个流建立关联；关闭一个文件就是取消这种关联。</p>
<p>open()函数的原型在fstream中定义。其原型为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void open(char *filename,int mod,int access);</span><br></pre></td></tr></table></figure>
<p>其中第一个参数是用来传递文件名；第二个参数的值决定文件的使用方式；第三个参数的值决定文件的访问方式。</p>
<p>对于ifstream流类，mod的值为ios::in;对于ofstream流类，mod的值为ios::out;。</p>
<h3 id="文件的打开与关闭">文件的打开与关闭</h3>
<p>打开文件</p>
<ul>
<li><p>先建立流对象，然后调用函数open连接外部文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">流类  对象名;</span><br><span class="line">对象名.open(文件名,方式);</span><br></pre></td></tr></table></figure></li>
<li><p>调用流类带参数的构造函数，建立流对象的同时连接外部文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">流类 对象名(文件名,方式);</span><br></pre></td></tr></table></figure>
<p>其中，“流类” 为ifstream、ofstream或fstream。</p></li>
</ul>
<p>关闭文件</p>
<ul>
<li><p>使用close()成员函数进行关闭：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">流对象名. close()</span><br></pre></td></tr></table></figure>
<p>其中，流对象名是待关闭的文件流的对象名。</p></li>
</ul>
<p>【例】 示例文件的输入/输出操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ofstream ostrm;       <span class="comment">//定义流类对象</span></span><br><span class="line">    ostrm.<span class="built_in">open</span>(<span class="string">&quot;f1.dat&quot;</span>); <span class="comment">//打开文件</span></span><br><span class="line">    ostrm &lt;&lt; <span class="number">120</span> &lt;&lt; endl; <span class="comment">//写操作</span></span><br><span class="line">    ostrm &lt;&lt; <span class="number">310.85</span> &lt;&lt; endl;</span><br><span class="line">    ostrm.<span class="built_in">close</span>();            <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="function">ifstream <span class="title">istrm</span><span class="params">(<span class="string">&quot;f1.dat&quot;</span>)</span></span>; <span class="comment">//定义流类对象</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    istrm &gt;&gt; n &gt;&gt; d; <span class="comment">//读操作</span></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    istrm.<span class="built_in">close</span>(); <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">120,310.85</span><br></pre></td></tr></table></figure>
<h3 id="文件的读写">文件的读写</h3>
<h4 id="文本文件的读写文本文件用默认方式打开">文本文件的读写：文本文件用默认方式打开。</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> s1[<span class="number">80</span>], s2[<span class="number">8</span>];</span><br><span class="line">    fstream outfile;</span><br><span class="line">    cin &gt;&gt; s1;</span><br><span class="line">    outfile.<span class="built_in">open</span>(<span class="string">&quot;exam.txt&quot;</span>, ios::out);</span><br><span class="line">    <span class="keyword">if</span> (!outfile)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;exam.txt can’t open&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    outfile &lt;&lt; s1;</span><br><span class="line">    outfile.<span class="built_in">close</span>();</span><br><span class="line">    outfile.<span class="built_in">open</span>(<span class="string">&quot;exam.txt&quot;</span>, ios::in);</span><br><span class="line">    outfile &gt;&gt; s2;</span><br><span class="line">    cout &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line">    outfile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二进制文件的读写">二进制文件的读写</h4>
<ul>
<li>若在文件的打开方式中没有特别说明，打开的文件均为ASCII码文件，若要打开二进制文件，则要特别说明并用特定的读写函数。</li>
<li>二进制文件用binary方式打开，读写方式完全由程序控制。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fstream infile, outfile;</span><br><span class="line">infile.<span class="built_in">open</span>(“inf1.dat”, ios::in | ios::binary);</span><br><span class="line"><span class="comment">//           文件名     输入方式打开 二进制文件</span></span><br><span class="line">outfile.<span class="built_in">open</span>(“outf1.dat”, ios::out | ios::binary);</span><br></pre></td></tr></table></figure>
<p>由于二进制文件中的数据不是ASCII码，故不能直接对其读写，必须要通过特定的函数予以转换。</p>
<p>输入函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">infile.<span class="built_in">read</span>( <span class="type">char</span>  *,   <span class="type">int</span> )</span><br><span class="line"><span class="comment">//infile:输入文件对象名，char *:数据进入的内存地址，int:一次读入的字节数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  i;</span><br><span class="line">infile.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;i, <span class="built_in">sizeof</span>(<span class="type">int</span>));<span class="comment">//从文件中输入一个整型数到i</span></span><br><span class="line"><span class="comment">//地址要强制转换成字符型</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int  a[10];</span><br><span class="line">infile.read((char *)a,  10*sizeof(int));//从文件中输入十个整型数到a</span><br></pre></td></tr></table></figure>
<p>输出函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">outfile.<span class="built_in">write</span>( <span class="type">char</span>  *,   <span class="type">int</span> )</span><br><span class="line"><span class="comment">//outfile:输出文件对象名，char *: 要输出的数据在内存中的地址，int: 一次输出的字节数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  i=<span class="number">4</span>;</span><br><span class="line">outfile.<span class="built_in">write</span>((<span class="type">char</span> *)&amp;i, <span class="built_in">sizeof</span>(<span class="type">int</span>));<span class="comment">//向文件输出一个整型数i</span></span><br><span class="line"><span class="comment">//地址要强制转换成字符型</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>  a[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">outfile.<span class="built_in">write</span>((<span class="type">char</span> *)a,  <span class="number">10</span>*<span class="built_in">sizeof</span>(<span class="type">int</span>));<span class="comment">//向文件输出一个整型数组a</span></span><br></pre></td></tr></table></figure>
<p>【例】 二进制文件的读写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">double</span> height;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> age;</span><br><span class="line">&#125; people[<span class="number">3</span>] = &#123;<span class="string">&quot;wang&quot;</span>, <span class="number">1.65</span>, <span class="number">25</span>, <span class="string">&quot;zhang&quot;</span>, <span class="number">1.78</span>, <span class="number">24</span>, <span class="string">&quot;li&quot;</span>, <span class="number">1.85</span>, <span class="number">21</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fstream infile, outfile;</span><br><span class="line">    outfile.<span class="built_in">open</span>(<span class="string">&quot;exam.dat&quot;</span>, ios::out | ios::binary);</span><br><span class="line">    <span class="keyword">if</span> (!outfile)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;exam.dat can&#x27;t open&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        outfile.<span class="built_in">write</span>((<span class="type">char</span> *)&amp;people[i], <span class="built_in">sizeof</span>(people[i]));</span><br><span class="line"></span><br><span class="line">    outfile.<span class="built_in">close</span>();</span><br><span class="line">    infile.<span class="built_in">open</span>(<span class="string">&quot;exam.dat&quot;</span>, ios::in | ios::binary);</span><br><span class="line">    <span class="keyword">if</span> (!infile)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;exam.dat can&#x27;t open&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        infile.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;people[j], <span class="built_in">sizeof</span>(people[j]));</span><br><span class="line">        cout &lt;&lt; people[j].name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; people[j].height &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; people[j].age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    infile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="文件的随机读写">文件的随机读写</h4>
<p>文件打开以后，系统自动生成两个隐含的流指针:读指针和写指针。在输入文件流类中，有关读指针的函数如下：</p>
<h5 id="移动读指针函数">移动读指针函数</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">istream::seekg</span><span class="params">(streampos pos)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数的功能是将输入文件的指针移动到pos指定的位置中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">istream::seekg</span><span class="params">(streamoff offset,seek_dir origin)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，origin的类型seek_dir是一个枚举类型，有以下三种取值：</p>
<p>ios::beg 表示指针的起始位置为文件头</p>
<p>ios::cur 表示指针的起始位置为当前位置</p>
<p>ios::end 表示指针的起始位置为文件尾</p>
<p>该函数的功能是从origin指定的开始位置起，将文件指针移动offset个字节数。</p>
<p>返回读指针当前指向的位置值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">streampos  <span class="title">istream::tellg</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数的功能是确定文件指针的当前位置。</p>
<p>相应地，ostream类提供有关写指针的函数如下：</p>
<h5 id="移动写指针函数">移动写指针函数</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">ostream::seekp</span><span class="params">(streampos pos)</span></span>;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">ostream::seekp</span><span class="params">(streamoff offset,seek_dir origin)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回写指针当前指向的位置值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">streampos <span class="title">ostream::tellp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数参数的意义与读指针函数一样。</p>
<p>【例】 文件的随机读写</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">fstream <span class="title">file</span><span class="params">(<span class="string">&quot;exam.dat&quot;</span>, ios::in | ios::out | ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!file)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;exam.dat can’t open&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++)</span><br><span class="line">        file.<span class="built_in">write</span>((<span class="type">char</span> *)&amp;i, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    streampos pos = file.<span class="built_in">tellp</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;current byte number: &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">15</span>; i &lt; <span class="number">45</span>; i++)</span><br><span class="line">        file.<span class="built_in">write</span>((<span class="type">char</span> *)&amp;i, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    file.<span class="built_in">seekg</span>(pos);</span><br><span class="line">    file.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;i, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The data stored is &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    file.<span class="built_in">seekp</span>(<span class="number">0</span>, ios::beg);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">80</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        file.<span class="built_in">write</span>((<span class="type">char</span> *)&amp;i, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    file.<span class="built_in">seekg</span>(pos);</span><br><span class="line">    file.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;i, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The data stored is &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    file.<span class="built_in">seekp</span>(<span class="number">20</span>, ios::cur);</span><br><span class="line">    file.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;i, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The data stored is&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;current byte number: &quot;</span> &lt;&lt; file.<span class="built_in">tellp</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">current byte number:60</span><br><span class="line">The data stored is 15</span><br><span class="line">The data stored is 95</span><br><span class="line">The data stored is 21</span><br><span class="line">current byte number:88</span><br></pre></td></tr></table></figure>
<h2 id="字符串流内存流">字符串流（内存流）</h2>
<p>以内存中用户定义的字符数组（字符串）作为输入输出的对象，也就是将数据输出到内存中的字符数组，或者从字符数组将数据读入。</p>
<p>字符串流具有相应的缓冲区。</p>
<p>在字符数组中可以存放字符，也可以存放整数、浮点数以及其他类型的数据。</p>
<p><img data-src="image-20201208145138149.png" alt="image-20201208145138149" style="zoom:50%;" /></p>
<h3 id="建立输出字符串流对象">建立输出字符串流对象</h3>
<p>ostrstream类提供的构造函数原型为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ostrstream::<span class="built_in">ostrstream</span>(<span class="type">char</span> *buffer, <span class="type">int</span> n, <span class="type">int</span> mod=ios::out);</span><br></pre></td></tr></table></figure>
<p>buffer是指向字符数组首元素的地址，n为指定的流缓冲区的大小，第3个参数是可选的，默认为 ios::out方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostrstream <span class="title">strout</span><span class="params">(ch1,<span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="建立输入字符串流对象">建立输入字符串流对象</h3>
<p>istrstream类提供了两个带参的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istrstream::<span class="built_in">istrstream</span>(<span class="type">char</span> *buffer);</span><br><span class="line">istrstream::<span class="built_in">istrstream</span>(<span class="type">char</span> *buffer, <span class="type">int</span> n);</span><br></pre></td></tr></table></figure>
<p>buffer是指向字符数组首元素的地址，用它来初始化流对象（使流对象与字符数组建立关联）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istrstream <span class="title">strin</span><span class="params">(ch2)</span></span>;</span><br><span class="line"><span class="function">istrstream <span class="title">strin</span><span class="params">(ch2, <span class="number">20</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="建立输入输出字符串流对象">建立输入输出字符串流对象</h3>
<p>strstream类提供的构造函数原型为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strstream::<span class="built_in">strstream</span>(<span class="type">char</span> *buffer,<span class="type">int</span> n,<span class="type">int</span> mod);</span><br><span class="line"><span class="function">strstream <span class="title">strio</span><span class="params">(ch3, <span class="keyword">sizeof</span>(ch3),ios::in|ios::out)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    student stud[<span class="number">3</span>] = &#123;<span class="number">1001</span>, <span class="string">&quot;Li&quot;</span>, <span class="number">78</span>, <span class="number">1002</span>, <span class="string">&quot;Wang&quot;</span>, <span class="number">89.5</span>, <span class="number">1004</span>, <span class="string">&quot;Fan&quot;</span>, <span class="number">90</span>&#125;;</span><br><span class="line">    <span class="comment">// 数据会被转换成ASCII码后再放入字符数组，一共29个字符</span></span><br><span class="line">    <span class="type">char</span> c[<span class="number">50</span>];                 <span class="comment">//用户定义的字符数组</span></span><br><span class="line">    <span class="function">ostrstream <span class="title">strout</span><span class="params">(c, <span class="number">30</span>)</span></span>;   <span class="comment">//建立输出字符串流，与数组c建立关联，缓冲区长30</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) <span class="comment">//向字符数组c写3个学生的数据</span></span><br><span class="line">        strout &lt;&lt; stud[i].num &lt;&lt; stud[i].name &lt;&lt; stud[i].score;</span><br><span class="line">    strout &lt;&lt; ends;                   <span class="comment">//ends是C++的I/O操作符，插入一个’\0’</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;array c :&quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">//显示字符数组c中的字符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array c:1001Li781002Wang89.51004Fan90</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">50</span>] =“<span class="number">12</span> <span class="number">34</span> <span class="number">65</span> - <span class="number">23</span> - <span class="number">32</span> <span class="number">33</span> <span class="number">61</span> <span class="number">99</span> <span class="number">321</span> <span class="number">32</span>”;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>], i;</span><br><span class="line">    cout &lt;&lt;“array c :” &lt;&lt; c &lt;&lt; endl; <span class="comment">//显示字符数组中的字符串</span></span><br><span class="line">    <span class="function">istrstream <span class="title">strin</span><span class="params">(c, <span class="keyword">sizeof</span>(c))</span></span>;  <span class="comment">//建立输入串流对象strin并与字符数组c关联</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        strin &gt;&gt; a[i]; <span class="comment">//从字符数组c读入10个整数赋给整型数组a</span></span><br><span class="line">    cout &lt;&lt;“array a :”;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt;“ ”;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="function">ostrstream <span class="title">strout</span><span class="params">(c, <span class="keyword">sizeof</span>(c))</span></span>; <span class="comment">//建立输出串流对象strout并与字符数组c关联</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        strout &lt;&lt; a[i] &lt;&lt;“ ”;       <span class="comment">//将10个整数存放在字符数组c</span></span><br><span class="line">    strout &lt;&lt; ends;                 <span class="comment">//加入’\0’</span></span><br><span class="line">    cout &lt;&lt;“array c :“&lt;&lt; c &lt;&lt; endl; <span class="comment">//显示字符数组c</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array c: <span class="number">12</span> <span class="number">34</span> <span class="number">65</span> <span class="number">-23</span> <span class="number">-32</span> <span class="number">33</span> <span class="number">61</span> <span class="number">99</span> <span class="number">321</span> <span class="number">32</span></span><br><span class="line">array a: <span class="number">12</span> <span class="number">34</span> <span class="number">65</span> <span class="number">-23</span> <span class="number">-32</span> <span class="number">33</span> <span class="number">61</span> <span class="number">99</span> <span class="number">321</span> <span class="number">32</span></span><br><span class="line">array c: <span class="number">12</span> <span class="number">34</span> <span class="number">65</span> <span class="number">-23</span> <span class="number">-32</span> <span class="number">33</span> <span class="number">61</span> <span class="number">99</span> <span class="number">321</span> <span class="number">32</span></span><br></pre></td></tr></table></figure>
<h3 id="注意">注意</h3>
<p>字符串流对象关联的是内存中的一个字符数组，因此不需要打开和关闭文件。</p>
<p>通过字符串流从字符数组读数据就如同从键盘读数据一样，可以从字符数组读入字符数据，也可以读入整数、浮点数或其他类型数据。如果不用字符串流，只能从字符数组逐个访问字符，而不能按其他类型的数据形式读取数据。</p>
<p>字符串流关联的字符数组并不一定是专为字符串流而定义的数组，它与一般的字符数组无异，可以对该数组进行其他操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">77</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;12345678901234567890\n&quot;</span>;</span><br><span class="line">    cout.<span class="built_in">fill</span>(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x=&quot;</span>;</span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">    cout.<span class="built_in">setf</span>(ios::left);</span><br><span class="line">    cout.<span class="built_in">fill</span>(<span class="string">&#x27;$&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">0x2a</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;12345678901234567890\n&quot;</span>;</span><br><span class="line">    cout.<span class="built_in">unsetf</span>(ios::left);</span><br><span class="line">    cout.<span class="built_in">fill</span>(<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;y=&quot;</span>;</span><br><span class="line">    cout.<span class="built_in">unsetf</span>(ios::right);</span><br><span class="line">    cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">    cout.<span class="built_in">setf</span>(ios::left);</span><br><span class="line">    cout.<span class="built_in">fill</span>(<span class="string">&#x27;$&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">12345678901234567890</span><br><span class="line">########x=77$$$$$$$$</span><br><span class="line">12345678901234567890</span><br><span class="line">%%%%%%%%y=42$$$$$$$$</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iomanip&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">7</span>, c = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">float</span> x = <span class="number">67.8564</span>, y = <span class="number">-789.124</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="type">long</span> n = <span class="number">1234567</span>;</span><br><span class="line">    <span class="type">unsigned</span> u = <span class="number">65535</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">3</span>) &lt;&lt; a &lt;&lt; <span class="built_in">setw</span>(<span class="number">3</span>) &lt;&lt; b &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">8</span>) &lt;&lt; y;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">3</span>) &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">setw</span>(<span class="number">3</span>) &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;%%&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; dec &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; ch;</span><br><span class="line">    cout &lt;&lt; oct &lt;&lt; ch &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; hex &lt;&lt; ch &lt;&lt; dec &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; oct &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; n &lt;&lt; hex &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; dec &lt;&lt; u &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; oct &lt;&lt; u &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; hex;</span><br><span class="line">    cout &lt;&lt; u &lt;&lt; dec &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; u &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">57</span><br><span class="line">  5  7</span><br><span class="line">67.8564,-789.124</span><br><span class="line">   67.8564,  -789.124</span><br><span class="line">      68,-7.9e+0267.86,-789.17e+01,-8e+02</span><br><span class="line">%%7e+01,  -7.9e+02</span><br><span class="line">A,AA,A</span><br><span class="line">1234567,4553207,12d687</span><br><span class="line">65535,177777,ffff,65535</span><br></pre></td></tr></table></figure>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"b72d5298f3697eb74696","clientSecret":"4cb6a985e89acb4525561d9c1cc12c589a7dccf6","repo":"Miroier.github.io","owner":"Miroier","admin":["Miroier"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/07/07/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%8F%96%E6%A8%A1/" rel="prev" title="快速幂取模">
                  <i class="fa fa-chevron-left"></i> 快速幂取模
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Miroier</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">139k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:06</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.1/jquery.min.js" integrity="sha256-o88AwQnZB+VDvE9tvIXrMQaPlFFSUTR+nldQm1LuPXQ=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>
<script src="//code.tidio.co/k7tfa6s9imp5pjmlgrzj7mnfc5nmbmwq.js"></script>
<script src="/js/third-party/chat/tidio.js"></script>



  <script src="/js/third-party/fancybox.js"></script>


  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->



</body>
</html>
